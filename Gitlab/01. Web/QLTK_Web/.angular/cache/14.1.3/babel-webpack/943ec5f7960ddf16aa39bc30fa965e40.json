{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/sankey/layout.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nvar _SPLINE_TENSION = .3;\nvar _ALIGNMENT_CENTER = \"center\";\nvar _ALIGNMENT_BOTTOM = \"bottom\";\nvar _ALIGNMENT_DEFAULT = _ALIGNMENT_CENTER;\nimport graphModule from \"./graph\";\nimport validatorModule from \"./data_validator\";\nexport var layout = {\n  _weightPerPixel: null,\n  _getCascadeIdx: function (nodeTitle, cascadesConfig) {\n    var nodeInfo = cascadesConfig.filter(c => c.name === nodeTitle)[0];\n\n    if (nodeInfo.outgoing.length > 0) {\n      return nodeInfo.lp;\n    } else {\n      return graphModule.routines.maxOfArray(cascadesConfig.map(c => c.lp));\n    }\n  },\n  _getInWeightForNode: function (nodeTitle, links) {\n    var w = 0;\n    links.forEach(link => {\n      if (link[1] === nodeTitle) {\n        w += link[2];\n      }\n    });\n    return w;\n  },\n  _getOutWeightForNode: function (nodeTitle, links) {\n    var w = 0;\n    links.forEach(link => {\n      if (link[0] === nodeTitle) {\n        w += link[2];\n      }\n    });\n    return w;\n  },\n  _computeCascades: function (links) {\n    var cascadesConfig = graphModule.struct.computeLongestPaths(links);\n    var maxCascade = graphModule.routines.maxOfArray(cascadesConfig.map(c => c.lp));\n    var cascades = [];\n\n    for (var i = 0; i < maxCascade + 1; i++) {\n      cascades.push({});\n    }\n\n    links.forEach(link => {\n      var cascade = cascades[this._getCascadeIdx(link[0], cascadesConfig)];\n\n      if (!cascade[link[0]]) {\n        cascade[link[0]] = {\n          nodeTitle: link[0]\n        };\n      }\n\n      cascade = cascades[this._getCascadeIdx(link[1], cascadesConfig)];\n\n      if (!cascade[link[1]]) {\n        cascade[link[1]] = {\n          nodeTitle: link[1]\n        };\n      }\n    });\n    cascades.forEach(cascade => {\n      Object.keys(cascade).forEach(nodeTitle => {\n        var node = cascade[nodeTitle];\n        node.inWeight = this._getInWeightForNode(node.nodeTitle, links);\n        node.outWeight = this._getOutWeightForNode(node.nodeTitle, links);\n        node.maxWeight = Math.max(node.inWeight, node.outWeight);\n      });\n    });\n    return cascades;\n  },\n  _getWeightForCascade: function (cascades, cascadeIdx) {\n    var wMax = 0;\n    var cascade = cascades[cascadeIdx];\n    Object.keys(cascade).forEach(nodeTitle => {\n      wMax += Math.max(cascade[nodeTitle].inWeight, cascade[nodeTitle].outWeight);\n    });\n    return wMax;\n  },\n  _getMaxWeightThroughCascades: function (cascades) {\n    var max = [];\n    cascades.forEach(cascade => {\n      var mW = 0;\n      Object.keys(cascade).forEach(nodeTitle => {\n        var node = cascade[nodeTitle];\n        mW += Math.max(node.inWeight, node.outWeight);\n      });\n      max.push(mW);\n    });\n    return graphModule.routines.maxOfArray(max);\n  },\n  _computeNodes: function (cascades, options) {\n    var rects = [];\n\n    var maxWeight = this._getMaxWeightThroughCascades(cascades);\n\n    var maxNodeNum = graphModule.routines.maxOfArray(cascades.map(nodesInCascade => Object.keys(nodesInCascade).length));\n    var nodePadding = options.nodePadding;\n    var heightAvailable = options.height - nodePadding * (maxNodeNum - 1);\n\n    if (heightAvailable < 0) {\n      nodePadding = 0;\n      heightAvailable = options.height - nodePadding * (maxNodeNum - 1);\n    }\n\n    this._weightPerPixel = maxWeight / heightAvailable;\n    var cascadeIdx = 0;\n    cascades.forEach(cascade => {\n      var cascadeRects = [];\n      var y = 0;\n      var nodesInCascade = Object.keys(cascade).length;\n      var cascadeHeight = this._getWeightForCascade(cascades, cascadeIdx) / this._weightPerPixel + nodePadding * (nodesInCascade - 1);\n      var cascadeAlign;\n\n      if (Array.isArray(options.nodeAlign)) {\n        cascadeAlign = cascadeIdx < options.nodeAlign.length ? options.nodeAlign[cascadeIdx] : _ALIGNMENT_DEFAULT;\n      } else {\n        cascadeAlign = options.nodeAlign;\n      }\n\n      if (cascadeAlign === _ALIGNMENT_BOTTOM) {\n        y = options.height - cascadeHeight;\n      } else if (cascadeAlign === _ALIGNMENT_CENTER) {\n        y = .5 * (options.height - cascadeHeight);\n      }\n\n      y = Math.round(y);\n      Object.keys(cascade).forEach(nodeTitle => {\n        cascade[nodeTitle].sort = this._sort && Object.prototype.hasOwnProperty.call(this._sort, nodeTitle) ? this._sort[nodeTitle] : 1;\n      });\n      Object.keys(cascade).sort((a, b) => cascade[a].sort - cascade[b].sort).forEach(nodeTitle => {\n        var node = cascade[nodeTitle];\n        var height = Math.floor(heightAvailable * node.maxWeight / maxWeight);\n        var x = Math.round(cascadeIdx * options.width / (cascades.length - 1)) - (0 === cascadeIdx ? 0 : options.nodeWidth);\n        var rect = {};\n        rect._name = nodeTitle;\n        rect.width = options.nodeWidth;\n        rect.height = height;\n        rect.x = x + options.x;\n        rect.y = y + options.y;\n        y += height + nodePadding;\n        cascadeRects.push(rect);\n      });\n      cascadeIdx++;\n      rects.push(cascadeRects);\n    });\n    return rects;\n  },\n  _findRectByName: function (rects, name) {\n    for (var c = 0; c < rects.length; c++) {\n      for (var r = 0; r < rects[c].length; r++) {\n        if (name === rects[c][r]._name) {\n          return rects[c][r];\n        }\n      }\n    }\n\n    return null;\n  },\n  _findIndexByName: function (rects, nodeTitle) {\n    var index = 0;\n\n    for (var c = 0; c < rects.length; c++) {\n      for (var r = 0; r < rects[c].length; r++) {\n        if (nodeTitle === rects[c][r]._name) {\n          return index;\n        }\n\n        index++;\n      }\n    }\n\n    return null;\n  },\n  _computeLinks: function (links, rects, cascades) {\n    var yOffsets = {};\n    var paths = [];\n    var result = [];\n    cascades.forEach(cascade => {\n      Object.keys(cascade).forEach(nodeTitle => {\n        yOffsets[nodeTitle] = {\n          in: 0,\n          out: 0\n        };\n      });\n    });\n    rects.forEach(rectsOfCascade => {\n      rectsOfCascade.forEach(nodeRect => {\n        var nodeTitle = nodeRect._name;\n\n        var rectFrom = this._findRectByName(rects, nodeTitle);\n\n        var linksFromNode = links.filter(link => link[0] === nodeTitle);\n        linksFromNode.forEach(link => {\n          link.sort = this._findIndexByName(rects, link[1]);\n        });\n        linksFromNode.sort((a, b) => a.sort - b.sort).forEach(link => {\n          var rectTo = this._findRectByName(rects, link[1]);\n\n          var height = Math.round(link[2] / this._weightPerPixel);\n          var yOffsetFrom = yOffsets[link[0]].out;\n          var yOffsetTo = yOffsets[link[1]].in;\n          var heightFrom = yOffsets[link[0]].out + height > rectFrom.height ? rectFrom.height - yOffsets[link[0]].out : height;\n          var heightTo = yOffsets[link[1]].in + height > rectTo.height ? rectTo.height - yOffsets[link[1]].in : height;\n          paths.push({\n            from: {\n              x: rectFrom.x,\n              y: rectFrom.y + yOffsetFrom,\n              width: rectFrom.width,\n              height: heightFrom,\n              node: rectFrom,\n              weight: link[2]\n            },\n            to: {\n              x: rectTo.x,\n              y: rectTo.y + yOffsetTo,\n              width: rectTo.width,\n              height: heightTo,\n              node: rectTo\n            }\n          });\n          yOffsets[link[0]].out += height;\n          yOffsets[link[1]].in += height;\n        });\n      });\n    });\n    paths.forEach(link => {\n      var path = {\n        d: this._spline(link.from, link.to),\n        _boundingRect: {\n          x: link.from.x + link.from.width,\n          y: Math.min(link.from.y, link.to.y),\n          width: link.to.x - (link.from.x + link.from.width),\n          height: Math.max(link.from.x + link.from.height, link.to.y + link.to.height) - Math.min(link.from.y, link.to.y)\n        },\n        _weight: link.from.weight,\n        _from: link.from.node,\n        _to: link.to.node\n      };\n      result.push(path);\n    });\n\n    this._fitAllNodesHeight(rects, paths);\n\n    return result;\n  },\n  _fitNodeHeight: function (nodeName, nodeRects, paths) {\n    var targetRect = this._findRectByName(nodeRects, nodeName);\n\n    var heightOfLinksSummaryIn = 0;\n    var heightOfLinksSummaryOut = 0;\n    paths.forEach(function (path) {\n      if (path.from.node._name === nodeName) {\n        heightOfLinksSummaryOut += path.from.height;\n      }\n\n      if (path.to.node._name === nodeName) {\n        heightOfLinksSummaryIn += path.to.height;\n      }\n    });\n    targetRect.height = Math.max(heightOfLinksSummaryIn, heightOfLinksSummaryOut);\n  },\n  _fitAllNodesHeight: function (nodeRects, paths) {\n    for (var c = 0; c < nodeRects.length; c++) {\n      for (var r = 0; r < nodeRects[c].length; r++) {\n        this._fitNodeHeight(nodeRects[c][r]._name, nodeRects, paths);\n      }\n    }\n  },\n  _spline: function (rectLeft, rectRight) {\n    var p_UpLeft = {\n      x: rectLeft.x + rectLeft.width,\n      y: rectLeft.y\n    };\n    var p_DownLeft = {\n      x: rectLeft.x + rectLeft.width,\n      y: rectLeft.y + rectLeft.height\n    };\n    var p_UpRight = {\n      x: rectRight.x,\n      y: rectRight.y\n    };\n    var p_DownRight = {\n      x: rectRight.x,\n      y: rectRight.y + rectRight.height\n    };\n    var curve_width = _SPLINE_TENSION * (p_UpRight.x - p_UpLeft.x);\n    var result = \"M \".concat(p_UpLeft.x, \" \").concat(p_UpLeft.y, \" C \").concat(p_UpLeft.x + curve_width, \" \").concat(p_UpLeft.y, \" \").concat(p_UpRight.x - curve_width, \" \").concat(p_UpRight.y, \" \").concat(p_UpRight.x, \" \").concat(p_UpRight.y, \" L \").concat(p_DownRight.x, \" \").concat(p_DownRight.y, \" C \").concat(p_DownRight.x - curve_width, \" \").concat(p_DownRight.y, \" \").concat(p_DownLeft.x + curve_width, \" \").concat(p_DownLeft.y, \" \").concat(p_DownLeft.x, \" \").concat(p_DownLeft.y, \" Z\");\n    return result;\n  },\n  computeLayout: function (linksData, sortData, options, incidentOccurred) {\n    this._sort = sortData;\n    var result = {};\n    var validateResult = validatorModule.validate(linksData, incidentOccurred);\n\n    if (!validateResult) {\n      result.cascades = this._computeCascades(linksData);\n      result.nodes = this._computeNodes(result.cascades, {\n        width: options.availableRect.width,\n        height: options.availableRect.height,\n        x: options.availableRect.x,\n        y: options.availableRect.y,\n        nodePadding: options.nodePadding,\n        nodeWidth: options.nodeWidth,\n        nodeAlign: options.nodeAlign\n      });\n      result.links = this._computeLinks(linksData, result.nodes, result.cascades);\n    } else {\n      result.error = validateResult;\n    }\n\n    return result;\n  },\n  overlap: function (box1, box2) {\n    return !(box2.x > box1.x + box1.width || box2.x + box2.width < box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}