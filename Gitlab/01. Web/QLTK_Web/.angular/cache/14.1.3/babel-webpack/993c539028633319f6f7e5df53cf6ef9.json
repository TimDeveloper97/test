{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.agenda.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { setOuterHeight, setHeight } from \"../../../core/utils/size\";\nimport $ from \"../../../core/renderer\";\nimport domAdapter from \"../../../core/dom_adapter\";\nimport { noop } from \"../../../core/utils/common\";\nimport { each } from \"../../../core/utils/iterator\";\nimport { getPublicElement } from \"../../../core/element\";\nimport registerComponent from \"../../../core/component_registrator\";\nimport WorkSpace from \"./ui.scheduler.work_space\";\nimport { extend } from \"../../../core/utils/extend\";\nimport dateLocalization from \"../../../localization/date\";\nimport tableCreatorModule from \"../table_creator\";\nimport { TIME_PANEL_CLASS, DATE_TABLE_CLASS, DATE_TABLE_ROW_CLASS, GROUP_ROW_CLASS, GROUP_HEADER_CONTENT_CLASS } from \"../classes\";\nimport { createReducedResourcesTree, getDataAccessors, getPathToLeaf } from \"../resources/utils\";\nimport { calculateStartViewDate } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/agenda\";\nimport { formatWeekday, getVerticalGroupCountClass } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { VIEWS } from \"../constants\";\nimport dateUtils from \"../../../core/utils/date\";\nvar {\n  tableCreator: tableCreator\n} = tableCreatorModule;\nvar AGENDA_CLASS = \"dx-scheduler-agenda\";\nvar AGENDA_DATE_CLASS = \"dx-scheduler-agenda-date\";\nvar GROUP_TABLE_CLASS = \"dx-scheduler-group-table\";\nvar TIME_PANEL_ROW_CLASS = \"dx-scheduler-time-panel-row\";\nvar TIME_PANEL_CELL_CLASS = \"dx-scheduler-time-panel-cell\";\nvar NODATA_CONTAINER_CLASS = \"dx-scheduler-agenda-nodata\";\nvar LAST_ROW_CLASS = \"dx-scheduler-date-table-last-row\";\nvar INNER_CELL_MARGIN = 5;\nvar OUTER_CELL_MARGIN = 20;\n\nclass SchedulerAgenda extends WorkSpace {\n  get type() {\n    return VIEWS.AGENDA;\n  }\n\n  get renderingStrategy() {\n    return this.invoke(\"getLayoutManager\").getRenderingStrategyInstance();\n  }\n\n  get appointmentDataProvider() {\n    return this.option(\"getAppointmentDataProvider\")();\n  }\n\n  getStartViewDate() {\n    return this._startViewDate;\n  }\n\n  _init() {\n    super._init();\n\n    this._activeStateUnit = void 0;\n  }\n\n  _getDefaultOptions() {\n    return extend(super._getDefaultOptions(), {\n      agendaDuration: 7,\n      rowHeight: 60,\n      noDataText: \"\"\n    });\n  }\n\n  _optionChanged(args) {\n    var name = args.name;\n    var value = args.value;\n\n    switch (name) {\n      case \"agendaDuration\":\n        break;\n\n      case \"noDataText\":\n      case \"rowHeight\":\n        this._recalculateAgenda(this._rows);\n\n        break;\n\n      case \"groups\":\n        if (!value || !value.length) {\n          if (this._$groupTable) {\n            this._$groupTable.remove();\n\n            this._$groupTable = null;\n\n            this._detachGroupCountClass();\n          }\n        } else if (!this._$groupTable) {\n          this._initGroupTable();\n\n          this._dateTableScrollable.$content().prepend(this._$groupTable);\n        }\n\n        super._optionChanged(args);\n\n        break;\n\n      default:\n        super._optionChanged(args);\n\n    }\n  }\n\n  _renderFocusState() {\n    return noop();\n  }\n\n  _renderFocusTarget() {\n    return noop();\n  }\n\n  _cleanFocusState() {\n    return noop();\n  }\n\n  supportAllDayRow() {\n    return false;\n  }\n\n  _isVerticalGroupedWorkSpace() {\n    return false;\n  }\n\n  _getElementClass() {\n    return AGENDA_CLASS;\n  }\n\n  _calculateStartViewDate() {\n    return calculateStartViewDate(this.option(\"currentDate\"), this.option(\"startDayHour\"));\n  }\n\n  _getRowCount() {\n    return this.option(\"agendaDuration\");\n  }\n\n  _getCellCount() {\n    return 1;\n  }\n\n  _getTimePanelRowCount() {\n    return this.option(\"agendaDuration\");\n  }\n\n  _renderAllDayPanel() {\n    return noop();\n  }\n\n  _toggleAllDayVisibility() {\n    return noop();\n  }\n\n  _initWorkSpaceUnits() {\n    this._initGroupTable();\n\n    this._$timePanel = $(\"<table>\").addClass(TIME_PANEL_CLASS);\n    this._$dateTable = $(\"<table>\").addClass(DATE_TABLE_CLASS);\n    this._$dateTableScrollableContent = $(\"<div>\").addClass(\"dx-scheduler-date-table-scrollable-content\");\n    this._$dateTableContainer = $(\"<div>\").addClass(\"dx-scheduler-date-table-container\");\n  }\n\n  _initGroupTable() {\n    var groups = this.option(\"groups\");\n\n    if (groups && groups.length) {\n      this._$groupTable = $(\"<table>\").addClass(GROUP_TABLE_CLASS);\n    }\n  }\n\n  _renderView() {\n    this._startViewDate = this._calculateStartViewDate();\n    this._rows = [];\n\n    this._initPositionHelper();\n  }\n\n  _recalculateAgenda(rows) {\n    var cellTemplates = [];\n\n    this._cleanView();\n\n    if (this._rowsIsEmpty(rows)) {\n      this._renderNoData();\n\n      return;\n    }\n\n    this._rows = rows;\n\n    if (this._$groupTable) {\n      cellTemplates = this._renderGroupHeader();\n\n      this._setGroupHeaderCellsHeight();\n    }\n\n    this._renderTimePanel();\n\n    this._renderDateTable();\n\n    this.invoke(\"onAgendaReady\", rows);\n\n    this._applyCellTemplates(cellTemplates);\n\n    this._dateTableScrollable.update();\n  }\n\n  _renderNoData() {\n    this._$noDataContainer = $(\"<div>\").addClass(NODATA_CONTAINER_CLASS).html(this.option(\"noDataText\"));\n\n    this._dateTableScrollable.$content().append(this._$noDataContainer);\n  }\n\n  _setTableSizes() {\n    return noop();\n  }\n\n  _toggleHorizontalScrollClass() {\n    return noop();\n  }\n\n  _createCrossScrollingConfig() {\n    return noop();\n  }\n\n  _setGroupHeaderCellsHeight() {\n    var $cells = this._getGroupHeaderCells().filter(function (_, element) {\n      return !element.getAttribute(\"rowSpan\");\n    });\n\n    var rows = this._removeEmptyRows(this._rows);\n\n    if (!rows.length) {\n      return;\n    }\n\n    for (var i = 0; i < $cells.length; i++) {\n      var $cellContent = $cells.eq(i).find(\".dx-scheduler-group-header-content\");\n      setOuterHeight($cellContent, this._getGroupRowHeight(rows[i]));\n    }\n  }\n\n  _rowsIsEmpty(rows) {\n    var result = true;\n\n    for (var i = 0; i < rows.length; i++) {\n      var groupRow = rows[i];\n\n      for (var j = 0; j < groupRow.length; j++) {\n        if (groupRow[j]) {\n          result = false;\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  _attachGroupCountClass() {\n    var className = getVerticalGroupCountClass(this.option(\"groups\"));\n    this.$element().addClass(className);\n  }\n\n  _removeEmptyRows(rows) {\n    var result = [];\n\n    for (var i = 0; i < rows.length; i++) {\n      if (rows[i].length && !(data = rows[i], !data.some(function (value) {\n        return value > 0;\n      }))) {\n        result.push(rows[i]);\n      }\n    }\n\n    var data;\n    return result;\n  }\n\n  _getGroupHeaderContainer() {\n    return this._$groupTable;\n  }\n\n  _makeGroupRows() {\n    var tree = createReducedResourcesTree(this.option(\"loadedResources\"), (field, action) => getDataAccessors(this.option(\"getResourceDataAccessors\")(), field, action), this.option(\"getFilteredItems\")());\n    var cellTemplate = this.option(\"resourceCellTemplate\");\n    var getGroupHeaderContentClass = GROUP_HEADER_CONTENT_CLASS;\n    var cellTemplates = [];\n    var table = tableCreator.makeGroupedTableFromJSON(tableCreator.VERTICAL, tree, {\n      cellTag: \"th\",\n      groupTableClass: GROUP_TABLE_CLASS,\n      groupRowClass: GROUP_ROW_CLASS,\n      groupCellClass: this._getGroupHeaderClass(),\n\n      groupCellCustomContent(cell, cellText, index, data) {\n        var container = domAdapter.createElement(\"div\");\n        var contentWrapper = domAdapter.createElement(\"div\");\n        container.className = getGroupHeaderContentClass;\n        contentWrapper.appendChild(cellText);\n        container.appendChild(contentWrapper);\n        container.className = getGroupHeaderContentClass;\n\n        if (cellTemplate && cellTemplate.render) {\n          cellTemplates.push(cellTemplate.render.bind(cellTemplate, {\n            model: {\n              data: data.data,\n              id: data.value,\n              color: data.color,\n              text: cellText.textContent\n            },\n            container: getPublicElement($(container)),\n            index: index\n          }));\n        } else {\n          contentWrapper.appendChild(cellText);\n          container.appendChild(contentWrapper);\n        }\n\n        cell.appendChild(container);\n      },\n\n      cellTemplate: cellTemplate\n    });\n    return {\n      elements: $(table).find(\".\".concat(GROUP_ROW_CLASS)),\n      cellTemplates: cellTemplates\n    };\n  }\n\n  _cleanView() {\n    this._$dateTable.empty();\n\n    this._$timePanel.empty();\n\n    if (this._$groupTable) {\n      this._$groupTable.empty();\n    }\n\n    if (this._$noDataContainer) {\n      this._$noDataContainer.empty();\n\n      this._$noDataContainer.remove();\n\n      delete this._$noDataContainer;\n    }\n  }\n\n  _createWorkSpaceElements() {\n    this._createWorkSpaceStaticElements();\n  }\n\n  _createWorkSpaceStaticElements() {\n    this._$dateTableContainer.append(this._$dateTable);\n\n    this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);\n\n    if (this._$groupTable) {\n      this._$dateTableScrollableContent.prepend(this._$groupTable);\n    }\n\n    this._$dateTableScrollableContent.append(this._$timePanel, this._$dateTableContainer);\n\n    this.$element().append(this._dateTableScrollable.$element());\n  }\n\n  _renderDateTable() {\n    this._renderTableBody({\n      container: getPublicElement(this._$dateTable),\n      rowClass: DATE_TABLE_ROW_CLASS,\n      cellClass: this._getDateTableCellClass()\n    });\n  }\n\n  _attachTablesEvents() {\n    return noop();\n  }\n\n  _attachEvents() {\n    return noop();\n  }\n\n  _cleanCellDataCache() {\n    return noop();\n  }\n\n  isIndicationAvailable() {\n    return false;\n  }\n\n  _prepareCellTemplateOptions(text, date, rowIndex, $cell) {\n    var groupsOpt = this.option(\"groups\");\n    var groups = {};\n    var isGroupedView = !!groupsOpt.length;\n    var path = isGroupedView && getPathToLeaf(rowIndex, groupsOpt) || [];\n    path.forEach(function (resourceValue, resourceIndex) {\n      var resourceName = groupsOpt[resourceIndex].name;\n      groups[resourceName] = resourceValue;\n    });\n    var groupIndex = isGroupedView ? this._getGroupIndexByResourceId(groups) : void 0;\n    return {\n      model: {\n        text: text,\n        date: date,\n        groups: groups,\n        groupIndex: groupIndex\n      },\n      container: getPublicElement($cell),\n      index: rowIndex\n    };\n  }\n\n  _renderTableBody(options) {\n    var cellTemplates = [];\n    var cellTemplateOpt = options.cellTemplate;\n    this._$rows = [];\n    var i;\n\n    var fillTableBody = function (rowIndex, rowSize) {\n      if (rowSize) {\n        var date;\n        var cellDateNumber;\n        var cellDayName;\n        var $row = $(\"<tr>\");\n        var $td = $(\"<td>\");\n        setHeight($td, this._getRowHeight(rowSize));\n\n        if (options.getStartDate) {\n          date = options.getStartDate && options.getStartDate(rowIndex);\n          cellDateNumber = dateLocalization.format(date, \"d\");\n          cellDayName = dateLocalization.format(date, formatWeekday);\n        }\n\n        if (cellTemplateOpt && cellTemplateOpt.render) {\n          var templateOptions = this._prepareCellTemplateOptions(cellDateNumber + \" \" + cellDayName, date, i, $td);\n\n          cellTemplates.push(cellTemplateOpt.render.bind(cellTemplateOpt, templateOptions));\n        } else if (cellDateNumber && cellDayName) {\n          $td.addClass(AGENDA_DATE_CLASS).text(cellDateNumber + \" \" + cellDayName);\n        }\n\n        if (options.rowClass) {\n          $row.addClass(options.rowClass);\n        }\n\n        if (options.cellClass) {\n          $td.addClass(options.cellClass);\n        }\n\n        $row.append($td);\n\n        this._$rows.push($row);\n      }\n    }.bind(this);\n\n    for (i = 0; i < this._rows.length; i++) {\n      each(this._rows[i], fillTableBody);\n\n      this._setLastRowClass();\n    }\n\n    $(options.container).append($(\"<tbody>\").append(this._$rows));\n\n    this._applyCellTemplates(cellTemplates);\n  }\n\n  _setLastRowClass() {\n    if (this._rows.length > 1 && this._$rows.length) {\n      var $lastRow = this._$rows[this._$rows.length - 1];\n      $lastRow.addClass(LAST_ROW_CLASS);\n    }\n  }\n\n  _renderTimePanel() {\n    this._renderTableBody({\n      container: getPublicElement(this._$timePanel),\n      rowCount: this._getTimePanelRowCount(),\n      cellCount: 1,\n      rowClass: TIME_PANEL_ROW_CLASS,\n      cellClass: TIME_PANEL_CELL_CLASS,\n      cellTemplate: this.option(\"dateCellTemplate\"),\n      getStartDate: this._getTimePanelStartDate.bind(this)\n    });\n  }\n\n  _getTimePanelStartDate(rowIndex) {\n    var current = new Date(this.option(\"currentDate\"));\n    var cellDate = new Date(current.setDate(current.getDate() + rowIndex));\n    return cellDate;\n  }\n\n  _getRowHeight(rowSize) {\n    var baseHeight = this.option(\"rowHeight\");\n    var innerOffset = (rowSize - 1) * INNER_CELL_MARGIN;\n    return rowSize ? baseHeight * rowSize + innerOffset + OUTER_CELL_MARGIN : 0;\n  }\n\n  _getGroupRowHeight(groupRows) {\n    if (!groupRows) {\n      return;\n    }\n\n    var result = 0;\n\n    for (var i = 0; i < groupRows.length; i++) {\n      result += this._getRowHeight(groupRows[i]);\n    }\n\n    return result;\n  }\n\n  _calculateRows(appointments) {\n    return this.renderingStrategy.calculateRows(appointments, this.option(\"agendaDuration\"), this.option(\"currentDate\"));\n  }\n\n  onDataSourceChanged(appointments) {\n    super.onDataSourceChanged();\n\n    this._renderView();\n\n    var rows = this._calculateRows(appointments);\n\n    this._recalculateAgenda(rows);\n  }\n\n  getAgendaVerticalStepHeight() {\n    return this.option(\"rowHeight\");\n  }\n\n  getEndViewDate() {\n    var currentDate = new Date(this.option(\"currentDate\"));\n    var agendaDuration = this.option(\"agendaDuration\");\n    currentDate.setHours(this.option(\"endDayHour\"));\n    var result = currentDate.setDate(currentDate.getDate() + agendaDuration - 1) - 6e4;\n    return new Date(result);\n  }\n\n  getEndViewDateByEndDayHour() {\n    return this.getEndViewDate();\n  }\n\n  getCellDataByCoordinates() {\n    return {\n      startDate: null,\n      endDate: null\n    };\n  }\n\n  updateScrollPosition(date) {\n    var newDate = this.timeZoneCalculator.createDate(date, {\n      path: \"toGrid\"\n    });\n    var bounds = this.getVisibleBounds();\n    var startDateHour = newDate.getHours();\n    var startDateMinutes = newDate.getMinutes();\n\n    if (this.needUpdateScrollPosition(startDateHour, startDateMinutes, bounds, newDate)) {\n      this.scrollToTime(startDateHour, startDateMinutes, newDate);\n    }\n  }\n\n  needUpdateScrollPosition(hours, minutes, bounds) {\n    var isUpdateNeeded = false;\n\n    if (hours < bounds.top.hours || hours > bounds.bottom.hours) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.top.hours && minutes < bounds.top.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.bottom.hours && minutes > bounds.top.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    return isUpdateNeeded;\n  }\n\n  renovatedRenderSupported() {\n    return false;\n  }\n\n  _setSelectedCellsByCellData() {}\n\n  _getIntervalDuration() {\n    return dateUtils.dateToMilliseconds(\"day\") * this.option(\"intervalCount\");\n  }\n\n  getDOMElementsMetaData() {\n    return {\n      dateTableCellsMeta: [[{}]],\n      allDayPanelCellsMeta: [{}]\n    };\n  }\n\n}\n\nregisterComponent(\"dxSchedulerAgenda\", SchedulerAgenda);\nexport default SchedulerAgenda;","map":null,"metadata":{},"sourceType":"module"}