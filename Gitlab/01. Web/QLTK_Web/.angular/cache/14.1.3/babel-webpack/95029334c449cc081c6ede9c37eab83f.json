{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/validation_engine.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport Class from \"../core/class\";\nimport { extend } from \"../core/utils/extend\";\nimport { each } from \"../core/utils/iterator\";\nimport { EventsStrategy } from \"../core/events_strategy\";\nimport errors from \"../core/errors\";\nimport { grep } from \"../core/utils/common\";\nimport { isDefined, isString, isDate, isBoolean, isObject, isFunction, isPromise, isNumeric } from \"../core/utils/type\";\nimport numberLocalization from \"../localization/number\";\nimport messageLocalization from \"../localization/message\";\nimport { fromPromise, Deferred } from \"../core/utils/deferred\";\nvar STATUS = {\n  valid: \"valid\",\n  invalid: \"invalid\",\n  pending: \"pending\"\n};\n\nclass BaseRuleValidator {\n  constructor() {\n    this.NAME = \"base\";\n  }\n\n  defaultMessage(value) {\n    return messageLocalization.getFormatter(\"validation-\".concat(this.NAME))(value);\n  }\n\n  defaultFormattedMessage(value) {\n    return messageLocalization.getFormatter(\"validation-\".concat(this.NAME, \"-formatted\"))(value);\n  }\n\n  _isValueEmpty(value) {\n    return !rulesValidators.required.validate(value, {});\n  }\n\n  validate(value, rule) {\n    var valueArray = Array.isArray(value) ? value : [value];\n    var result = true;\n\n    if (valueArray.length) {\n      valueArray.every(itemValue => {\n        result = this._validate(itemValue, rule);\n        return result;\n      });\n    } else {\n      result = this._validate(null, rule);\n    }\n\n    return result;\n  }\n\n}\n\nclass RequiredRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"required\";\n  }\n\n  _validate(value, rule) {\n    if (!isDefined(value)) {\n      return false;\n    }\n\n    if (false === value) {\n      return false;\n    }\n\n    value = String(value);\n\n    if (rule.trim || !isDefined(rule.trim)) {\n      value = value.trim();\n    }\n\n    return \"\" !== value;\n  }\n\n}\n\nclass NumericRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"numeric\";\n  }\n\n  _validate(value, rule) {\n    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n\n    if (rule.useCultureSettings && isString(value)) {\n      return !isNaN(numberLocalization.parse(value));\n    } else {\n      return isNumeric(value);\n    }\n  }\n\n}\n\nclass RangeRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"range\";\n  }\n\n  _validate(value, rule) {\n    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n\n    var validNumber = rulesValidators.numeric.validate(value, rule);\n    var validValue = isDefined(value) && \"\" !== value;\n    var number = validNumber ? parseFloat(value) : validValue && value.valueOf();\n    var min = rule.min;\n    var max = rule.max;\n\n    if (!(validNumber || isDate(value)) && !validValue) {\n      return false;\n    }\n\n    if (isDefined(min)) {\n      if (isDefined(max)) {\n        return number >= min && number <= max;\n      }\n\n      return number >= min;\n    } else if (isDefined(max)) {\n      return number <= max;\n    } else {\n      throw errors.Error(\"E0101\");\n    }\n  }\n\n}\n\nclass StringLengthRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"stringLength\";\n  }\n\n  _validate(value, rule) {\n    var _value;\n\n    value = String(null !== (_value = value) && void 0 !== _value ? _value : \"\");\n\n    if (rule.trim || !isDefined(rule.trim)) {\n      value = value.trim();\n    }\n\n    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n\n    return rulesValidators.range.validate(value.length, extend({}, rule));\n  }\n\n}\n\nclass CustomRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"custom\";\n  }\n\n  validate(value, rule) {\n    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n\n    var validator = rule.validator;\n    var dataGetter = validator && isFunction(validator.option) && validator.option(\"dataGetter\");\n    var extraParams = isFunction(dataGetter) && dataGetter();\n    var params = {\n      value: value,\n      validator: validator,\n      rule: rule\n    };\n\n    if (extraParams) {\n      extend(params, extraParams);\n    }\n\n    return rule.validationCallback(params);\n  }\n\n}\n\nclass AsyncRuleValidator extends CustomRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"async\";\n  }\n\n  validate(value, rule) {\n    if (!isDefined(rule.reevaluate)) {\n      extend(rule, {\n        reevaluate: true\n      });\n    }\n\n    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n\n    var validator = rule.validator;\n    var dataGetter = validator && isFunction(validator.option) && validator.option(\"dataGetter\");\n    var extraParams = isFunction(dataGetter) && dataGetter();\n    var params = {\n      value: value,\n      validator: validator,\n      rule: rule\n    };\n\n    if (extraParams) {\n      extend(params, extraParams);\n    }\n\n    var callbackResult = rule.validationCallback(params);\n\n    if (!isPromise(callbackResult)) {\n      throw errors.Error(\"E0103\");\n    }\n\n    return this._getWrappedPromise(fromPromise(callbackResult).promise());\n  }\n\n  _getWrappedPromise(promise) {\n    var deferred = new Deferred();\n    promise.then(function (res) {\n      deferred.resolve(res);\n    }, function (err) {\n      var res = {\n        isValid: false\n      };\n\n      if (isDefined(err)) {\n        if (isString(err)) {\n          res.message = err;\n        } else if (isObject(err) && isDefined(err.message) && isString(err.message)) {\n          res.message = err.message;\n        }\n      }\n\n      deferred.resolve(res);\n    });\n    return deferred.promise();\n  }\n\n}\n\nclass CompareRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"compare\";\n  }\n\n  _validate(value, rule) {\n    if (!rule.comparisonTarget) {\n      throw errors.Error(\"E0102\");\n    }\n\n    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n\n    extend(rule, {\n      reevaluate: true\n    });\n    var otherValue = rule.comparisonTarget();\n    var type = rule.comparisonType || \"==\";\n\n    switch (type) {\n      case \"==\":\n        return value == otherValue;\n\n      case \"!=\":\n        return value != otherValue;\n\n      case \"===\":\n        return value === otherValue;\n\n      case \"!==\":\n        return value !== otherValue;\n\n      case \">\":\n        return value > otherValue;\n\n      case \">=\":\n        return value >= otherValue;\n\n      case \"<\":\n        return value < otherValue;\n\n      case \"<=\":\n        return value <= otherValue;\n    }\n  }\n\n}\n\nclass PatternRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"pattern\";\n  }\n\n  _validate(value, rule) {\n    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n\n    var pattern = rule.pattern;\n\n    if (isString(pattern)) {\n      pattern = new RegExp(pattern);\n    }\n\n    return pattern.test(value);\n  }\n\n}\n\nclass EmailRuleValidator extends BaseRuleValidator {\n  constructor() {\n    super();\n    this.NAME = \"email\";\n  }\n\n  _validate(value, rule) {\n    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value)) {\n      return true;\n    }\n\n    return rulesValidators.pattern.validate(value, extend({}, rule, {\n      pattern: /^[\\d\\w._-]+@[\\d\\w._-]+\\.[\\w]+$/i\n    }));\n  }\n\n}\n\nvar rulesValidators = {\n  required: new RequiredRuleValidator(),\n  numeric: new NumericRuleValidator(),\n  range: new RangeRuleValidator(),\n  stringLength: new StringLengthRuleValidator(),\n  custom: new CustomRuleValidator(),\n  async: new AsyncRuleValidator(),\n  compare: new CompareRuleValidator(),\n  pattern: new PatternRuleValidator(),\n  email: new EmailRuleValidator()\n};\nvar GroupConfig = Class.inherit({\n  ctor(group) {\n    this.group = group;\n    this.validators = [];\n    this._pendingValidators = [];\n    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);\n\n    this._resetValidationInfo();\n\n    this._eventsStrategy = new EventsStrategy(this);\n  },\n\n  validate() {\n    var result = {\n      isValid: true,\n      brokenRules: [],\n      validators: [],\n      status: STATUS.valid,\n      complete: null\n    };\n\n    this._unsubscribeFromAllChangeEvents();\n\n    this._pendingValidators = [];\n\n    this._resetValidationInfo();\n\n    each(this.validators, (_, validator) => {\n      var validatorResult = validator.validate();\n      result.isValid = result.isValid && validatorResult.isValid;\n\n      if (validatorResult.brokenRules) {\n        result.brokenRules = result.brokenRules.concat(validatorResult.brokenRules);\n      }\n\n      result.validators.push(validator);\n\n      if (validatorResult.status === STATUS.pending) {\n        this._addPendingValidator(validator);\n      }\n\n      this._subscribeToChangeEvents(validator);\n    });\n\n    if (this._pendingValidators.length) {\n      result.status = STATUS.pending;\n    } else {\n      result.status = result.isValid ? STATUS.valid : STATUS.invalid;\n\n      this._unsubscribeFromAllChangeEvents();\n\n      this._raiseValidatedEvent(result);\n    }\n\n    this._updateValidationInfo(result);\n\n    return extend({}, this._validationInfo.result);\n  },\n\n  _subscribeToChangeEvents(validator) {\n    validator.on(\"validating\", this._onValidatorStatusChanged);\n    validator.on(\"validated\", this._onValidatorStatusChanged);\n  },\n\n  _unsubscribeFromChangeEvents(validator) {\n    validator.off(\"validating\", this._onValidatorStatusChanged);\n    validator.off(\"validated\", this._onValidatorStatusChanged);\n  },\n\n  _unsubscribeFromAllChangeEvents() {\n    each(this.validators, (_, validator) => {\n      this._unsubscribeFromChangeEvents(validator);\n    });\n  },\n\n  _updateValidationInfo(result) {\n    this._validationInfo.result = result;\n\n    if (result.status !== STATUS.pending) {\n      return;\n    }\n\n    if (!this._validationInfo.deferred) {\n      this._validationInfo.deferred = new Deferred();\n      this._validationInfo.result.complete = this._validationInfo.deferred.promise();\n    }\n  },\n\n  _addPendingValidator(validator) {\n    var foundValidator = grep(this._pendingValidators, function (val) {\n      return val === validator;\n    })[0];\n\n    if (!foundValidator) {\n      this._pendingValidators.push(validator);\n    }\n  },\n\n  _removePendingValidator(validator) {\n    var index = this._pendingValidators.indexOf(validator);\n\n    if (index >= 0) {\n      this._pendingValidators.splice(index, 1);\n    }\n  },\n\n  _orderBrokenRules(brokenRules) {\n    var orderedRules = [];\n    each(this.validators, function (_, validator) {\n      var foundRules = grep(brokenRules, function (rule) {\n        return rule.validator === validator;\n      });\n\n      if (foundRules.length) {\n        orderedRules = orderedRules.concat(foundRules);\n      }\n    });\n    return orderedRules;\n  },\n\n  _updateBrokenRules(result) {\n    if (!this._validationInfo.result) {\n      return;\n    }\n\n    var brokenRules = this._validationInfo.result.brokenRules;\n    var rules = grep(brokenRules, function (rule) {\n      return rule.validator !== result.validator;\n    });\n\n    if (result.brokenRules) {\n      brokenRules = rules.concat(result.brokenRules);\n    }\n\n    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);\n  },\n\n  _onValidatorStatusChanged(result) {\n    if (result.status === STATUS.pending) {\n      this._addPendingValidator(result.validator);\n\n      return;\n    }\n\n    this._resolveIfComplete(result);\n  },\n\n  _resolveIfComplete(result) {\n    this._removePendingValidator(result.validator);\n\n    this._updateBrokenRules(result);\n\n    if (!this._pendingValidators.length) {\n      this._unsubscribeFromAllChangeEvents();\n\n      if (!this._validationInfo.result) {\n        return;\n      }\n\n      this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;\n      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;\n      var res = extend({}, this._validationInfo.result, {\n        complete: null\n      });\n      var deferred = this._validationInfo.deferred;\n      this._validationInfo.deferred = null;\n\n      this._raiseValidatedEvent(res);\n\n      deferred && setTimeout(() => {\n        deferred.resolve(res);\n      });\n    }\n  },\n\n  _raiseValidatedEvent(result) {\n    this._eventsStrategy.fireEvent(\"validated\", [result]);\n  },\n\n  _resetValidationInfo() {\n    this._validationInfo = {\n      result: null,\n      deferred: null\n    };\n  },\n\n  _synchronizeValidationInfo() {\n    if (this._validationInfo.result) {\n      this._validationInfo.result.validators = this.validators;\n    }\n  },\n\n  removeRegisteredValidator(validator) {\n    var index = this.validators.indexOf(validator);\n\n    if (index > -1) {\n      this.validators.splice(index, 1);\n\n      this._synchronizeValidationInfo();\n\n      this._resolveIfComplete({\n        validator: validator\n      });\n    }\n  },\n\n  registerValidator(validator) {\n    if (!this.validators.includes(validator)) {\n      this.validators.push(validator);\n\n      this._synchronizeValidationInfo();\n    }\n  },\n\n  reset() {\n    each(this.validators, function (_, validator) {\n      validator.reset();\n    });\n    this._pendingValidators = [];\n\n    this._resetValidationInfo();\n  },\n\n  on(eventName, eventHandler) {\n    this._eventsStrategy.on(eventName, eventHandler);\n\n    return this;\n  },\n\n  off(eventName, eventHandler) {\n    this._eventsStrategy.off(eventName, eventHandler);\n\n    return this;\n  }\n\n});\nvar ValidationEngine = {\n  groups: [],\n\n  getGroupConfig(group) {\n    var result = grep(this.groups, function (config) {\n      return config.group === group;\n    });\n\n    if (result.length) {\n      return result[0];\n    }\n  },\n\n  findGroup($element, model) {\n    var _$element$data, _$element$data$dxComp;\n\n    var hasValidationGroup = null === (_$element$data = $element.data()) || void 0 === _$element$data ? void 0 : null === (_$element$data$dxComp = _$element$data.dxComponents) || void 0 === _$element$data$dxComp ? void 0 : _$element$data$dxComp.includes(\"dxValidationGroup\");\n    var validationGroup = hasValidationGroup && $element.dxValidationGroup(\"instance\");\n\n    if (validationGroup) {\n      return validationGroup;\n    }\n\n    var $dxGroup = $element.parents(\".dx-validationgroup\").first();\n\n    if ($dxGroup.length) {\n      return $dxGroup.dxValidationGroup(\"instance\");\n    }\n\n    return model;\n  },\n\n  initGroups() {\n    this.groups = [];\n    this.addGroup();\n  },\n\n  addGroup(group) {\n    var config = this.getGroupConfig(group);\n\n    if (!config) {\n      config = new GroupConfig(group);\n      this.groups.push(config);\n    }\n\n    return config;\n  },\n\n  removeGroup(group) {\n    var config = this.getGroupConfig(group);\n    var index = this.groups.indexOf(config);\n\n    if (index > -1) {\n      this.groups.splice(index, 1);\n    }\n\n    return config;\n  },\n\n  _setDefaultMessage(info) {\n    var {\n      rule: rule,\n      validator: validator,\n      name: name\n    } = info;\n\n    if (!isDefined(rule.message)) {\n      if (validator.defaultFormattedMessage && isDefined(name)) {\n        rule.message = validator.defaultFormattedMessage(name);\n      } else {\n        rule.message = validator.defaultMessage();\n      }\n    }\n  },\n\n  _addBrokenRule(info) {\n    var {\n      result: result,\n      rule: rule\n    } = info;\n\n    if (!result.brokenRule) {\n      result.brokenRule = rule;\n    }\n\n    if (!result.brokenRules) {\n      result.brokenRules = [];\n    }\n\n    result.brokenRules.push(rule);\n  },\n\n  validate(value, rules, name) {\n    var _rules$;\n\n    var result = {\n      name: name,\n      value: value,\n      brokenRule: null,\n      brokenRules: null,\n      isValid: true,\n      validationRules: rules,\n      pendingRules: null,\n      status: STATUS.valid,\n      complete: null\n    };\n    var validator = null === rules || void 0 === rules ? void 0 : null === (_rules$ = rules[0]) || void 0 === _rules$ ? void 0 : _rules$.validator;\n    var asyncRuleItems = [];\n    each(rules || [], (_, rule) => {\n      var ruleValidator = rulesValidators[rule.type];\n      var ruleValidationResult;\n\n      if (ruleValidator) {\n        if (isDefined(rule.isValid) && rule.value === value && !rule.reevaluate) {\n          if (!rule.isValid) {\n            result.isValid = false;\n\n            this._addBrokenRule({\n              result: result,\n              rule: rule\n            });\n\n            return false;\n          }\n\n          return true;\n        }\n\n        rule.value = value;\n\n        if (\"async\" === rule.type) {\n          asyncRuleItems.push({\n            rule: rule,\n            ruleValidator: ruleValidator\n          });\n          return true;\n        }\n\n        ruleValidationResult = ruleValidator.validate(value, rule);\n        rule.isValid = ruleValidationResult;\n\n        if (!ruleValidationResult) {\n          result.isValid = false;\n\n          this._setDefaultMessage({\n            rule: rule,\n            validator: ruleValidator,\n            name: name\n          });\n\n          this._addBrokenRule({\n            result: result,\n            rule: rule\n          });\n        }\n\n        if (!rule.isValid) {\n          return false;\n        }\n      } else {\n        throw errors.Error(\"E0100\");\n      }\n    });\n\n    if (result.isValid && !result.brokenRules && asyncRuleItems.length) {\n      result = this._validateAsyncRules({\n        value: value,\n        items: asyncRuleItems,\n        result: result,\n        name: name\n      });\n    }\n\n    this._synchronizeGroupValidationInfo(validator, result);\n\n    result.status = result.pendingRules ? STATUS.pending : result.isValid ? STATUS.valid : STATUS.invalid;\n    return result;\n  },\n\n  _synchronizeGroupValidationInfo(validator, result) {\n    var _result$brokenRules;\n\n    if (!validator) {\n      return;\n    }\n\n    var groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);\n\n    groupConfig._updateBrokenRules.call(groupConfig, {\n      validator: validator,\n      brokenRules: null !== (_result$brokenRules = result.brokenRules) && void 0 !== _result$brokenRules ? _result$brokenRules : []\n    });\n  },\n\n  _validateAsyncRules(_ref) {\n    var {\n      result: result,\n      value: value,\n      items: items,\n      name: name\n    } = _ref;\n    var asyncResults = [];\n    each(items, (_, item) => {\n      var validateResult = item.ruleValidator.validate(value, item.rule);\n\n      if (!isPromise(validateResult)) {\n        this._updateRuleConfig({\n          rule: item.rule,\n          ruleResult: this._getPatchedRuleResult(validateResult),\n          validator: item.ruleValidator,\n          name: name\n        });\n      } else {\n        if (!result.pendingRules) {\n          result.pendingRules = [];\n        }\n\n        result.pendingRules.push(item.rule);\n        var asyncResult = validateResult.then(res => {\n          var ruleResult = this._getPatchedRuleResult(res);\n\n          this._updateRuleConfig({\n            rule: item.rule,\n            ruleResult: ruleResult,\n            validator: item.ruleValidator,\n            name: name\n          });\n\n          return ruleResult;\n        });\n        asyncResults.push(asyncResult);\n      }\n    });\n\n    if (asyncResults.length) {\n      result.complete = Promise.all(asyncResults).then(values => this._getAsyncRulesResult({\n        result: result,\n        values: values\n      }));\n    }\n\n    return result;\n  },\n\n  _updateRuleConfig(_ref2) {\n    var {\n      rule: rule,\n      ruleResult: ruleResult,\n      validator: validator,\n      name: name\n    } = _ref2;\n    rule.isValid = ruleResult.isValid;\n\n    if (!ruleResult.isValid) {\n      if (isDefined(ruleResult.message) && isString(ruleResult.message) && ruleResult.message.length) {\n        rule.message = ruleResult.message;\n      } else {\n        this._setDefaultMessage({\n          rule: rule,\n          validator: validator,\n          name: name\n        });\n      }\n    }\n  },\n\n  _getPatchedRuleResult(ruleResult) {\n    var result;\n\n    if (isObject(ruleResult)) {\n      result = extend({}, ruleResult);\n\n      if (!isDefined(result.isValid)) {\n        result.isValid = true;\n      }\n    } else {\n      result = {\n        isValid: isBoolean(ruleResult) ? ruleResult : true\n      };\n    }\n\n    return result;\n  },\n\n  _getAsyncRulesResult(_ref3) {\n    var {\n      values: values,\n      result: result\n    } = _ref3;\n    each(values, (index, val) => {\n      if (false === val.isValid) {\n        result.isValid = val.isValid;\n        var rule = result.pendingRules[index];\n\n        this._addBrokenRule({\n          result: result,\n          rule: rule\n        });\n      }\n    });\n    result.pendingRules = null;\n    result.complete = null;\n    result.status = result.isValid ? STATUS.valid : STATUS.invalid;\n    return result;\n  },\n\n  registerValidatorInGroup(group, validator) {\n    var groupConfig = ValidationEngine.addGroup(group);\n    groupConfig.registerValidator.call(groupConfig, validator);\n  },\n\n  _shouldRemoveGroup(group, validatorsInGroup) {\n    var isDefaultGroup = void 0 === group;\n    var isValidationGroupInstance = group && \"dxValidationGroup\" === group.NAME;\n    return !isDefaultGroup && !isValidationGroupInstance && !validatorsInGroup.length;\n  },\n\n  removeRegisteredValidator(group, validator) {\n    var config = ValidationEngine.getGroupConfig(group);\n\n    if (config) {\n      config.removeRegisteredValidator.call(config, validator);\n      var validatorsInGroup = config.validators;\n\n      if (this._shouldRemoveGroup(group, validatorsInGroup)) {\n        this.removeGroup(group);\n      }\n    }\n  },\n\n  initValidationOptions(options) {\n    var initedOptions = {};\n\n    if (options) {\n      [\"isValid\", \"validationStatus\", \"validationError\", \"validationErrors\"].forEach(prop => {\n        if (prop in options) {\n          extend(initedOptions, this.synchronizeValidationOptions({\n            name: prop,\n            value: options[prop]\n          }, options));\n        }\n      });\n    }\n\n    return initedOptions;\n  },\n\n  synchronizeValidationOptions(_ref4, options) {\n    var {\n      name: name,\n      value: value\n    } = _ref4;\n\n    switch (name) {\n      case \"validationStatus\":\n        var isValid = value === STATUS.valid || value === STATUS.pending;\n        return options.isValid !== isValid ? {\n          isValid: isValid\n        } : {};\n\n      case \"isValid\":\n        var {\n          validationStatus: validationStatus\n        } = options;\n        var newStatus = validationStatus;\n\n        if (value && validationStatus === STATUS.invalid) {\n          newStatus = STATUS.valid;\n        } else if (!value && validationStatus !== STATUS.invalid) {\n          newStatus = STATUS.invalid;\n        }\n\n        return newStatus !== validationStatus ? {\n          validationStatus: newStatus\n        } : {};\n\n      case \"validationErrors\":\n        var validationError = !value || !value.length ? null : value[0];\n        return options.validationError !== validationError ? {\n          validationError: validationError\n        } : {};\n\n      case \"validationError\":\n        var {\n          validationErrors: validationErrors\n        } = options;\n\n        if (!value && validationErrors) {\n          return {\n            validationErrors: null\n          };\n        } else if (value && !validationErrors) {\n          return {\n            validationErrors: [value]\n          };\n        } else if (value && validationErrors && value !== validationErrors[0]) {\n          validationErrors[0] = value;\n          return {\n            validationErrors: validationErrors.slice()\n          };\n        }\n\n    }\n\n    return {};\n  },\n\n  validateGroup(group) {\n    var groupConfig = ValidationEngine.getGroupConfig(group);\n\n    if (!groupConfig) {\n      throw errors.Error(\"E0110\");\n    }\n\n    return groupConfig.validate();\n  },\n\n  resetGroup(group) {\n    var groupConfig = ValidationEngine.getGroupConfig(group);\n\n    if (!groupConfig) {\n      throw errors.Error(\"E0110\");\n    }\n\n    return groupConfig.reset();\n  }\n\n};\nValidationEngine.initGroups();\nexport default ValidationEngine;","map":null,"metadata":{},"sourceType":"module"}