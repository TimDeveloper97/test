{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.work_space.indicator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { setWidth } from \"../../../core/utils/size\";\nimport $ from \"../../../core/renderer\";\nimport SchedulerWorkSpace from \"./ui.scheduler.work_space\";\nimport registerComponent from \"../../../core/component_registrator\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport { hasWindow } from \"../../../core/utils/window\";\nimport { HEADER_CURRENT_TIME_CELL_CLASS } from \"../classes\";\nimport { getToday } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport timezoneUtils from \"../utils.timeZone\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar SCHEDULER_DATE_TIME_INDICATOR_CLASS = \"dx-scheduler-date-time-indicator\";\nvar TIME_PANEL_CURRENT_TIME_CELL_CLASS = \"dx-scheduler-time-panel-current-time-cell\";\n\nclass SchedulerWorkSpaceIndicator extends SchedulerWorkSpace {\n  _getToday() {\n    return getToday(this.option(\"indicatorTime\"), this.timeZoneCalculator);\n  }\n\n  isIndicationOnView() {\n    if (this.option(\"showCurrentTimeIndicator\")) {\n      var today = this._getToday();\n\n      var endViewDate = dateUtils.trimTime(this.getEndViewDate());\n      return dateUtils.dateInRange(today, this.getStartViewDate(), new Date(endViewDate.getTime() + toMs(\"day\")));\n    }\n\n    return false;\n  }\n\n  isIndicationAvailable() {\n    if (!hasWindow()) {\n      return false;\n    }\n\n    var today = this._getToday();\n\n    return today >= dateUtils.trimTime(new Date(this.getStartViewDate()));\n  }\n\n  isIndicatorVisible() {\n    var today = this._getToday();\n\n    var endViewDate = new Date(this.getEndViewDate().getTime() + toMs(\"minute\") - 1);\n    var firstViewDate = new Date(this.getStartViewDate());\n    firstViewDate.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n    endViewDate.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n    return dateUtils.dateInRange(today, firstViewDate, endViewDate);\n  }\n\n  _renderDateTimeIndication() {\n    if (this.isIndicationAvailable()) {\n      if (this.option(\"shadeUntilCurrentTime\")) {\n        this._shader.render();\n      }\n\n      if (this.isIndicationOnView() && this.isIndicatorVisible()) {\n        var groupCount = this._getGroupCount() || 1;\n\n        var $container = this._dateTableScrollable.$content();\n\n        var height = this.getIndicationHeight();\n\n        var rtlOffset = this._getRtlOffset(this.getCellWidth());\n\n        this._renderIndicator(height, rtlOffset, $container, groupCount);\n\n        this._setCurrentTimeCells();\n      }\n    }\n  }\n\n  _renderIndicator(height, rtlOffset, $container, groupCount) {\n    var groupedByDate = this.isGroupedByDate();\n    var repeatCount = groupedByDate ? 1 : groupCount;\n\n    for (var i = 0; i < repeatCount; i++) {\n      var $indicator = this._createIndicator($container);\n\n      setWidth($indicator, groupedByDate ? this.getCellWidth() * groupCount : this.getCellWidth());\n\n      this._groupedStrategy.shiftIndicator($indicator, height, rtlOffset, i);\n    }\n  }\n\n  _createIndicator($container) {\n    var $indicator = $(\"<div>\").addClass(SCHEDULER_DATE_TIME_INDICATOR_CLASS);\n    $container.append($indicator);\n    return $indicator;\n  }\n\n  _getRtlOffset(width) {\n    return this.option(\"rtlEnabled\") ? getBoundingRect(this._dateTableScrollable.$content().get(0)).width - this.getTimePanelWidth() - width : 0;\n  }\n\n  _setIndicationUpdateInterval() {\n    if (!this.option(\"showCurrentTimeIndicator\") || 0 === this.option(\"indicatorUpdateInterval\")) {\n      return;\n    }\n\n    this._clearIndicatorUpdateInterval();\n\n    this._indicatorInterval = setInterval(function () {\n      this._refreshDateTimeIndication();\n    }.bind(this), this.option(\"indicatorUpdateInterval\"));\n  }\n\n  _clearIndicatorUpdateInterval() {\n    if (this._indicatorInterval) {\n      clearInterval(this._indicatorInterval);\n      delete this._indicatorInterval;\n    }\n  }\n\n  _isVerticalShader() {\n    return true;\n  }\n\n  getIndicationWidth(groupIndex) {\n    var maxWidth = this.getCellWidth() * this._getCellCount();\n\n    var difference = this._getIndicatorDuration();\n\n    if (difference > this._getCellCount()) {\n      difference = this._getCellCount();\n    }\n\n    var width = difference * this.getRoundedCellWidth(groupIndex, groupIndex * this._getCellCount(), difference);\n    return maxWidth < width ? maxWidth : width;\n  }\n\n  getIndicatorOffset(groupIndex) {\n    var difference = this._getIndicatorDuration() - 1;\n    var offset = difference * this.getRoundedCellWidth(groupIndex, groupIndex * this._getCellCount(), difference);\n    return offset;\n  }\n\n  _getIndicatorDuration() {\n    var today = this._getToday();\n\n    var firstViewDate = new Date(this.getStartViewDate());\n    var timeDiff = today.getTime() - firstViewDate.getTime();\n\n    if (\"workWeek\" === this.option(\"type\")) {\n      timeDiff -= this._getWeekendsCount(Math.round(timeDiff / toMs(\"day\"))) * toMs(\"day\");\n    }\n\n    return Math.ceil((timeDiff + 1) / toMs(\"day\"));\n  }\n\n  getIndicationHeight() {\n    var today = timezoneUtils.getDateWithoutTimezoneChange(this._getToday());\n    var cellHeight = this.getCellHeight();\n    var date = new Date(this.getStartViewDate());\n\n    if (this.isIndicationOnView()) {\n      date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n    }\n\n    var duration = today.getTime() - date.getTime();\n    var cellCount = duration / this.getCellDuration();\n    return cellCount * cellHeight;\n  }\n\n  _dispose() {\n    this._clearIndicatorUpdateInterval();\n\n    super._dispose.apply(this, arguments);\n  }\n\n  _refreshDateTimeIndication() {\n    var _this$_shader;\n\n    this._cleanDateTimeIndicator();\n\n    this._cleanCurrentTimeCells();\n\n    null === (_this$_shader = this._shader) || void 0 === _this$_shader ? void 0 : _this$_shader.clean();\n\n    this._renderDateTimeIndication();\n  }\n\n  _setCurrentTimeCells() {\n    var timePanelCells = this._getTimePanelCells();\n\n    var currentTimeCellIndices = this._getCurrentTimePanelCellIndices();\n\n    currentTimeCellIndices.forEach(timePanelCellIndex => {\n      timePanelCells.eq(timePanelCellIndex).addClass(TIME_PANEL_CURRENT_TIME_CELL_CLASS);\n    });\n  }\n\n  _isCurrentTimeHeaderCell(headerIndex) {\n    if (this.isIndicationOnView()) {\n      var completeDateHeaderMap = this.viewDataProvider.completeDateHeaderMap;\n      var date = completeDateHeaderMap[completeDateHeaderMap.length - 1][headerIndex].startDate;\n      return dateUtils.sameDate(date, this._getToday());\n    }\n\n    return false;\n  }\n\n  _getHeaderPanelCellClass(i) {\n    var cellClass = super._getHeaderPanelCellClass(i);\n\n    if (this._isCurrentTimeHeaderCell(i)) {\n      return cellClass + \" \" + HEADER_CURRENT_TIME_CELL_CLASS;\n    }\n\n    return cellClass;\n  }\n\n  _cleanView() {\n    super._cleanView();\n\n    this._cleanDateTimeIndicator();\n  }\n\n  _dimensionChanged() {\n    super._dimensionChanged();\n\n    this._refreshDateTimeIndication();\n  }\n\n  _cleanDateTimeIndicator() {\n    this.$element().find(\".\" + SCHEDULER_DATE_TIME_INDICATOR_CLASS).remove();\n  }\n\n  _cleanCurrentTimeCells() {\n    this.$element().find(\".\".concat(TIME_PANEL_CURRENT_TIME_CELL_CLASS)).removeClass(TIME_PANEL_CURRENT_TIME_CELL_CLASS);\n  }\n\n  _cleanWorkSpace() {\n    super._cleanWorkSpace();\n\n    this._renderDateTimeIndication();\n\n    this._setIndicationUpdateInterval();\n  }\n\n  _optionChanged(args) {\n    switch (args.name) {\n      case \"showCurrentTimeIndicator\":\n      case \"indicatorTime\":\n        this._cleanWorkSpace();\n\n        break;\n\n      case \"indicatorUpdateInterval\":\n        this._setIndicationUpdateInterval();\n\n        break;\n\n      case \"showAllDayPanel\":\n      case \"allDayExpanded\":\n      case \"crossScrollingEnabled\":\n        super._optionChanged(args);\n\n        this._refreshDateTimeIndication();\n\n        break;\n\n      case \"shadeUntilCurrentTime\":\n        this._refreshDateTimeIndication();\n\n        break;\n\n      default:\n        super._optionChanged(args);\n\n    }\n  }\n\n  _getDefaultOptions() {\n    return extend(super._getDefaultOptions(), {\n      showCurrentTimeIndicator: true,\n      indicatorTime: new Date(),\n      indicatorUpdateInterval: 5 * toMs(\"minute\"),\n      shadeUntilCurrentTime: true\n    });\n  }\n\n  _getCurrentTimePanelCellIndices() {\n    var rowCountPerGroup = this._getTimePanelRowCount();\n\n    var today = this._getToday();\n\n    var index = this.getCellIndexByDate(today);\n\n    var {\n      rowIndex: currentTimeRowIndex\n    } = this._getCellCoordinatesByIndex(index);\n\n    if (void 0 === currentTimeRowIndex) {\n      return [];\n    }\n\n    var cellIndices;\n\n    if (0 === currentTimeRowIndex) {\n      cellIndices = [currentTimeRowIndex];\n    } else {\n      cellIndices = currentTimeRowIndex % 2 === 0 ? [currentTimeRowIndex - 1, currentTimeRowIndex] : [currentTimeRowIndex, currentTimeRowIndex + 1];\n    }\n\n    var verticalGroupCount = this._isVerticalGroupedWorkSpace() ? this._getGroupCount() : 1;\n    return [...new Array(verticalGroupCount)].reduce((currentIndices, _, groupIndex) => [...currentIndices, ...cellIndices.map(cellIndex => rowCountPerGroup * groupIndex + cellIndex)], []);\n  }\n\n}\n\nregisterComponent(\"dxSchedulerWorkSpace\", SchedulerWorkSpaceIndicator);\nexport default SchedulerWorkSpaceIndicator;","map":null,"metadata":{},"sourceType":"module"}