{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/widget/ui.widget.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport Action from \"../../core/action\";\nimport DOMComponent from \"../../core/dom_component\";\nimport { active, focus, hover, keyboard } from \"../../events/short\";\nimport { deferRender, deferRenderer, noop } from \"../../core/utils/common\";\nimport { each } from \"../../core/utils/iterator\";\nimport { extend } from \"../../core/utils/extend\";\nimport { focusable as focusableSelector } from \"./selectors\";\nimport { isPlainObject, isDefined } from \"../../core/utils/type\";\nimport devices from \"../../core/devices\";\nimport { compare as compareVersions } from \"../../core/utils/version\";\nimport \"../../events/click\";\nimport \"../../events/core/emitter.feedback\";\nimport \"../../events/hover\";\n\nfunction setAttribute(name, value, target) {\n  name = \"role\" === name || \"id\" === name ? name : \"aria-\".concat(name);\n  value = isDefined(value) ? value.toString() : null;\n  target.attr(name, value);\n}\n\nvar Widget = DOMComponent.inherit({\n  _feedbackHideTimeout: 400,\n  _feedbackShowTimeout: 30,\n  _supportedKeys: () => ({}),\n\n  _getDefaultOptions() {\n    return extend(this.callBase(), {\n      hoveredElement: null,\n      isActive: false,\n      disabled: false,\n      visible: true,\n      hint: void 0,\n      activeStateEnabled: false,\n      onContentReady: null,\n      hoverStateEnabled: false,\n      focusStateEnabled: false,\n      tabIndex: 0,\n      accessKey: void 0,\n      onFocusIn: null,\n      onFocusOut: null,\n      onKeyboardHandled: null,\n      ignoreParentReadOnly: false,\n      useResizeObserver: true\n    });\n  },\n\n  _defaultOptionsRules: function () {\n    return this.callBase().concat([{\n      device: function () {\n        var device = devices.real();\n        var platform = device.platform;\n        var version = device.version;\n        return \"ios\" === platform && compareVersions(version, \"13.3\") <= 0;\n      },\n      options: {\n        useResizeObserver: false\n      }\n    }]);\n  },\n\n  _init() {\n    this.callBase();\n\n    this._initContentReadyAction();\n  },\n\n  _innerWidgetOptionChanged: function (innerWidget, args) {\n    var options = Widget.getOptionsFromContainer(args);\n    innerWidget && innerWidget.option(options);\n\n    this._options.cache(args.name, options);\n  },\n\n  _bindInnerWidgetOptions(innerWidget, optionsContainer) {\n    var syncOptions = () => this._options.silent(optionsContainer, extend({}, innerWidget.option()));\n\n    syncOptions();\n    innerWidget.on(\"optionChanged\", syncOptions);\n  },\n\n  _getAriaTarget() {\n    return this._focusTarget();\n  },\n\n  _initContentReadyAction() {\n    this._contentReadyAction = this._createActionByOption(\"onContentReady\", {\n      excludeValidators: [\"disabled\", \"readOnly\"]\n    });\n  },\n\n  _initMarkup() {\n    var {\n      disabled: disabled,\n      visible: visible\n    } = this.option();\n    this.$element().addClass(\"dx-widget\");\n\n    this._toggleDisabledState(disabled);\n\n    this._toggleVisibility(visible);\n\n    this._renderHint();\n\n    this._isFocusable() && this._renderFocusTarget();\n    this.callBase();\n  },\n\n  _render() {\n    this.callBase();\n\n    this._renderContent();\n\n    this._renderFocusState();\n\n    this._attachFeedbackEvents();\n\n    this._attachHoverEvents();\n\n    this._toggleIndependentState();\n  },\n\n  _renderHint() {\n    var {\n      hint: hint\n    } = this.option();\n    this.$element().attr(\"title\", hint || null);\n  },\n\n  _renderContent() {\n    deferRender(() => !this._disposed ? this._renderContentImpl() : void 0).done(() => !this._disposed ? this._fireContentReadyAction() : void 0);\n  },\n\n  _renderContentImpl: noop,\n  _fireContentReadyAction: deferRenderer(function () {\n    return this._contentReadyAction();\n  }),\n\n  _dispose() {\n    this._contentReadyAction = null;\n\n    this._detachKeyboardEvents();\n\n    this.callBase();\n  },\n\n  _resetActiveState() {\n    this._toggleActiveState(this._eventBindingTarget(), false);\n  },\n\n  _clean() {\n    this._cleanFocusState();\n\n    this._resetActiveState();\n\n    this.callBase();\n    this.$element().empty();\n  },\n\n  _toggleVisibility(visible) {\n    this.$element().toggleClass(\"dx-state-invisible\", !visible);\n    this.setAria(\"hidden\", !visible || void 0);\n  },\n\n  _renderFocusState() {\n    this._attachKeyboardEvents();\n\n    if (this._isFocusable()) {\n      this._renderFocusTarget();\n\n      this._attachFocusEvents();\n\n      this._renderAccessKey();\n    }\n  },\n\n  _renderAccessKey() {\n    var $el = this._focusTarget();\n\n    var {\n      accessKey: accessKey\n    } = this.option();\n    $el.attr(\"accesskey\", accessKey);\n  },\n\n  _isFocusable() {\n    var {\n      focusStateEnabled: focusStateEnabled,\n      disabled: disabled\n    } = this.option();\n    return focusStateEnabled && !disabled;\n  },\n\n  _eventBindingTarget() {\n    return this.$element();\n  },\n\n  _focusTarget() {\n    return this._getActiveElement();\n  },\n\n  _isFocusTarget: function (element) {\n    var focusTargets = $(this._focusTarget()).toArray();\n    return focusTargets.includes(element);\n  },\n\n  _getActiveElement() {\n    var activeElement = this._eventBindingTarget();\n\n    if (this._activeStateUnit) {\n      return activeElement.find(this._activeStateUnit).not(\".dx-state-disabled\");\n    }\n\n    return activeElement;\n  },\n\n  _renderFocusTarget() {\n    var {\n      tabIndex: tabIndex\n    } = this.option();\n\n    this._focusTarget().attr(\"tabIndex\", tabIndex);\n  },\n\n  _keyboardEventBindingTarget() {\n    return this._eventBindingTarget();\n  },\n\n  _refreshFocusEvent() {\n    this._detachFocusEvents();\n\n    this._attachFocusEvents();\n  },\n\n  _focusEventTarget() {\n    return this._focusTarget();\n  },\n\n  _focusInHandler(event) {\n    if (!event.isDefaultPrevented()) {\n      this._createActionByOption(\"onFocusIn\", {\n        beforeExecute: () => this._updateFocusState(event, true),\n        excludeValidators: [\"readOnly\"]\n      })({\n        event: event\n      });\n    }\n  },\n\n  _focusOutHandler(event) {\n    if (!event.isDefaultPrevented()) {\n      this._createActionByOption(\"onFocusOut\", {\n        beforeExecute: () => this._updateFocusState(event, false),\n        excludeValidators: [\"readOnly\", \"disabled\"]\n      })({\n        event: event\n      });\n    }\n  },\n\n  _updateFocusState(_ref, isFocused) {\n    var {\n      target: target\n    } = _ref;\n\n    if (this._isFocusTarget(target)) {\n      this._toggleFocusClass(isFocused, $(target));\n    }\n  },\n\n  _toggleFocusClass(isFocused, $element) {\n    var $focusTarget = $element && $element.length ? $element : this._focusTarget();\n    $focusTarget.toggleClass(\"dx-state-focused\", isFocused);\n  },\n\n  _hasFocusClass(element) {\n    var $focusTarget = $(element || this._focusTarget());\n    return $focusTarget.hasClass(\"dx-state-focused\");\n  },\n\n  _isFocused() {\n    return this._hasFocusClass();\n  },\n\n  _getKeyboardListeners: () => [],\n\n  _attachKeyboardEvents() {\n    this._detachKeyboardEvents();\n\n    var {\n      focusStateEnabled: focusStateEnabled,\n      onKeyboardHandled: onKeyboardHandled\n    } = this.option();\n\n    var hasChildListeners = this._getKeyboardListeners().length;\n\n    var hasKeyboardEventHandler = !!onKeyboardHandled;\n    var shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;\n\n    if (shouldAttach) {\n      this._keyboardListenerId = keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), opts => this._keyboardHandler(opts));\n    }\n  },\n\n  _keyboardHandler(options, onlyChildProcessing) {\n    if (!onlyChildProcessing) {\n      var {\n        originalEvent: originalEvent,\n        keyName: keyName,\n        which: which\n      } = options;\n\n      var keys = this._supportedKeys(originalEvent);\n\n      var func = keys[keyName] || keys[which];\n\n      if (void 0 !== func) {\n        var handler = func.bind(this);\n        var result = handler(originalEvent, options);\n\n        if (!result) {\n          return false;\n        }\n      }\n    }\n\n    var keyboardListeners = this._getKeyboardListeners();\n\n    var {\n      onKeyboardHandled: onKeyboardHandled\n    } = this.option();\n    keyboardListeners.forEach(listener => listener && listener._keyboardHandler(options));\n    onKeyboardHandled && onKeyboardHandled(options);\n    return true;\n  },\n\n  _refreshFocusState() {\n    this._cleanFocusState();\n\n    this._renderFocusState();\n  },\n\n  _cleanFocusState() {\n    var $element = this._focusTarget();\n\n    $element.removeAttr(\"tabIndex\");\n\n    this._toggleFocusClass(false);\n\n    this._detachFocusEvents();\n\n    this._detachKeyboardEvents();\n  },\n\n  _detachKeyboardEvents() {\n    keyboard.off(this._keyboardListenerId);\n    this._keyboardListenerId = null;\n  },\n\n  _attachHoverEvents() {\n    var {\n      hoverStateEnabled: hoverStateEnabled\n    } = this.option();\n    var selector = this._activeStateUnit;\n\n    var $el = this._eventBindingTarget();\n\n    hover.off($el, {\n      selector: selector,\n      namespace: \"UIFeedback\"\n    });\n\n    if (hoverStateEnabled) {\n      hover.on($el, new Action(_ref2 => {\n        var {\n          event: event,\n          element: element\n        } = _ref2;\n\n        this._hoverStartHandler(event);\n\n        this.option(\"hoveredElement\", $(element));\n      }, {\n        excludeValidators: [\"readOnly\"]\n      }), event => {\n        this.option(\"hoveredElement\", null);\n\n        this._hoverEndHandler(event);\n      }, {\n        selector: selector,\n        namespace: \"UIFeedback\"\n      });\n    }\n  },\n\n  _attachFeedbackEvents() {\n    var {\n      activeStateEnabled: activeStateEnabled\n    } = this.option();\n    var selector = this._activeStateUnit;\n\n    var $el = this._eventBindingTarget();\n\n    active.off($el, {\n      namespace: \"UIFeedback\",\n      selector: selector\n    });\n\n    if (activeStateEnabled) {\n      active.on($el, new Action(_ref3 => {\n        var {\n          event: event,\n          element: element\n        } = _ref3;\n        return this._toggleActiveState($(element), true, event);\n      }), new Action(_ref4 => {\n        var {\n          event: event,\n          element: element\n        } = _ref4;\n        return this._toggleActiveState($(element), false, event);\n      }, {\n        excludeValidators: [\"disabled\", \"readOnly\"]\n      }), {\n        showTimeout: this._feedbackShowTimeout,\n        hideTimeout: this._feedbackHideTimeout,\n        selector: selector,\n        namespace: \"UIFeedback\"\n      });\n    }\n  },\n\n  _detachFocusEvents() {\n    var $el = this._focusEventTarget();\n\n    focus.off($el, {\n      namespace: \"\".concat(this.NAME, \"Focus\")\n    });\n  },\n\n  _attachFocusEvents() {\n    var $el = this._focusEventTarget();\n\n    focus.on($el, e => this._focusInHandler(e), e => this._focusOutHandler(e), {\n      namespace: \"\".concat(this.NAME, \"Focus\"),\n      isFocusable: (index, el) => $(el).is(focusableSelector)\n    });\n  },\n\n  _hoverStartHandler: noop,\n  _hoverEndHandler: noop,\n\n  _toggleActiveState($element, value) {\n    this.option(\"isActive\", value);\n    $element.toggleClass(\"dx-state-active\", value);\n  },\n\n  _updatedHover() {\n    var hoveredElement = this._options.silent(\"hoveredElement\");\n\n    this._hover(hoveredElement, hoveredElement);\n  },\n\n  _findHoverTarget($el) {\n    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());\n  },\n\n  _hover($el, $previous) {\n    var {\n      hoverStateEnabled: hoverStateEnabled,\n      disabled: disabled,\n      isActive: isActive\n    } = this.option();\n    $previous = this._findHoverTarget($previous);\n    $previous && $previous.toggleClass(\"dx-state-hover\", false);\n\n    if ($el && hoverStateEnabled && !disabled && !isActive) {\n      var newHoveredElement = this._findHoverTarget($el);\n\n      newHoveredElement && newHoveredElement.toggleClass(\"dx-state-hover\", true);\n    }\n  },\n\n  _toggleDisabledState(value) {\n    this.$element().toggleClass(\"dx-state-disabled\", Boolean(value));\n    this.setAria(\"disabled\", value || void 0);\n  },\n\n  _toggleIndependentState() {\n    this.$element().toggleClass(\"dx-state-independent\", this.option(\"ignoreParentReadOnly\"));\n  },\n\n  _setWidgetOption(widgetName, args) {\n    if (!this[widgetName]) {\n      return;\n    }\n\n    if (isPlainObject(args[0])) {\n      each(args[0], (option, value) => this._setWidgetOption(widgetName, [option, value]));\n      return;\n    }\n\n    var optionName = args[0];\n    var value = args[1];\n\n    if (1 === args.length) {\n      value = this.option(optionName);\n    }\n\n    var widgetOptionMap = this[\"\".concat(widgetName, \"OptionMap\")];\n    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value);\n  },\n\n  _optionChanged(args) {\n    var {\n      name: name,\n      value: value,\n      previousValue: previousValue\n    } = args;\n\n    switch (name) {\n      case \"disabled\":\n        this._toggleDisabledState(value);\n\n        this._updatedHover();\n\n        this._refreshFocusState();\n\n        break;\n\n      case \"hint\":\n        this._renderHint();\n\n        break;\n\n      case \"ignoreParentReadOnly\":\n        this._toggleIndependentState();\n\n        break;\n\n      case \"activeStateEnabled\":\n        this._attachFeedbackEvents();\n\n        break;\n\n      case \"hoverStateEnabled\":\n        this._attachHoverEvents();\n\n        this._updatedHover();\n\n        break;\n\n      case \"tabIndex\":\n      case \"focusStateEnabled\":\n        this._refreshFocusState();\n\n        break;\n\n      case \"onFocusIn\":\n      case \"onFocusOut\":\n      case \"useResizeObserver\":\n        break;\n\n      case \"accessKey\":\n        this._renderAccessKey();\n\n        break;\n\n      case \"hoveredElement\":\n        this._hover(value, previousValue);\n\n        break;\n\n      case \"isActive\":\n        this._updatedHover();\n\n        break;\n\n      case \"visible\":\n        this._toggleVisibility(value);\n\n        if (this._isVisibilityChangeSupported()) {\n          this._checkVisibilityChanged(value ? \"shown\" : \"hiding\");\n        }\n\n        break;\n\n      case \"onKeyboardHandled\":\n        this._attachKeyboardEvents();\n\n        break;\n\n      case \"onContentReady\":\n        this._initContentReadyAction();\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n\n  _isVisible() {\n    var {\n      visible: visible\n    } = this.option();\n    return this.callBase() && visible;\n  },\n\n  beginUpdate() {\n    this._ready(false);\n\n    this.callBase();\n  },\n\n  endUpdate() {\n    this.callBase();\n\n    if (this._initialized) {\n      this._ready(true);\n    }\n  },\n\n  _ready(value) {\n    if (0 === arguments.length) {\n      return this._isReady;\n    }\n\n    this._isReady = value;\n  },\n\n  setAria() {\n    if (!isPlainObject(arguments.length <= 0 ? void 0 : arguments[0])) {\n      setAttribute(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget());\n    } else {\n      var target = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();\n\n      each(arguments.length <= 0 ? void 0 : arguments[0], (name, value) => setAttribute(name, value, target));\n    }\n  },\n\n  isReady() {\n    return this._ready();\n  },\n\n  repaint() {\n    this._refresh();\n  },\n\n  focus() {\n    focus.trigger(this._focusTarget());\n  },\n\n  registerKeyHandler(key, handler) {\n    var currentKeys = this._supportedKeys();\n\n    this._supportedKeys = () => extend(currentKeys, {\n      [key]: handler\n    });\n  }\n\n});\n\nWidget.getOptionsFromContainer = _ref5 => {\n  var {\n    name: name,\n    fullName: fullName,\n    value: value\n  } = _ref5;\n  var options = {};\n\n  if (name === fullName) {\n    options = value;\n  } else {\n    var option = fullName.split(\".\").pop();\n    options[option] = value;\n  }\n\n  return options;\n};\n\nexport default Widget;","map":null,"metadata":{},"sourceType":"module"}