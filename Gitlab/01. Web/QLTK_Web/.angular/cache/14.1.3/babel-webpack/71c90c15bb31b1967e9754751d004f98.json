{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/cellPositionCalculator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { isDefined } from \"../../../core/utils/type\";\nimport dateUtils from \"../../../core/utils/date\";\n\nclass BaseStrategy {\n  constructor(options) {\n    this.options = options;\n  }\n\n  get DOMMetaData() {\n    return this.options.DOMMetaData;\n  }\n\n  get appointments() {\n    return this.options.dateSettings;\n  }\n\n  get viewDataProvider() {\n    return this.options.viewDataProvider;\n  }\n\n  get positionHelper() {\n    return this.options.positionHelper;\n  }\n\n  get startViewDate() {\n    return this.options.startViewDate;\n  }\n\n  get viewStartDayHour() {\n    return this.options.viewStartDayHour;\n  }\n\n  get viewEndDayHour() {\n    return this.options.viewEndDayHour;\n  }\n\n  get cellDuration() {\n    return this.options.cellDuration;\n  }\n\n  get getPositionShift() {\n    return this.options.getPositionShiftCallback;\n  }\n\n  get groupCount() {\n    return this.options.groupCount;\n  }\n\n  get rtlEnabled() {\n    return this.options.rtlEnabled;\n  }\n\n  get isVerticalGrouping() {\n    return this.options.isVerticalGroupOrientation;\n  }\n\n  get showAllDayPanel() {\n    return this.options.showAllDayPanel;\n  }\n\n  get supportAllDayRow() {\n    return this.options.supportAllDayRow;\n  }\n\n  get isGroupedAllDayPanel() {\n    return this.options.isGroupedAllDayPanel;\n  }\n\n  get isVirtualScrolling() {\n    return false;\n  }\n\n  calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment) {\n    var result = [];\n    this.appointments.forEach((dateSetting, index) => {\n      var coordinates = this.getCoordinateInfos({\n        appointment: dateSetting,\n        groupIndices: groupIndices,\n        isAllDayRowAppointment: isAllDayRowAppointment,\n        isRecurrentAppointment: isRecurrentAppointment\n      });\n      coordinates.forEach(item => {\n        !!item && result.push(this._prepareObject(item, index));\n      });\n    });\n    return result;\n  }\n\n  getCoordinateInfos(options) {\n    var {\n      appointment: appointment,\n      isAllDayRowAppointment: isAllDayRowAppointment,\n      groupIndices: groupIndices,\n      recurrent: recurrent\n    } = options;\n    var {\n      startDate: startDate\n    } = appointment;\n    var groupIndex = !recurrent ? appointment.source.groupIndex : void 0;\n    return this.getCoordinatesByDateInGroup(startDate, groupIndices, isAllDayRowAppointment, groupIndex);\n  }\n\n  _prepareObject(position, dateSettingIndex) {\n    position.dateSettingIndex = dateSettingIndex;\n    return {\n      coordinates: position,\n      dateSettingIndex: dateSettingIndex\n    };\n  }\n\n  getCoordinatesByDate(date, groupIndex, inAllDayRow) {\n    var validGroupIndex = groupIndex || 0;\n    var cellInfo = {\n      groupIndex: validGroupIndex,\n      startDate: date,\n      isAllDay: inAllDayRow\n    };\n    var positionByMap = this.viewDataProvider.findCellPositionInMap(cellInfo);\n\n    if (!positionByMap) {\n      return;\n    }\n\n    var position = this.getCellPosition(positionByMap, inAllDayRow && !this.isVerticalGrouping);\n    var timeShift = inAllDayRow ? 0 : this.getTimeShift(date);\n    var shift = this.getPositionShift(timeShift, inAllDayRow);\n    var horizontalHMax = this.positionHelper.getHorizontalMax(validGroupIndex, date);\n    var verticalMax = this.positionHelper.getVerticalMax({\n      groupIndex: validGroupIndex,\n      isVirtualScrolling: this.isVirtualScrolling,\n      showAllDayPanel: this.showAllDayPanel,\n      supportAllDayRow: this.supportAllDayRow,\n      isGroupedAllDayPanel: this.isGroupedAllDayPanel,\n      isVerticalGrouping: this.isVerticalGrouping\n    });\n    return {\n      positionByMap: positionByMap,\n      cellPosition: position.left + shift.cellPosition,\n      top: position.top + shift.top,\n      left: position.left + shift.left,\n      rowIndex: position.rowIndex,\n      columnIndex: position.columnIndex,\n      hMax: horizontalHMax,\n      vMax: verticalMax,\n      groupIndex: validGroupIndex\n    };\n  }\n\n  getCoordinatesByDateInGroup(startDate, groupIndices, inAllDayRow, groupIndex) {\n    var result = [];\n\n    if (this.viewDataProvider.isSkippedDate(startDate)) {\n      return result;\n    }\n\n    var validGroupIndices = [groupIndex];\n\n    if (!isDefined(groupIndex)) {\n      validGroupIndices = this.groupCount ? groupIndices : [0];\n    }\n\n    validGroupIndices.forEach(groupIndex => {\n      var coordinates = this.getCoordinatesByDate(startDate, groupIndex, inAllDayRow);\n\n      if (coordinates) {\n        result.push(coordinates);\n      }\n    });\n    return result;\n  }\n\n  getCellPosition(cellCoordinates, isAllDayPanel) {\n    var {\n      dateTableCellsMeta: dateTableCellsMeta,\n      allDayPanelCellsMeta: allDayPanelCellsMeta\n    } = this.DOMMetaData;\n    var {\n      columnIndex: columnIndex,\n      rowIndex: rowIndex\n    } = cellCoordinates;\n    var position = isAllDayPanel ? allDayPanelCellsMeta[columnIndex] : dateTableCellsMeta[rowIndex][columnIndex];\n\n    var validPosition = _extends({}, position);\n\n    if (this.rtlEnabled) {\n      validPosition.left += position.width;\n    }\n\n    if (validPosition) {\n      validPosition.rowIndex = cellCoordinates.rowIndex;\n      validPosition.columnIndex = cellCoordinates.columnIndex;\n    }\n\n    return validPosition;\n  }\n\n  getTimeShift(date) {\n    var currentDayStart = new Date(date);\n    var currentDayEndHour = new Date(new Date(date).setHours(this.viewEndDayHour, 0, 0));\n\n    if (date.getTime() <= currentDayEndHour.getTime()) {\n      currentDayStart.setHours(this.viewStartDayHour, 0, 0, 0);\n    }\n\n    var timeZoneDifference = dateUtils.getTimezonesDifference(date, currentDayStart);\n    var currentDateTime = date.getTime();\n    var currentDayStartTime = currentDayStart.getTime();\n    var minTime = this.startViewDate.getTime();\n    return currentDateTime > minTime ? (currentDateTime - currentDayStartTime + timeZoneDifference) % this.cellDuration / this.cellDuration : 0;\n  }\n\n}\n\nclass VirtualStrategy extends BaseStrategy {\n  get isVirtualScrolling() {\n    return true;\n  }\n\n  calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment) {\n    var appointments = isAllDayRowAppointment ? this.appointments : this.appointments.filter(_ref => {\n      var {\n        source: source,\n        startDate: startDate,\n        endDate: endDate\n      } = _ref;\n      return this.viewDataProvider.isGroupIntersectDateInterval(source.groupIndex, startDate, endDate);\n    });\n\n    if (isRecurrentAppointment) {\n      return this.createRecurrentAppointmentInfos(appointments, isAllDayRowAppointment);\n    }\n\n    return super.calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment);\n  }\n\n  createRecurrentAppointmentInfos(dateSettings, isAllDayRowAppointment) {\n    var result = [];\n    dateSettings.forEach((_ref2, index) => {\n      var {\n        source: source,\n        startDate: startDate\n      } = _ref2;\n      var coordinate = this.getCoordinatesByDate(startDate, source.groupIndex, isAllDayRowAppointment);\n\n      if (coordinate) {\n        result.push(this._prepareObject(coordinate, index));\n      }\n    });\n    return result;\n  }\n\n}\n\nexport class CellPositionCalculator {\n  constructor(options) {\n    this.options = options;\n  }\n\n  calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment) {\n    var strategy = this.options.isVirtualScrolling ? new VirtualStrategy(this.options) : new BaseStrategy(this.options);\n    return strategy.calculateCellPositions(groupIndices, isAllDayRowAppointment, isRecurrentAppointment);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}