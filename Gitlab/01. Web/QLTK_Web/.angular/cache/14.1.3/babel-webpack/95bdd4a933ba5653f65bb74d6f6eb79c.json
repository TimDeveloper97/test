{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/rendering_strategies/strategy_vertical.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport BaseAppointmentsStrategy from \"./strategy.base\";\nimport { extend } from \"../../../../core/utils/extend\";\nimport { isNumeric } from \"../../../../core/utils/type\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport timeZoneUtils from \"../../utils.timeZone\";\nimport { ExpressionUtils } from \"../../expressionUtils\";\nimport { createAppointmentAdapter } from \"../../appointmentAdapter\";\nimport getSkippedHoursInRange from \"../../../../renovation/ui/scheduler/view_model/appointments/utils/getSkippedHoursInRange\";\nimport { getAppointmentTakesAllDay } from \"../../../../renovation/ui/scheduler/appointment/utils/getAppointmentTakesAllDay\";\nimport { roundFloatPart } from \"../../../../core/utils/math\";\nvar ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET = 5;\nvar ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET = 20;\nvar toMs = dateUtils.dateToMilliseconds;\n\nclass VerticalRenderingStrategy extends BaseAppointmentsStrategy {\n  getDeltaTime(args, initialSize, appointment) {\n    var deltaTime = 0;\n\n    if (this.isAllDay(appointment)) {\n      deltaTime = this._getDeltaWidth(args, initialSize) * toMs(\"day\");\n    } else {\n      var deltaHeight = args.height - initialSize.height;\n      deltaTime = toMs(\"minute\") * Math.round(deltaHeight / this.cellHeight * this.cellDurationInMinutes);\n    }\n\n    return deltaTime;\n  }\n\n  _correctCollectorCoordinatesInAdaptive(coordinates, isAllDay) {\n    if (isAllDay) {\n      super._correctCollectorCoordinatesInAdaptive(coordinates, isAllDay);\n    } else if (0 === this._getMaxAppointmentCountPerCellByType()) {\n      var cellHeight = this.cellHeight;\n      var cellWidth = this.cellWidth;\n      coordinates.top += (cellHeight - this.getDropDownButtonAdaptiveSize()) / 2;\n      coordinates.left += (cellWidth - this.getDropDownButtonAdaptiveSize()) / 2;\n    }\n  }\n\n  getAppointmentGeometry(coordinates) {\n    var geometry = null;\n\n    if (coordinates.allDay) {\n      geometry = this._getAllDayAppointmentGeometry(coordinates);\n    } else {\n      geometry = this.isAdaptive && coordinates.isCompact ? this._getAdaptiveGeometry(coordinates) : this._getVerticalAppointmentGeometry(coordinates);\n    }\n\n    return super.getAppointmentGeometry(geometry);\n  }\n\n  _getAdaptiveGeometry(coordinates) {\n    var config = this._calculateGeometryConfig(coordinates);\n\n    return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset);\n  }\n\n  _getItemPosition(appointment) {\n    var allDay = this.isAllDay(appointment);\n\n    if (allDay) {\n      return super._getItemPosition(appointment);\n    }\n\n    var adapter = createAppointmentAdapter(appointment, this.dataAccessors, this.timeZoneCalculator);\n    var isRecurring = !!adapter.recurrenceRule;\n    var appointmentStartDate = adapter.calculateStartDate(\"toGrid\");\n    var appointmentEndDate = adapter.calculateEndDate(\"toGrid\");\n    var appointmentDuration = appointmentEndDate - appointmentStartDate;\n    var appointmentBeginInCurrentView = this.options.startViewDate < appointmentStartDate;\n    var isAppointmentTakesSeveralDays = !timeZoneUtils.isSameAppointmentDates(appointmentStartDate, appointmentEndDate);\n    var settings = this.generateAppointmentSettings(appointment);\n    var result = [];\n\n    for (var j = 0; j < settings.length; j++) {\n      var currentSetting = settings[j];\n      var height = this.calculateAppointmentHeight(appointment, currentSetting);\n      var width = this.calculateAppointmentWidth(appointment, currentSetting);\n      var resultHeight = height;\n      var appointmentReduced = null;\n      var multiDaysAppointmentParts = [];\n      var currentMaxAllowedPosition = currentSetting.vMax;\n\n      if (this._isMultiViewAppointment(currentSetting, height) || isAppointmentTakesSeveralDays && !isRecurring) {\n        var trimmedStartDate = dateUtils.trimTime(appointmentStartDate);\n        var trimmedSettingStartDate = dateUtils.trimTime(currentSetting.info.appointment.startDate);\n        var reduceHead = trimmedStartDate <= trimmedSettingStartDate || isRecurring;\n\n        if (reduceHead) {\n          resultHeight = this._reduceMultiDayAppointment(height, {\n            top: currentSetting.top,\n            bottom: currentMaxAllowedPosition\n          });\n          multiDaysAppointmentParts = this._getAppointmentParts({\n            sourceAppointmentHeight: height,\n            reducedHeight: resultHeight,\n            width: width\n          }, currentSetting);\n        }\n\n        var {\n          startDate: currentSettingStartDate,\n          normalizedEndDate: currentSettingNormalizedEndDate\n        } = currentSetting.info.appointment;\n        var currentSettingDuration = currentSettingNormalizedEndDate - currentSettingStartDate;\n        var hasNextParts = currentSettingDuration < appointmentDuration;\n        appointmentReduced = hasNextParts ? appointmentBeginInCurrentView ? \"head\" : \"body\" : appointmentBeginInCurrentView ? \"head\" : \"tail\";\n      }\n\n      extend(currentSetting, {\n        height: resultHeight,\n        width: width,\n        allDay: allDay,\n        appointmentReduced: appointmentReduced\n      });\n      result = this._getAppointmentPartsPosition(multiDaysAppointmentParts, currentSetting, result);\n    }\n\n    return result;\n  }\n\n  _isMultiViewAppointment(_ref, height) {\n    var {\n      vMax: vMax,\n      top: top\n    } = _ref;\n    var fullAppointmentHeight = roundFloatPart(height, 2);\n    var remainingHeight = roundFloatPart(vMax - top, 2);\n    return fullAppointmentHeight > remainingHeight;\n  }\n\n  _reduceMultiDayAppointment(sourceAppointmentHeight, bound) {\n    return Math.min(sourceAppointmentHeight, bound.bottom - Math.floor(bound.top));\n  }\n\n  _getGroupHeight() {\n    return this.cellHeight * this.rowCount;\n  }\n\n  _getGroupTopOffset(appointmentSettings) {\n    var {\n      groupIndex: groupIndex\n    } = appointmentSettings;\n    var groupTop = Math.max(0, this.positionHelper.getGroupTop({\n      groupIndex: groupIndex,\n      showAllDayPanel: this.showAllDayPanel,\n      isGroupedAllDayPanel: this.isGroupedAllDayPanel\n    }));\n    var allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({\n      groupIndex: groupIndex,\n      supportAllDayRow: this.allDaySupported(),\n      showAllDayPanel: this.showAllDayPanel\n    });\n    var appointmentGroupTopOffset = appointmentSettings.top - groupTop - allDayPanelOffset;\n    return appointmentGroupTopOffset;\n  }\n\n  _getTailHeight(appointmentGeometry, appointmentSettings) {\n    if (!this.isVirtualScrolling) {\n      return appointmentGeometry.sourceAppointmentHeight - appointmentGeometry.reducedHeight;\n    }\n\n    var appointmentGroupTopOffset = this._getGroupTopOffset(appointmentSettings);\n\n    var {\n      sourceAppointmentHeight: sourceAppointmentHeight\n    } = appointmentGeometry;\n\n    var groupHeight = this._getGroupHeight();\n\n    var tailHeight = appointmentGroupTopOffset + sourceAppointmentHeight - groupHeight;\n    return tailHeight;\n  }\n\n  _getAppointmentParts(appointmentGeometry, appointmentSettings) {\n    var width = appointmentGeometry.width;\n    var result = [];\n    var currentPartTop = Math.max(0, this.positionHelper.getGroupTop({\n      groupIndex: appointmentSettings.groupIndex,\n      showAllDayPanel: this.showAllDayPanel,\n      isGroupedAllDayPanel: this.isGroupedAllDayPanel\n    }));\n    var cellsDiff = this.isGroupedByDate ? this.groupCount : 1;\n    var offset = this.cellWidth * cellsDiff;\n    var allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({\n      groupIndex: appointmentSettings.groupIndex,\n      supportAllDayRow: this.allDaySupported(),\n      showAllDayPanel: this.showAllDayPanel\n    });\n    currentPartTop += allDayPanelOffset;\n    var minHeight = this.getAppointmentMinSize();\n    var {\n      vMax: vMax,\n      hMax: hMax\n    } = appointmentSettings;\n    var hasTailPart = this.options.endViewDate > appointmentSettings.info.appointment.endDate;\n    var left = Math.round(appointmentSettings.left + offset);\n\n    var tailHeight = this._getTailHeight(appointmentGeometry, appointmentSettings);\n\n    while (tailHeight > 0 && left < hMax) {\n      tailHeight = Math.max(minHeight, tailHeight);\n      var columnIndex = appointmentSettings.columnIndex + cellsDiff;\n      var height = Math.min(tailHeight, vMax);\n      result.push(_extends({}, appointmentSettings, {\n        top: currentPartTop,\n        left: left,\n        height: height,\n        width: width,\n        appointmentReduced: \"body\",\n        rowIndex: 0,\n        columnIndex: columnIndex\n      }));\n      left += offset;\n      tailHeight -= vMax;\n    }\n\n    if (hasTailPart && result.length > 0) {\n      result[result.length - 1].appointmentReduced = \"tail\";\n    }\n\n    return result;\n  }\n\n  _getMinuteHeight() {\n    return this.cellHeight / this.cellDurationInMinutes;\n  }\n\n  _getCompactLeftCoordinate(itemLeft, index) {\n    var cellWidth = this.cellWidth || this.getAppointmentMinSize();\n    return itemLeft + (1 + cellWidth) * index;\n  }\n\n  _getVerticalAppointmentGeometry(coordinates) {\n    var config = this._calculateVerticalGeometryConfig(coordinates);\n\n    return this._customizeVerticalCoordinates(coordinates, config.width, config.appointmentCountPerCell, config.offset);\n  }\n\n  _customizeVerticalCoordinates(coordinates, width, appointmentCountPerCell, topOffset, isAllDay) {\n    var appointmentWidth = Math.max(width / appointmentCountPerCell, width / coordinates.count);\n    var height = coordinates.height;\n    var appointmentLeft = coordinates.left + coordinates.index * appointmentWidth;\n    var top = coordinates.top;\n\n    if (coordinates.isCompact) {\n      this._markAppointmentAsVirtual(coordinates, isAllDay);\n    }\n\n    return {\n      height: height,\n      width: appointmentWidth,\n      top: top,\n      left: appointmentLeft,\n      empty: this._isAppointmentEmpty(height, width)\n    };\n  }\n\n  _calculateVerticalGeometryConfig(coordinates) {\n    var overlappingMode = this.maxAppointmentsPerCell;\n\n    var offsets = this._getOffsets();\n\n    var appointmentDefaultOffset = this._getAppointmentDefaultOffset();\n\n    var appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);\n\n    var ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);\n\n    var maxWidth = this._getMaxWidth();\n\n    if (!appointmentCountPerCell) {\n      appointmentCountPerCell = coordinates.count;\n      ratio = (maxWidth - offsets.unlimited) / maxWidth;\n    }\n\n    var topOffset = (1 - ratio) * maxWidth;\n\n    if (\"auto\" === overlappingMode || isNumeric(overlappingMode)) {\n      ratio = 1;\n      maxWidth -= appointmentDefaultOffset;\n      topOffset = 0;\n    }\n\n    return {\n      width: ratio * maxWidth,\n      appointmentCountPerCell: appointmentCountPerCell,\n      offset: topOffset\n    };\n  }\n\n  _getMaxWidth() {\n    return this.cellWidth || this.cellWidth;\n  }\n\n  isAllDay(appointmentData) {\n    return getAppointmentTakesAllDay(createAppointmentAdapter(appointmentData, this.dataAccessors, this.timeZoneCalculator), this.startDayHour, this.endDayHour, this.allDayPanelMode);\n  }\n\n  _getAppointmentMaxWidth() {\n    return this.cellWidth - this._getAppointmentDefaultOffset();\n  }\n\n  calculateAppointmentWidth(appointment, position) {\n    if (!this.isAllDay(appointment)) {\n      return 0;\n    }\n\n    var startDate = dateUtils.trimTime(position.info.appointment.startDate);\n    var {\n      normalizedEndDate: normalizedEndDate\n    } = position.info.appointment;\n    var cellWidth = this.cellWidth || this.getAppointmentMinSize();\n    var durationInHours = (normalizedEndDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n    var skippedHours = getSkippedHoursInRange(position.info.appointment.startDate, position.info.appointment.endDate, this.viewDataProvider);\n    var width = Math.ceil((durationInHours - skippedHours) / 24) * cellWidth;\n    width = this.cropAppointmentWidth(width, cellWidth);\n    return width;\n  }\n\n  calculateAppointmentHeight(appointment, position) {\n    if (this.isAllDay(appointment)) {\n      return 0;\n    }\n\n    var startDate = position.info.appointment.startDate;\n    var {\n      normalizedEndDate: normalizedEndDate\n    } = position.info.appointment;\n    var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", appointment);\n    var duration = this.getAppointmentDurationInMs(startDate, normalizedEndDate, allDay);\n    var durationInMinutes = this._adjustDurationByDaylightDiff(duration, startDate, normalizedEndDate) / toMs(\"minute\");\n\n    var height = durationInMinutes * this._getMinuteHeight();\n\n    return height;\n  }\n\n  getDirection() {\n    return \"vertical\";\n  }\n\n  _sortCondition(a, b) {\n    var allDayCondition = a.allDay - b.allDay;\n    var isAllDay = a.allDay && b.allDay;\n    var condition = \"vertical\" === this.groupOrientation && isAllDay ? this._columnCondition(a, b) : this._rowCondition(a, b);\n    return allDayCondition ? allDayCondition : condition;\n  }\n\n  allDaySupported() {\n    return true;\n  }\n\n  _getAllDayAppointmentGeometry(coordinates) {\n    var config = this._calculateGeometryConfig(coordinates);\n\n    return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset, true);\n  }\n\n  _calculateGeometryConfig(coordinates) {\n    if (!this.allowResizing || !this.allowAllDayResizing) {\n      coordinates.skipResizing = true;\n    }\n\n    var config = super._calculateGeometryConfig(coordinates);\n\n    if (coordinates.count <= this._getDynamicAppointmentCountPerCell().allDay) {\n      config.offset = 0;\n    }\n\n    return config;\n  }\n\n  _getAppointmentCount(overlappingMode, coordinates) {\n    return \"auto\" !== overlappingMode && 1 === coordinates.count && !isNumeric(overlappingMode) ? coordinates.count : this._getMaxAppointmentCountPerCellByType(coordinates.allDay);\n  }\n\n  _getDefaultRatio(coordinates, appointmentCountPerCell) {\n    return coordinates.count > this.appointmentCountPerCell ? .65 : 1;\n  }\n\n  _getOffsets() {\n    return {\n      unlimited: ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET,\n      auto: ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET\n    };\n  }\n\n  _getMaxHeight() {\n    return this.allDayHeight || this.getAppointmentMinSize();\n  }\n\n  _needVerticalGroupBounds(allDay) {\n    return !allDay;\n  }\n\n  _needHorizontalGroupBounds() {\n    return false;\n  }\n\n  getPositionShift(timeShift, isAllDay) {\n    if (!isAllDay && this.isAdaptive && 0 === this._getMaxAppointmentCountPerCellByType(isAllDay)) {\n      return {\n        top: 0,\n        left: 0,\n        cellPosition: 0\n      };\n    }\n\n    return super.getPositionShift(timeShift, isAllDay);\n  }\n\n}\n\nexport default VerticalRenderingStrategy;","map":null,"metadata":{},"sourceType":"module"}