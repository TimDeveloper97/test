{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/resources/utils.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { normalizeDataSourceOptions } from \"../../../data/data_source/utils\";\nimport { DataSource } from \"../../../data/data_source/data_source\";\nimport { when, Deferred } from \"../../../core/utils/deferred\";\nimport { compileGetter, compileSetter } from \"../../../core/utils/data\";\nimport { each } from \"../../../core/utils/iterator\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { isDefined } from \"../../../core/utils/type\";\nimport { wrapToArray } from \"../../../core/utils/array\";\nimport { deepExtendArraySafe } from \"../../../core/utils/object\";\nimport { equalByValue } from \"../../../core/utils/common\";\nimport { hasResourceValue } from \"../../../renovation/ui/scheduler/resources/hasResourceValue\";\nexport var getValueExpr = resource => resource.valueExpr || \"id\";\nexport var getDisplayExpr = resource => resource.displayExpr || \"text\";\nexport var getFieldExpr = resource => resource.fieldExpr || resource.field;\nexport var getWrappedDataSource = dataSource => {\n  if (dataSource instanceof DataSource) {\n    return dataSource;\n  }\n\n  var result = {\n    store: normalizeDataSourceOptions(dataSource).store,\n    pageSize: 0\n  };\n\n  if (!Array.isArray(dataSource)) {\n    result.filter = dataSource.filter;\n  }\n\n  return new DataSource(result);\n};\nexport var createResourcesTree = groups => {\n  var leafIndex = 0;\n\n  var make = (group, groupIndex, result, parent) => {\n    result = result || [];\n\n    for (var itemIndex = 0; itemIndex < group.items.length; itemIndex++) {\n      var _group$data;\n\n      var currentGroupItem = group.items[itemIndex];\n      var resultItem = {\n        name: group.name,\n        value: currentGroupItem.id,\n        title: currentGroupItem.text,\n        data: null === (_group$data = group.data) || void 0 === _group$data ? void 0 : _group$data[itemIndex],\n        children: [],\n        parent: parent || null\n      };\n      var nextGroupIndex = groupIndex + 1;\n\n      if (groups[nextGroupIndex]) {\n        make(groups[nextGroupIndex], nextGroupIndex, resultItem.children, resultItem);\n      }\n\n      if (!resultItem.children.length) {\n        resultItem.leafIndex = leafIndex;\n        leafIndex++;\n      }\n\n      result.push(resultItem);\n    }\n\n    return result;\n  };\n\n  return make(groups[0], 0);\n};\nexport var getPathToLeaf = (leafIndex, groups) => {\n  var tree = createResourcesTree(groups);\n\n  var findLeafByIndex = (data, index) => {\n    for (var i = 0; i < data.length; i++) {\n      if (data[i].leafIndex === index) {\n        return data[i];\n      } else {\n        var _leaf = findLeafByIndex(data[i].children, index);\n\n        if (_leaf) {\n          return _leaf;\n        }\n      }\n    }\n  };\n\n  var makeBranch = (leaf, result) => {\n    result = result || [];\n    result.push(leaf.value);\n\n    if (leaf.parent) {\n      makeBranch(leaf.parent, result);\n    }\n\n    return result;\n  };\n\n  var leaf = findLeafByIndex(tree, leafIndex);\n  return makeBranch(leaf).reverse();\n};\nexport var getCellGroups = (groupIndex, groups) => {\n  var result = [];\n\n  if (getGroupCount(groups)) {\n    if (groupIndex < 0) {\n      return;\n    }\n\n    var path = getPathToLeaf(groupIndex, groups);\n\n    for (var i = 0; i < groups.length; i++) {\n      result.push({\n        name: groups[i].name,\n        id: path[i]\n      });\n    }\n  }\n\n  return result;\n};\nexport var getGroupCount = groups => {\n  var result = 0;\n\n  for (var i = 0, len = groups.length; i < len; i++) {\n    if (!i) {\n      result = groups[i].items.length;\n    } else {\n      result *= groups[i].items.length;\n    }\n  }\n\n  return result;\n};\nexport var getGroupsObjectFromGroupsArray = groupsArray => groupsArray.reduce((currentGroups, _ref) => {\n  var {\n    name: name,\n    id: id\n  } = _ref;\n  return _extends({}, currentGroups, {\n    [name]: id\n  });\n}, {});\nexport var getAllGroups = groups => {\n  var groupCount = getGroupCount(groups);\n  return [...new Array(groupCount)].map((_, groupIndex) => {\n    var groupsArray = getCellGroups(groupIndex, groups);\n    return getGroupsObjectFromGroupsArray(groupsArray);\n  });\n};\nexport var getResourceByField = (fieldName, loadedResources) => {\n  for (var i = 0; i < loadedResources.length; i++) {\n    var resource = loadedResources[i];\n\n    if (resource.name === fieldName) {\n      return resource.data;\n    }\n  }\n\n  return [];\n};\nexport var createResourceEditorModel = (resources, loadedResources) => resources.map(resource => {\n  var dataField = getFieldExpr(resource);\n  var dataSource = getResourceByField(dataField, loadedResources);\n  return {\n    editorOptions: {\n      dataSource: dataSource.length ? dataSource : getWrappedDataSource(resource.dataSource),\n      displayExpr: getDisplayExpr(resource),\n      valueExpr: getValueExpr(resource)\n    },\n    dataField: dataField,\n    editorType: resource.allowMultiple ? \"dxTagBox\" : \"dxSelectBox\",\n    label: {\n      text: resource.label || dataField\n    }\n  };\n});\nexport var isResourceMultiple = (resources, resourceField) => {\n  var resource = resources.find(resource => {\n    var field = getFieldExpr(resource);\n    return field === resourceField;\n  });\n  return !!(null !== resource && void 0 !== resource && resource.allowMultiple);\n};\nexport var filterResources = (resources, fields) => resources.filter(resource => {\n  var field = getFieldExpr(resource);\n  return fields.indexOf(field) > -1;\n});\nexport var getPaintedResources = (resources, groups) => {\n  var newGroups = groups || [];\n  var result = resources.find(resource => resource.useColorAsDefault);\n\n  if (result) {\n    return result;\n  }\n\n  var newResources = newGroups.length ? filterResources(resources, newGroups) : resources;\n  return newResources[newResources.length - 1];\n};\nexport var getOrLoadResourceItem = (resources, resourceLoaderMap, field, value) => {\n  var result = new Deferred();\n  resources.filter(resource => getFieldExpr(resource) === field && isDefined(resource.dataSource)).forEach(resource => {\n    var wrappedDataSource = getWrappedDataSource(resource.dataSource);\n    var valueExpr = getValueExpr(resource);\n\n    if (!resourceLoaderMap.has(field)) {\n      resourceLoaderMap.set(field, wrappedDataSource.load());\n    }\n\n    resourceLoaderMap.get(field).done(data => {\n      var getter = compileGetter(valueExpr);\n      var filteredData = data.filter(resource => equalByValue(getter(resource), value));\n      result.resolve(filteredData[0]);\n    }).fail(() => {\n      resourceLoaderMap.delete(field);\n      result.reject();\n    });\n  });\n  return result.promise();\n};\nexport var getDataAccessors = (dataAccessors, fieldName, type) => {\n  var actions = dataAccessors[type];\n  return actions[fieldName];\n};\nexport var groupAppointmentsByResources = function (config, appointments) {\n  var groups = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];\n  var result = {\n    0: appointments\n  };\n\n  if (groups.length && config.loadedResources.length) {\n    result = groupAppointmentsByResourcesCore(config, appointments, config.loadedResources);\n  }\n\n  var totalResourceCount = 0;\n  config.loadedResources.forEach((resource, index) => {\n    if (!index) {\n      totalResourceCount = resource.items.length;\n    } else {\n      totalResourceCount *= resource.items.length;\n    }\n  });\n\n  for (var index = 0; index < totalResourceCount; index++) {\n    var key = index.toString();\n\n    if (result[key]) {\n      continue;\n    }\n\n    result[key] = [];\n  }\n\n  return result;\n};\nexport var groupAppointmentsByResourcesCore = (config, appointments, resources) => {\n  var tree = createResourcesTree(resources);\n  var result = {};\n  appointments.forEach(appointment => {\n    var treeLeaves = getResourceTreeLeaves((field, action) => getDataAccessors(config.dataAccessors, field, action), tree, appointment);\n\n    for (var i = 0; i < treeLeaves.length; i++) {\n      if (!result[treeLeaves[i]]) {\n        result[treeLeaves[i]] = [];\n      }\n\n      result[treeLeaves[i]].push(deepExtendArraySafe({}, appointment, true));\n    }\n  });\n  return result;\n};\nexport var getResourceTreeLeaves = (getDataAccessors, tree, rawAppointment, result) => {\n  result = result || [];\n\n  for (var i = 0; i < tree.length; i++) {\n    if (!hasGroupItem(getDataAccessors, rawAppointment, tree[i].name, tree[i].value)) {\n      continue;\n    }\n\n    if (isDefined(tree[i].leafIndex)) {\n      result.push(tree[i].leafIndex);\n    }\n\n    if (tree[i].children) {\n      getResourceTreeLeaves(getDataAccessors, tree[i].children, rawAppointment, result);\n    }\n  }\n\n  return result;\n};\n\nvar hasGroupItem = (getDataAccessors, rawAppointment, groupName, itemValue) => {\n  var resourceValue = getDataAccessors(groupName, \"getter\")(rawAppointment);\n  return hasResourceValue(wrapToArray(resourceValue), itemValue);\n};\n\nexport var createReducedResourcesTree = (loadedResources, getDataAccessors, appointments) => {\n  var tree = createResourcesTree(loadedResources);\n  return reduceResourcesTree(getDataAccessors, tree, appointments);\n};\nexport var reduceResourcesTree = (getDataAccessors, tree, existingAppointments, _result) => {\n  _result = _result ? _result.children : [];\n  tree.forEach(function (node, index) {\n    var ok = false;\n    var resourceName = node.name;\n    var resourceValue = node.value;\n    var resourceTitle = node.title;\n    var resourceData = node.data;\n    var resourceGetter = getDataAccessors(resourceName, \"getter\");\n    existingAppointments.forEach(function (appointment) {\n      if (!ok) {\n        var resourceFromAppointment = resourceGetter(appointment);\n\n        if (Array.isArray(resourceFromAppointment)) {\n          if (resourceFromAppointment.indexOf(resourceValue) > -1) {\n            _result.push({\n              name: resourceName,\n              value: resourceValue,\n              title: resourceTitle,\n              data: resourceData,\n              children: []\n            });\n\n            ok = true;\n          }\n        } else if (resourceFromAppointment === resourceValue) {\n          _result.push({\n            name: resourceName,\n            value: resourceValue,\n            title: resourceTitle,\n            data: resourceData,\n            children: []\n          });\n\n          ok = true;\n        }\n      }\n    });\n\n    if (ok && node.children && node.children.length) {\n      reduceResourcesTree(getDataAccessors, node.children, existingAppointments, _result[index]);\n    }\n  });\n  return _result;\n};\nexport var getResourcesDataByGroups = (loadedResources, resources, groups) => {\n  if (!groups || !groups.length) {\n    return loadedResources;\n  }\n\n  var fieldNames = {};\n  var currentResourcesData = [];\n  groups.forEach(group => {\n    each(group, (name, value) => fieldNames[name] = value);\n  });\n  var resourceData = loadedResources.filter(_ref2 => {\n    var {\n      name: name\n    } = _ref2;\n    return isDefined(fieldNames[name]);\n  });\n  resourceData.forEach(data => currentResourcesData.push(extend({}, data)));\n  currentResourcesData.forEach(currentResource => {\n    var {\n      items: items,\n      data: data,\n      name: resourceName\n    } = currentResource;\n    var resource = filterResources(resources, [resourceName])[0] || {};\n    var valueExpr = getValueExpr(resource);\n    var filteredItems = [];\n    var filteredData = [];\n    groups.filter(group => isDefined(group[resourceName])).forEach(group => {\n      each(group, (name, value) => {\n        if (!filteredItems.filter(item => item.id === value && item[valueExpr] === name).length) {\n          var currentItems = items.filter(item => item.id === value);\n          var currentData = data.filter(item => item[valueExpr] === value);\n          filteredItems.push(...currentItems);\n          filteredData.push(...currentData);\n        }\n      });\n    });\n    currentResource.items = filteredItems;\n    currentResource.data = filteredData;\n  });\n  return currentResourcesData;\n};\nexport var setResourceToAppointment = (resources, dataAccessors, appointment, groups) => {\n  var resourcesSetter = dataAccessors.setter;\n\n  for (var name in groups) {\n    var resourceData = groups[name];\n    var value = isResourceMultiple(resources, name) ? wrapToArray(resourceData) : resourceData;\n    resourcesSetter[name](appointment, value);\n  }\n};\nexport var getResourceColor = (resources, resourceLoaderMap, field, value) => {\n  var result = new Deferred();\n  var resource = filterResources(resources, [field])[0] || {};\n  var colorExpr = resource.colorExpr || \"color\";\n  var colorGetter = compileGetter(colorExpr);\n  getOrLoadResourceItem(resources, resourceLoaderMap, field, value).done(resource => result.resolve(colorGetter(resource))).fail(() => result.reject());\n  return result.promise();\n};\nexport var getAppointmentColor = (resourceConfig, appointmentConfig) => {\n  var {\n    resources: resources,\n    dataAccessors: dataAccessors,\n    loadedResources: loadedResources,\n    resourceLoaderMap: resourceLoaderMap\n  } = resourceConfig;\n  var {\n    groupIndex: groupIndex,\n    groups: groups,\n    itemData: itemData\n  } = appointmentConfig;\n  var paintedResources = getPaintedResources(resources || [], groups);\n\n  if (paintedResources) {\n    var field = getFieldExpr(paintedResources);\n    var cellGroups = getCellGroups(groupIndex, loadedResources);\n    var resourcesDataAccessors = getDataAccessors(dataAccessors, field, \"getter\");\n    var resourceValues = wrapToArray(resourcesDataAccessors(itemData));\n    var groupId = resourceValues[0];\n\n    for (var i = 0; i < cellGroups.length; i++) {\n      if (cellGroups[i].name === field) {\n        groupId = cellGroups[i].id;\n        break;\n      }\n    }\n\n    return getResourceColor(resources, resourceLoaderMap, field, groupId);\n  }\n\n  return new Deferred().resolve().promise();\n};\nexport var createExpressions = function () {\n  var resources = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];\n  var result = {\n    getter: {},\n    setter: {}\n  };\n  resources.forEach(resource => {\n    var field = getFieldExpr(resource);\n    result.getter[field] = compileGetter(field);\n    result.setter[field] = compileSetter(field);\n  });\n  return result;\n};\n\nvar getTransformedResourceData = (resource, data) => {\n  var valueGetter = compileGetter(getValueExpr(resource));\n  var displayGetter = compileGetter(getDisplayExpr(resource));\n  return data.map(item => {\n    var result = {\n      id: valueGetter(item),\n      text: displayGetter(item)\n    };\n\n    if (item.color) {\n      result.color = item.color;\n    }\n\n    return result;\n  });\n};\n\nexport var loadResources = (groups, resources, resourceLoaderMap) => {\n  var result = new Deferred();\n  var deferreds = [];\n  var newGroups = groups || [];\n  var newResources = resources || [];\n  var loadedResources = [];\n  filterResources(newResources, newGroups).forEach(resource => {\n    var deferred = new Deferred();\n    var name = getFieldExpr(resource);\n    deferreds.push(deferred);\n    var dataSourcePromise = getWrappedDataSource(resource.dataSource).load();\n    resourceLoaderMap.set(name, dataSourcePromise);\n    dataSourcePromise.done(data => {\n      var items = getTransformedResourceData(resource, data);\n      deferred.resolve({\n        name: name,\n        items: items,\n        data: data\n      });\n    }).fail(() => deferred.reject());\n  });\n\n  if (!deferreds.length) {\n    return result.resolve(loadedResources);\n  }\n\n  when.apply(null, deferreds).done(function () {\n    for (var _len = arguments.length, resources = new Array(_len), _key = 0; _key < _len; _key++) {\n      resources[_key] = arguments[_key];\n    }\n\n    var hasEmpty = resources.some(r => 0 === r.items.length);\n    loadedResources = hasEmpty ? [] : resources;\n    result.resolve(loadedResources);\n  }).fail(() => result.reject());\n  return result.promise();\n};\nexport var getNormalizedResources = (rawAppointment, dataAccessors, resources) => {\n  var result = {};\n  each(dataAccessors.resources.getter, fieldName => {\n    var value = dataAccessors.resources.getter[fieldName](rawAppointment);\n\n    if (isDefined(value)) {\n      var isMultiple = isResourceMultiple(resources, fieldName);\n      var resourceValue = isMultiple ? wrapToArray(value) : value;\n      result[fieldName] = resourceValue;\n    }\n  });\n  return result;\n};","map":null,"metadata":{},"sourceType":"module"}