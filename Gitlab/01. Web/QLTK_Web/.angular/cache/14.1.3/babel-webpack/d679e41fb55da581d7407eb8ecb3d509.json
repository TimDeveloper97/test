{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.virtual_scrolling.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport domAdapter from \"../../../core/dom_adapter\";\nimport eventsEngine from \"../../../events/core/events_engine\";\nimport { getWindow } from \"../../../core/utils/window\";\nimport { addNamespace } from \"../../../events/utils/index\";\nimport { isDefined } from \"../../../core/utils/type\";\nvar DEFAULT_CELL_HEIGHT = 50;\nvar MIN_CELL_WIDTH = 1;\nvar MIN_SCROLL_OFFSET = 10;\nvar VIRTUAL_APPOINTMENTS_RENDER_TIMEOUT = 15;\nvar DOCUMENT_SCROLL_EVENT_NAMESPACE = addNamespace(\"scroll\", \"dxSchedulerVirtualScrolling\");\nvar scrollingOrientations = {\n  vertical: \"vertical\",\n  horizontal: \"horizontal\",\n  both: \"both\",\n  none: \"none\"\n};\nvar DefaultScrollingOrientation = scrollingOrientations.both;\nexport class VirtualScrollingDispatcher {\n  constructor(options) {\n    this.options = options;\n\n    if (options) {\n      this._rowHeight = this.getCellHeight();\n      this._cellWidth = this.getCellWidth();\n\n      this._createVirtualScrollingBase();\n    }\n  }\n\n  get isRTL() {\n    return this.options.isRTL();\n  }\n\n  get verticalVirtualScrolling() {\n    return this._verticalVirtualScrolling;\n  }\n\n  set verticalVirtualScrolling(value) {\n    this._verticalVirtualScrolling = value;\n  }\n\n  get horizontalVirtualScrolling() {\n    return this._horizontalVirtualScrolling;\n  }\n\n  set horizontalVirtualScrolling(value) {\n    this._horizontalVirtualScrolling = value;\n  }\n\n  get document() {\n    return domAdapter.getDocument();\n  }\n\n  get height() {\n    return this.options.getSchedulerHeight();\n  }\n\n  get width() {\n    return this.options.getSchedulerWidth();\n  }\n\n  get rowHeight() {\n    return this._rowHeight;\n  }\n\n  set rowHeight(value) {\n    this._rowHeight = value;\n  }\n\n  get outlineCount() {\n    return this.options.getScrolling().outlineCount;\n  }\n\n  get cellWidth() {\n    return this._cellWidth;\n  }\n\n  set cellWidth(value) {\n    this._cellWidth = value;\n  }\n\n  get viewportWidth() {\n    var width = this.width && this.options.getViewWidth();\n    return width > 0 ? width : this.options.getWindowWidth();\n  }\n\n  get viewportHeight() {\n    var height = this.height && this.options.getViewHeight();\n    return height > 0 ? height : this.options.getWindowHeight();\n  }\n\n  get cellCountInsideTopVirtualRow() {\n    var _this$verticalScrolli;\n\n    return (null === (_this$verticalScrolli = this.verticalScrollingState) || void 0 === _this$verticalScrolli ? void 0 : _this$verticalScrolli.virtualItemCountBefore) || 0;\n  }\n\n  get cellCountInsideLeftVirtualCell() {\n    var _this$horizontalScrol;\n\n    return (null === (_this$horizontalScrol = this.horizontalScrollingState) || void 0 === _this$horizontalScrol ? void 0 : _this$horizontalScrol.virtualItemCountBefore) || 0;\n  }\n\n  get cellCountInsideRightVirtualCell() {\n    var _this$horizontalScrol2;\n\n    return (null === (_this$horizontalScrol2 = this.horizontalScrollingState) || void 0 === _this$horizontalScrol2 ? void 0 : _this$horizontalScrol2.virtualItemCountAfter) || 0;\n  }\n\n  get topVirtualRowsCount() {\n    return this.cellCountInsideTopVirtualRow > 0 ? 1 : 0;\n  }\n\n  get leftVirtualCellsCount() {\n    var virtualItemsCount = !this.isRTL ? this.cellCountInsideLeftVirtualCell : this.cellCountInsideRightVirtualCell;\n    return virtualItemsCount > 0 ? 1 : 0;\n  }\n\n  get virtualRowOffset() {\n    var _this$verticalScrolli2;\n\n    return (null === (_this$verticalScrolli2 = this.verticalScrollingState) || void 0 === _this$verticalScrolli2 ? void 0 : _this$verticalScrolli2.virtualItemSizeBefore) || 0;\n  }\n\n  get virtualCellOffset() {\n    var _this$horizontalScrol3;\n\n    return (null === (_this$horizontalScrol3 = this.horizontalScrollingState) || void 0 === _this$horizontalScrol3 ? void 0 : _this$horizontalScrol3.virtualItemSizeBefore) || 0;\n  }\n\n  get scrollingState() {\n    var _this$verticalVirtual, _this$horizontalVirtu;\n\n    return {\n      vertical: null === (_this$verticalVirtual = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual ? void 0 : _this$verticalVirtual.state,\n      horizontal: null === (_this$horizontalVirtu = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu ? void 0 : _this$horizontalVirtu.state\n    };\n  }\n\n  get verticalScrollingState() {\n    return this.scrollingState.vertical;\n  }\n\n  get horizontalScrollingState() {\n    return this.scrollingState.horizontal;\n  }\n\n  get scrollingOrientation() {\n    var scrolling = this.options.getScrolling();\n\n    if (\"standard\" === scrolling.mode) {\n      return scrollingOrientations.none;\n    }\n\n    return scrolling.orientation || DefaultScrollingOrientation;\n  }\n\n  get verticalScrollingAllowed() {\n    return this.scrollingOrientation === scrollingOrientations.vertical || this.scrollingOrientation === scrollingOrientations.both;\n  }\n\n  get horizontalScrollingAllowed() {\n    return this.scrollingOrientation === scrollingOrientations.horizontal || this.scrollingOrientation === scrollingOrientations.both;\n  }\n\n  setViewOptions(options) {\n    this.options = options;\n\n    if (this.verticalVirtualScrolling) {\n      this.verticalVirtualScrolling.options = options;\n      this.verticalVirtualScrolling.itemSize = this.rowHeight;\n      this.verticalVirtualScrolling.viewportSize = this.viewportHeight;\n    }\n\n    if (this.horizontalVirtualScrolling) {\n      this.horizontalVirtualScrolling.options = options;\n      this.verticalVirtualScrolling.itemSize = this.cellWidth;\n      this.verticalVirtualScrolling.viewportSize = this.viewportWidth;\n    }\n  }\n\n  getRenderState() {\n    var _this$verticalVirtual2, _this$horizontalVirtu2;\n\n    var verticalRenderState = (null === (_this$verticalVirtual2 = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual2 ? void 0 : _this$verticalVirtual2.getRenderState()) || {};\n    var horizontalRenderState = (null === (_this$horizontalVirtu2 = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu2 ? void 0 : _this$horizontalVirtu2.getRenderState()) || {};\n    return _extends({}, verticalRenderState, horizontalRenderState);\n  }\n\n  getCellHeight() {\n    var cellHeight = this.options.getCellHeight();\n    var result = cellHeight > 0 ? cellHeight : DEFAULT_CELL_HEIGHT;\n    return Math.floor(result);\n  }\n\n  getCellWidth() {\n    var cellWidth = this.options.getCellWidth();\n    var minCellWidth = this.options.getCellMinWidth();\n\n    if (!cellWidth || cellWidth < minCellWidth) {\n      cellWidth = minCellWidth;\n    }\n\n    var result = cellWidth > 0 ? cellWidth : MIN_CELL_WIDTH;\n    return Math.floor(result);\n  }\n\n  calculateCoordinatesByDataAndPosition(cellData, position, date, isCalculateTime, isVerticalDirectionView) {\n    var {\n      rowIndex: rowIndex,\n      columnIndex: columnIndex\n    } = position;\n    var {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay\n    } = cellData;\n    var timeToScroll = date.getTime();\n    var cellStartTime = startDate.getTime();\n    var cellEndTime = endDate.getTime();\n    var scrollInCell = allDay || !isCalculateTime ? 0 : (timeToScroll - cellStartTime) / (cellEndTime - cellStartTime);\n    var cellWidth = this.getCellWidth();\n    var rowHeight = this.getCellHeight();\n    var top = isVerticalDirectionView ? (rowIndex + scrollInCell) * rowHeight : rowIndex * rowHeight;\n    var left = isVerticalDirectionView ? columnIndex * cellWidth : (columnIndex + scrollInCell) * cellWidth;\n\n    if (this.isRTL) {\n      left = this.options.getScrollableOuterWidth() - left;\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  }\n\n  dispose() {\n    if (this._onScrollHandler) {\n      eventsEngine.off(this.document, DOCUMENT_SCROLL_EVENT_NAMESPACE, this._onScrollHandler);\n    }\n  }\n\n  createVirtualScrolling() {\n    var isVerticalVirtualScrollingCreated = !!this.verticalVirtualScrolling;\n    var isHorizontalVirtualScrollingCreated = !!this.horizontalVirtualScrolling;\n\n    if (this.verticalScrollingAllowed !== isVerticalVirtualScrollingCreated || this.horizontalScrollingAllowed !== isHorizontalVirtualScrollingCreated) {\n      this._rowHeight = this.getCellHeight();\n      this._cellWidth = this.getCellWidth();\n\n      this._createVirtualScrollingBase();\n    }\n  }\n\n  _createVirtualScrollingBase() {\n    if (this.verticalScrollingAllowed) {\n      this.verticalVirtualScrolling = new VerticalVirtualScrolling(_extends({}, this.options, {\n        viewportHeight: this.viewportHeight,\n        rowHeight: this.rowHeight,\n        outlineCount: this.outlineCount\n      }));\n    }\n\n    if (this.horizontalScrollingAllowed) {\n      this.horizontalVirtualScrolling = new HorizontalVirtualScrolling(_extends({}, this.options, {\n        viewportWidth: this.viewportWidth,\n        cellWidth: this.cellWidth,\n        outlineCount: this.outlineCount\n      }));\n    }\n  }\n\n  isAttachWindowScrollEvent() {\n    return (this.horizontalScrollingAllowed || this.verticalScrollingAllowed) && !this.height;\n  }\n\n  attachScrollableEvents() {\n    if (this.isAttachWindowScrollEvent()) {\n      this._attachWindowScroll();\n    }\n  }\n\n  _attachWindowScroll() {\n    var window = getWindow();\n    this._onScrollHandler = this.options.createAction(() => {\n      var {\n        scrollX: scrollX,\n        scrollY: scrollY\n      } = window;\n\n      if (scrollX >= MIN_SCROLL_OFFSET || scrollY >= MIN_SCROLL_OFFSET) {\n        this.handleOnScrollEvent({\n          left: scrollX,\n          top: scrollY\n        });\n      }\n    });\n    eventsEngine.on(this.document, DOCUMENT_SCROLL_EVENT_NAMESPACE, this._onScrollHandler);\n  }\n\n  handleOnScrollEvent(scrollPosition) {\n    if (scrollPosition) {\n      var _this$verticalVirtual3, _this$horizontalVirtu3;\n\n      var {\n        left: left,\n        top: top\n      } = scrollPosition;\n      var verticalStateChanged = isDefined(top) && (null === (_this$verticalVirtual3 = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual3 ? void 0 : _this$verticalVirtual3.updateState(top));\n      var horizontalStateChanged = isDefined(left) && (null === (_this$horizontalVirtu3 = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu3 ? void 0 : _this$horizontalVirtu3.updateState(left));\n\n      if (verticalStateChanged || horizontalStateChanged) {\n        var _this$options$updateR, _this$options;\n\n        null === (_this$options$updateR = (_this$options = this.options).updateRender) || void 0 === _this$options$updateR ? void 0 : _this$options$updateR.call(_this$options);\n      }\n    }\n  }\n\n  updateDimensions(isForce) {\n    var cellHeight = this.getCellHeight();\n    var needUpdateVertical = this.verticalScrollingAllowed && cellHeight !== this.rowHeight;\n\n    if ((needUpdateVertical || isForce) && this.verticalVirtualScrolling) {\n      this.rowHeight = cellHeight;\n      this.verticalVirtualScrolling.viewportSize = this.viewportHeight;\n      this.verticalVirtualScrolling.reinitState(cellHeight, isForce);\n    }\n\n    var cellWidth = this.getCellWidth();\n    var needUpdateHorizontal = this.horizontalScrollingAllowed && cellWidth !== this.cellWidth;\n\n    if ((needUpdateHorizontal || isForce) && this.horizontalVirtualScrolling) {\n      this.cellWidth = cellWidth;\n      this.horizontalVirtualScrolling.viewportSize = this.viewportWidth;\n      this.horizontalVirtualScrolling.reinitState(cellWidth, isForce);\n    }\n\n    if (needUpdateVertical || needUpdateHorizontal) {\n      var _this$options$updateG, _this$options2;\n\n      null === (_this$options$updateG = (_this$options2 = this.options).updateGrid) || void 0 === _this$options$updateG ? void 0 : _this$options$updateG.call(_this$options2);\n    }\n  }\n\n}\n\nclass VirtualScrollingBase {\n  constructor(options) {\n    this.options = options;\n    this._state = this.defaultState;\n    this.viewportSize = options.viewportSize;\n    this._itemSize = options.itemSize;\n    this._position = -1;\n    this._itemSizeChanged = false;\n    this.updateState(0);\n  }\n\n  get itemSize() {\n    return this._itemSize;\n  }\n\n  set itemSize(value) {\n    this._itemSizeChanged = this._itemSize !== value;\n    this._itemSize = value;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  set state(value) {\n    this._state = value;\n  }\n\n  get startIndex() {\n    return this.state.startIndex;\n  }\n\n  get pageSize() {\n    return Math.ceil(this.viewportSize / this.itemSize);\n  }\n\n  get outlineCount() {\n    return isDefined(this.options.outlineCount) ? this.options.outlineCount : Math.floor(this.pageSize / 2);\n  }\n\n  get groupCount() {\n    return this.options.getGroupCount();\n  }\n\n  get isVerticalGrouping() {\n    return this.options.isVerticalGrouping();\n  }\n\n  get defaultState() {\n    return {\n      prevPosition: 0,\n      startIndex: -1,\n      itemCount: 0,\n      virtualItemCountBefore: 0,\n      virtualItemCountAfter: 0,\n      outlineCountBefore: 0,\n      outlineCountAfter: 0,\n      virtualItemSizeBefore: 0,\n      virtualItemSizeAfter: 0,\n      outlineSizeBefore: 0,\n      outlineSizeAfter: 0\n    };\n  }\n\n  get maxScrollPosition() {\n    return this.getTotalItemCount() * this.itemSize - this.viewportSize;\n  }\n\n  get position() {\n    return this._position;\n  }\n\n  set position(value) {\n    this._position = value;\n  }\n\n  needUpdateState(position) {\n    var {\n      prevPosition: prevPosition,\n      startIndex: startIndex\n    } = this.state;\n    var isFirstInitialization = startIndex < 0;\n\n    if (isFirstInitialization) {\n      return true;\n    }\n\n    var isStartIndexChanged = false;\n\n    if (this._validateAndSavePosition(position)) {\n      if (0 === position || position === this.maxScrollPosition) {\n        return true;\n      }\n\n      var currentPosition = prevPosition;\n      var currentItemsCount = Math.floor(currentPosition / this.itemSize);\n      var itemsCount = Math.floor(position / this.itemSize);\n      isStartIndexChanged = Math.abs(currentItemsCount - itemsCount) >= this.outlineCount;\n    }\n\n    return isStartIndexChanged;\n  }\n\n  _validateAndSavePosition(position) {\n    if (!isDefined(position)) {\n      return false;\n    }\n\n    var result = this.position !== position;\n    this.position = position;\n    return result;\n  }\n\n  _correctPosition(position) {\n    return position >= 0 ? Math.min(position, this.maxScrollPosition) : -1;\n  }\n\n  updateState(position, isForce) {\n    position = this._correctPosition(position);\n\n    if (!this.needUpdateState(position) && !isForce) {\n      return false;\n    }\n\n    var itemsInfoBefore = this._calcItemInfoBefore(position);\n\n    var itemsDeltaBefore = this._calcItemDeltaBefore(itemsInfoBefore);\n\n    var {\n      outlineCountAfter: outlineCountAfter,\n      virtualItemCountAfter: virtualItemCountAfter,\n      itemCountWithAfter: itemCountWithAfter\n    } = this._calcItemInfoAfter(itemsDeltaBefore);\n\n    var {\n      virtualItemCountBefore: virtualItemCountBefore,\n      outlineCountBefore: outlineCountBefore\n    } = itemsInfoBefore;\n    var itemCount = outlineCountBefore + itemCountWithAfter + outlineCountAfter;\n    var itemCountBefore = Math.floor(position / this.itemSize);\n    this.state.prevPosition = itemCountBefore * this.itemSize;\n    this.state.startIndex = itemCountBefore - outlineCountBefore;\n    this.state.virtualItemCountBefore = virtualItemCountBefore;\n    this.state.outlineCountBefore = outlineCountBefore;\n    this.state.itemCount = itemCount;\n    this.state.outlineCountAfter = outlineCountAfter;\n    this.state.virtualItemCountAfter = virtualItemCountAfter;\n\n    this._updateStateCore();\n\n    return true;\n  }\n\n  reinitState(itemSize, isForceUpdate) {\n    var {\n      position: position\n    } = this;\n    this.itemSize = itemSize;\n    this.updateState(0, isForceUpdate);\n\n    if (position > 0) {\n      this.updateState(position, isForceUpdate);\n    }\n  }\n\n  _calcItemInfoBefore(position) {\n    var virtualItemCountBefore = Math.floor(position / this.itemSize);\n    var outlineCountBefore = Math.min(virtualItemCountBefore, this.outlineCount);\n    virtualItemCountBefore -= outlineCountBefore;\n    return {\n      virtualItemCountBefore: virtualItemCountBefore,\n      outlineCountBefore: outlineCountBefore\n    };\n  }\n\n  _calcItemDeltaBefore(itemInfoBefore) {\n    var {\n      virtualItemCountBefore: virtualItemCountBefore,\n      outlineCountBefore: outlineCountBefore\n    } = itemInfoBefore;\n    var totalItemCount = this.getTotalItemCount();\n    return totalItemCount - virtualItemCountBefore - outlineCountBefore;\n  }\n\n  getTotalItemCount() {\n    throw \"getTotalItemCount method should be implemented\";\n  }\n\n  getRenderState() {\n    throw \"getRenderState method should be implemented\";\n  }\n\n  _calcItemInfoAfter(itemsDeltaBefore) {\n    var itemCountWithAfter = itemsDeltaBefore >= this.pageSize ? this.pageSize : itemsDeltaBefore;\n    var virtualItemCountAfter = itemsDeltaBefore - itemCountWithAfter;\n    var outlineCountAfter = virtualItemCountAfter > 0 ? Math.min(virtualItemCountAfter, this.outlineCount) : 0;\n\n    if (virtualItemCountAfter > 0) {\n      virtualItemCountAfter -= outlineCountAfter;\n    }\n\n    return {\n      virtualItemCountAfter: virtualItemCountAfter,\n      outlineCountAfter: outlineCountAfter,\n      itemCountWithAfter: itemCountWithAfter\n    };\n  }\n\n  _updateStateCore() {\n    var {\n      state: state\n    } = this;\n    var virtualItemCountBefore = state.virtualItemCountBefore;\n    var virtualItemCountAfter = state.virtualItemCountAfter;\n    var outlineCountBefore = state.outlineCountBefore;\n    var outlineCountAfter = state.outlineCountAfter;\n    var prevVirtualItemSizeBefore = state.virtualItemSizeBefore;\n    var prevVirtualItemSizeAfter = state.virtualItemSizeAfter;\n    var prevOutlineSizeBefore = state.outlineSizeBefore;\n    var prevOutlineSizeAfter = state.outlineSizeAfter;\n    var virtualItemSizeBefore = this.itemSize * virtualItemCountBefore;\n    var virtualItemSizeAfter = this.itemSize * virtualItemCountAfter;\n    var outlineSizeBefore = this.itemSize * outlineCountBefore;\n    var outlineSizeAfter = this.itemSize * outlineCountAfter;\n    var prevVirtualSizeBefore = prevVirtualItemSizeBefore + prevOutlineSizeBefore;\n    var virtualSizeBefore = virtualItemSizeBefore + outlineSizeBefore;\n    var prevVirtualSizeAfter = prevVirtualItemSizeAfter + prevOutlineSizeAfter;\n    var virtualSizeAfter = virtualItemSizeAfter + outlineSizeAfter;\n    var isAppend = prevVirtualSizeBefore < virtualSizeBefore;\n    var isPrepend = prevVirtualSizeAfter < virtualSizeAfter;\n    var needAddItems = this._itemSizeChanged || isAppend || isPrepend;\n\n    if (needAddItems) {\n      this._updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter);\n    }\n  }\n\n  _updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter) {\n    var {\n      state: state\n    } = this;\n    state.virtualItemSizeBefore = virtualItemSizeBefore;\n    state.virtualItemSizeAfter = virtualItemSizeAfter;\n  }\n\n}\n\nclass VerticalVirtualScrolling extends VirtualScrollingBase {\n  constructor(options) {\n    super(_extends({}, options, {\n      itemSize: options.rowHeight,\n      viewportSize: options.viewportHeight\n    }));\n  }\n\n  get prevTopPosition() {\n    return this.state.prevPosition;\n  }\n\n  get rowCount() {\n    return this.state.itemCount;\n  }\n\n  get topVirtualRowCount() {\n    return this.state.virtualItemCountBefore;\n  }\n\n  get bottomVirtualRowCount() {\n    return this.state.virtualItemCountAfter;\n  }\n\n  getTotalItemCount() {\n    return this.options.getTotalRowCount(this.groupCount, this.isVerticalGrouping);\n  }\n\n  getRenderState() {\n    return {\n      topVirtualRowHeight: this.state.virtualItemSizeBefore,\n      bottomVirtualRowHeight: this.state.virtualItemSizeAfter,\n      startRowIndex: this.state.startIndex,\n      rowCount: this.state.itemCount,\n      startIndex: this.state.startIndex\n    };\n  }\n\n}\n\nclass HorizontalVirtualScrolling extends VirtualScrollingBase {\n  constructor(options) {\n    super(_extends({}, options, {\n      itemSize: options.cellWidth,\n      viewportSize: options.viewportWidth\n    }));\n  }\n\n  get isRTL() {\n    return this.options.isRTL();\n  }\n\n  getTotalItemCount() {\n    return this.options.getTotalCellCount(this.groupCount, this.isVerticalGrouping);\n  }\n\n  getRenderState() {\n    return {\n      leftVirtualCellWidth: this.state.virtualItemSizeBefore,\n      rightVirtualCellWidth: this.state.virtualItemSizeAfter,\n      startCellIndex: this.state.startIndex,\n      cellCount: this.state.itemCount,\n      cellWidth: this.itemSize\n    };\n  }\n\n  _updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter) {\n    if (!this.isRTL) {\n      super._updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter);\n    } else {\n      var {\n        state: state\n      } = this;\n      state.virtualItemSizeAfter = virtualItemSizeBefore;\n      state.virtualItemSizeBefore = virtualItemSizeAfter;\n      state.startIndex = this.getTotalItemCount() - this.startIndex - this.state.itemCount;\n    }\n  }\n\n}\n\nexport class VirtualScrollingRenderer {\n  constructor(workspace) {\n    this._workspace = workspace;\n    this._renderAppointmentTimeoutID = null;\n  }\n\n  getRenderTimeout() {\n    return this._workspace.option(\"isRenovatedAppointments\") ? -1 : VIRTUAL_APPOINTMENTS_RENDER_TIMEOUT;\n  }\n\n  get workspace() {\n    return this._workspace;\n  }\n\n  updateRender() {\n    this._renderGrid();\n\n    this._renderAppointments();\n  }\n\n  _renderGrid() {\n    this.workspace.renderWorkSpace(false);\n  }\n\n  _renderAppointments() {\n    var renderTimeout = this.getRenderTimeout();\n\n    if (renderTimeout >= 0) {\n      clearTimeout(this._renderAppointmentTimeoutID);\n      this._renderAppointmentTimeoutID = setTimeout(() => this.workspace.updateAppointments(), renderTimeout);\n    } else {\n      this.workspace.updateAppointments();\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}