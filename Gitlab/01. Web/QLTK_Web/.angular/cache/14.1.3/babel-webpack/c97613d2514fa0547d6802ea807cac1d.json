{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/core/plaque.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nvar _excluded = [\"x\", \"y\", \"canvas\", \"offsetX\", \"offsetY\", \"offset\"];\nimport { extend } from \"../../core/utils/extend\";\nimport { isDefined } from \"../../core/utils/type\";\nvar math = Math;\nvar round = math.round;\nvar max = math.max;\nvar min = math.min;\nvar sin = math.sin;\nvar cos = math.cos;\nvar asin = math.asin;\nvar PI = math.PI;\n\nvar buildPath = function () {\n  for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {\n    points[_key] = arguments[_key];\n  }\n\n  return points.join(\"\");\n};\n\nfunction getArc(cornerRadius, xDirection, yDirection) {\n  return \"a \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(xDirection * cornerRadius, \" \").concat(yDirection * cornerRadius);\n}\n\nfunction getAbsoluteArc(cornerRadius, x, y) {\n  return \"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(x, \" \").concat(y);\n}\n\nfunction rotateX(x, y, angle, x0, y0) {\n  return (x - x0) * round(cos(angle)) + (y - y0) * round(sin(angle)) + x0;\n}\n\nfunction rotateY(x, y, angle, x0, y0) {\n  return -(x - x0) * round(sin(angle)) + (y - y0) * round(cos(angle)) + y0;\n}\n\nfunction rotateSize(options, angle) {\n  if (angle % 90 === 0 && angle % 180 !== 0) {\n    return {\n      width: options.height,\n      height: options.width\n    };\n  }\n\n  return options;\n}\n\nfunction getCloudAngle(_ref, x, y, anchorX, anchorY) {\n  var {\n    width: width,\n    height: height\n  } = _ref;\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var xr = Math.ceil(x + halfWidth);\n  var xl = Math.floor(x - halfWidth);\n  var yt = Math.floor(y - halfHeight);\n  var yb = Math.ceil(y + halfHeight);\n\n  if (anchorX < xl && anchorY < yt || anchorX >= xl && anchorX <= xr && anchorY < yt) {\n    return 270;\n  }\n\n  if (anchorX > xr && anchorY > yb || anchorX >= xl && anchorX <= xr && anchorY > yb) {\n    return 90;\n  } else if (anchorX < xl && anchorY > yb || anchorX < xl && anchorY >= yt && anchorY <= yb) {\n    return 180;\n  }\n\n  return 0;\n}\n\nfunction getCloudPoints(_ref2, x, y, anchorX, anchorY, _ref3, bounded) {\n  var {\n    width: width,\n    height: height\n  } = _ref2;\n  var {\n    arrowWidth: arrowWidth,\n    cornerRadius = 0\n  } = _ref3;\n  var halfArrowWidth = arrowWidth / 2;\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var xr = Math.ceil(x + halfWidth);\n  var xl = Math.floor(x - halfWidth);\n  var yt = Math.floor(y - halfHeight);\n  var yb = Math.ceil(y + halfHeight);\n  var leftTopCorner = [xl, yt];\n  var rightTopCorner = [xr, yt];\n  var rightBottomCorner = [xr, yb];\n  var leftBottomCorner = [xl, yb];\n  var arrowX = anchorX <= xl ? xl : xr <= anchorX ? xr : anchorX;\n  var arrowY = anchorY <= yt ? yt : yb <= anchorY ? yb : anchorY;\n  var arrowBaseBottom = min(arrowY + halfArrowWidth, yb);\n  var arrowBaseTop = max(arrowY - halfArrowWidth, yt);\n  var arrowBaseLeft = max(arrowX - halfArrowWidth, xl);\n  cornerRadius = Math.min(width / 2, height / 2, cornerRadius);\n  var points;\n  leftTopCorner[1] += cornerRadius;\n  rightTopCorner[0] -= cornerRadius;\n  rightBottomCorner[1] -= cornerRadius;\n  leftBottomCorner[0] += cornerRadius;\n\n  if (!bounded || xl <= anchorX && anchorX <= xr && yt <= anchorY && anchorY <= yb) {\n    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), \"L\", rightTopCorner, getArc(cornerRadius, 1, 1), \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1), \"L\", leftBottomCorner, getArc(cornerRadius, -1, -1));\n  } else if (anchorX > xr && anchorY < yt) {\n    var arrowAngle = arrowWidth / cornerRadius || 0;\n    var angle = PI / 4 + arrowAngle / 2;\n    var endAngle = PI / 4 - arrowAngle / 2;\n    var arrowEndPointX = rightTopCorner[0] + cos(endAngle) * cornerRadius;\n    var arrowEndPointY = rightTopCorner[1] + (1 - sin(endAngle)) * cornerRadius;\n    var arrowArc = buildPath(\"L\", rightTopCorner, getArc(cornerRadius, cos(angle), 1 - sin(angle)), \"L\", [anchorX, anchorY, arrowEndPointX, arrowEndPointY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius));\n\n    if (Math.abs(angle) > PI / 2) {\n      arrowArc = buildPath(\"L\", [arrowBaseLeft, yt, anchorX, anchorY, xr, arrowBaseBottom]);\n    }\n\n    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), arrowArc, \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1), \"L\", leftBottomCorner, getArc(cornerRadius, -1, -1));\n  } else if (anchorX > xr && anchorY >= yt && anchorY <= yb) {\n    var _arrowArc;\n\n    if (arrowBaseTop >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {\n      _arrowArc = buildPath(getArc(cornerRadius, 1, 1), \"L\", [xr, arrowBaseTop, anchorX, anchorY, xr, arrowBaseBottom], \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1));\n    } else if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {\n      var arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;\n\n      var _angle = arrowWidthRest / cornerRadius;\n\n      var arrowBaseTopX = rightTopCorner[0] + cos(_angle) * cornerRadius;\n      var arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle)) * cornerRadius;\n      _arrowArc = buildPath(getArc(cornerRadius, cos(_angle), 1 - sin(_angle)), \"L\", [arrowBaseTopX, arrowBaseTopY, anchorX, anchorY, xr, arrowBaseBottom], \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1));\n    } else if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom < rightTopCorner[1] + cornerRadius) {\n      var _arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;\n\n      var _arrowAngle = _arrowWidthRest / cornerRadius;\n\n      var _angle2 = _arrowAngle;\n\n      var _arrowBaseTopX = rightTopCorner[0] + cos(_angle2) * cornerRadius;\n\n      var _arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle2)) * cornerRadius;\n\n      var bottomAngle = Math.sin((rightTopCorner[1] + cornerRadius - arrowBaseBottom) / cornerRadius);\n      var arrowBaseBottomX = rightTopCorner[0] + cornerRadius * cos(bottomAngle);\n      var arrowBaseBottomY = rightTopCorner[1] + cornerRadius * (1 - sin(bottomAngle));\n      _arrowArc = buildPath(getArc(cornerRadius, cos(_angle2), 1 - sin(_angle2)), \"L\", [_arrowBaseTopX, _arrowBaseTopY, anchorX, anchorY, arrowBaseBottomX, arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius), \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1));\n    } else if (arrowBaseTop <= rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightBottomCorner[1]) {\n      var topAngle = asin((rightTopCorner[1] + cornerRadius - arrowBaseTop) / cornerRadius);\n\n      var _arrowBaseTopX2 = rightTopCorner[0] + cornerRadius * cos(topAngle);\n\n      var _arrowBaseTopY2 = rightTopCorner[1] + cornerRadius * (1 - sin(topAngle));\n\n      var _bottomAngle = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);\n\n      var _arrowBaseBottomX = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle) - 1);\n\n      var _arrowBaseBottomY = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle);\n\n      _arrowArc = buildPath(getArc(cornerRadius, cos(topAngle), 1 - sin(topAngle)), \"L\", [_arrowBaseTopX2, _arrowBaseTopY2, anchorX, anchorY, _arrowBaseBottomX, _arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));\n    } else if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseTop <= rightBottomCorner[1] && arrowBaseBottom > rightBottomCorner[1]) {\n      var _bottomAngle2 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);\n\n      var _arrowBaseBottomX2 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle2) - 1);\n\n      var _arrowBaseBottomY2 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle2);\n\n      _arrowArc = buildPath(getArc(cornerRadius, 1, 1), \"L\", [xr, arrowBaseTop, anchorX, anchorY, _arrowBaseBottomX2, _arrowBaseBottomY2], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));\n    } else if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseBottom > rightBottomCorner[1]) {\n      var _bottomAngle3 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);\n\n      var _arrowBaseBottomX3 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle3) - 1);\n\n      var _arrowBaseBottomY3 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle3);\n\n      var _topAngle = asin((arrowBaseTop - rightBottomCorner[1]) / cornerRadius);\n\n      var _arrowBaseTopX3 = rightBottomCorner[0] + cornerRadius * (cos(_topAngle) - 1);\n\n      var _arrowBaseTopY3 = rightBottomCorner[1] + cornerRadius * sin(_topAngle);\n\n      _arrowArc = buildPath(getArc(cornerRadius, 1, 1), \"L\", rightBottomCorner, getArc(cornerRadius, cos(_topAngle) - 1, sin(_topAngle)), \"L\", [_arrowBaseTopX3, _arrowBaseTopY3, anchorX, anchorY, _arrowBaseBottomX3, _arrowBaseBottomY3], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));\n    }\n\n    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), \"L\", rightTopCorner, _arrowArc, \"L\", leftBottomCorner, getArc(cornerRadius, -1, -1));\n  }\n\n  return buildPath(\"M\", points, \"Z\");\n}\n\nexport class Plaque {\n  constructor(options, widget, root, contentTemplate) {\n    var bounded = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : true;\n    var measureContent = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : (_, g) => g.getBBox();\n    var moveContentGroup = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : (_, g, x, y) => g.move(x, y);\n    this.widget = widget;\n    this.options = options;\n    this.root = root;\n    this.contentTemplate = contentTemplate;\n    this.bonded = bounded;\n    this.measureContent = measureContent;\n    this.moveContentGroup = moveContentGroup;\n  }\n\n  draw(_ref4) {\n    var {\n      x: anchorX,\n      y: anchorY,\n      canvas = {},\n      offsetX: offsetX,\n      offsetY: offsetY,\n      offset = 0\n    } = _ref4,\n        restProps = _objectWithoutPropertiesLoose(_ref4, _excluded);\n\n    var options = this.options;\n    var {\n      x: x,\n      y: y\n    } = options;\n    var bounds_xl = canvas.left,\n        bounds_xr = canvas.width - canvas.right,\n        bounds_width = canvas.width - canvas.right - canvas.left,\n        bounds_yt = canvas.top,\n        bounds_yb = canvas.height - canvas.bottom,\n        bounds_height = canvas.height - canvas.bottom - canvas.top;\n\n    if (!(isDefined(anchorX) && isDefined(anchorY)) && !(isDefined(x) && isDefined(y))) {\n      return false;\n    }\n\n    if (isDefined(anchorX) && (anchorX < bounds_xl || bounds_xr < anchorX || anchorY < bounds_yt || bounds_yb < anchorY)) {\n      return false;\n    }\n\n    if (!this._root) {\n      this._draw();\n    }\n\n    var shadowSettings = extend({\n      x: \"-50%\",\n      y: \"-50%\",\n      width: \"200%\",\n      height: \"200%\"\n    }, options.shadow);\n    var contentWidth = options.width > 0 ? options.width : null;\n    var contentHeight = options.height > 0 ? options.height : null;\n\n    var onRender = () => {\n      var _this$_root;\n\n      var bBox = this._contentBBox = this.measureContent(this.widget, this._contentGroup);\n      var size = this._size = {\n        width: max(contentWidth, bBox.width) + 2 * options.paddingLeftRight,\n        height: max(contentHeight, bBox.height) + 2 * options.paddingTopBottom,\n        offset: offset\n      };\n      var xOff = shadowSettings.offsetX;\n      var yOff = shadowSettings.offsetY;\n      var blur = 2 * shadowSettings.blur + 1;\n      var lm = max(blur - xOff, 0);\n      var rm = max(blur + xOff, 0);\n      var tm = max(blur - yOff, 0);\n      var bm = max(blur + yOff, 0);\n      this.margins = {\n        lm: lm,\n        rm: rm,\n        tm: tm,\n        bm: bm\n      };\n\n      if (!isDefined(x)) {\n        if (isDefined(offsetX)) {\n          x = anchorX + offsetX;\n        } else if (bounds_width < size.width) {\n          x = round(bounds_xl + bounds_width / 2);\n        } else {\n          x = min(max(anchorX, Math.ceil(bounds_xl + size.width / 2 + lm)), Math.floor(bounds_xr - size.width / 2 - rm));\n        }\n      } else {\n        x += offsetX || 0;\n\n        if (!isDefined(anchorX)) {\n          anchorX = x;\n        }\n      }\n\n      if (!isDefined(y)) {\n        if (isDefined(offsetY)) {\n          y = anchorY + offsetY;\n        } else {\n          var y_top = anchorY - options.arrowLength - size.height / 2 - offset;\n          var y_bottom = anchorY + options.arrowLength + size.height / 2 + offset;\n\n          if (bounds_height < size.height + options.arrowLength) {\n            y = round(bounds_yt + size.height / 2);\n          } else if (y_top - size.height / 2 - tm < bounds_yt) {\n            if (y_bottom + size.height / 2 + bm < bounds_yb) {\n              y = y_bottom;\n              anchorY += offset;\n            } else {\n              y = round(bounds_yt + size.height / 2);\n            }\n          } else {\n            y = y_top;\n            anchorY -= offset;\n          }\n        }\n      } else {\n        y += offsetY || 0;\n\n        if (!isDefined(anchorY)) {\n          anchorY = y + size.height / 2;\n        }\n      }\n\n      this.anchorX = anchorX;\n      this.anchorY = anchorY;\n      this.move(x, y);\n      null === (_this$_root = this._root) || void 0 === _this$_root ? void 0 : _this$_root.append(this.root);\n    };\n\n    if (this.contentTemplate.render) {\n      this.contentTemplate.render({\n        model: options,\n        container: this._contentGroup.element,\n        onRendered: onRender\n      });\n    } else {\n      return this.contentTemplate(_extends({\n        group: this._contentGroup,\n        onRender: onRender\n      }, restProps));\n    }\n\n    return true;\n  }\n\n  _draw() {\n    var renderer = this.widget._renderer;\n    var options = this.options;\n    var shadowSettings = extend({\n      x: \"-50%\",\n      y: \"-50%\",\n      width: \"200%\",\n      height: \"200%\"\n    }, options.shadow);\n    var shadow = this._shadow = renderer.shadowFilter().attr(shadowSettings);\n    var cloudSettings = {\n      opacity: options.opacity,\n      \"stroke-width\": 0,\n      fill: options.color\n    };\n    var borderOptions = options.border || {};\n\n    if (borderOptions.visible) {\n      extend(cloudSettings, {\n        \"stroke-width\": borderOptions.width,\n        stroke: borderOptions.color,\n        \"stroke-opacity\": borderOptions.opacity,\n        dashStyle: borderOptions.dashStyle\n      });\n    }\n\n    var group = this._root = renderer.g().append(this.root);\n\n    if (options.type) {\n      group.attr({\n        class: \"dxc-\".concat(options.type, \"-annotation\")\n      });\n    }\n\n    var cloudGroup = renderer.g().attr({\n      filter: shadow.id\n    }).append(group);\n    this._cloud = renderer.path([], \"area\").attr(cloudSettings).sharp().append(cloudGroup);\n    this._contentGroup = renderer.g().append(group);\n  }\n\n  getBBox() {\n    var size = this._size || {};\n    var margins = this.margins || {};\n    var rotationAngle = getCloudAngle(size, this.x, this.y, this.anchorX, this.anchorY);\n    return {\n      x: Math.floor(this.x - size.width / 2 - margins.lm),\n      y: Math.floor(this.y - size.height / 2 - margins.tm - (270 === rotationAngle ? this.options.arrowLength : 0)),\n      width: size.width + margins.lm + margins.rm,\n      height: size.height + margins.tm + margins.bm + (90 === rotationAngle || 270 === rotationAngle ? this.options.arrowLength : 0)\n    };\n  }\n\n  clear() {\n    if (this._root) {\n      this._root.remove();\n\n      this._shadow.remove();\n\n      this._root = null;\n    }\n\n    return this;\n  }\n\n  customizeCloud(attr) {\n    if (this._cloud) {\n      this._cloud.attr(attr);\n    }\n  }\n\n  moveRoot(x, y) {\n    if (this._root) {\n      this._root.move(x, y);\n    }\n  }\n\n  move(x, y) {\n    x = round(x);\n    y = round(y);\n    this.x = x;\n    this.y = y;\n    var rotationAngle = getCloudAngle(this._size, x, y, this.anchorX, this.anchorY);\n    var radRotationAngle = rotationAngle * PI / 180;\n\n    this._cloud.attr({\n      d: getCloudPoints(rotateSize(this._size, rotationAngle), x, y, rotateX(this.anchorX, this.anchorY, radRotationAngle, x, y), rotateY(this.anchorX, this.anchorY, radRotationAngle, x, y), this.options, this.bonded)\n    }).rotate(rotationAngle, x, y);\n\n    this.moveContentGroup(this.widget, this._contentGroup, x - this._contentBBox.x - this._contentBBox.width / 2, y - this._contentBBox.y - this._contentBBox.height / 2);\n  }\n\n  hitTest(x, y) {\n    var {\n      width: width,\n      height: height\n    } = this._size || {};\n    return Math.abs(x - this.x) <= width / 2 && Math.abs(y - this.y) <= height / 2;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}