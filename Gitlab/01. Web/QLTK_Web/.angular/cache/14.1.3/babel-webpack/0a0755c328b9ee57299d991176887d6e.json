{"ast":null,"code":"/**\r\n * DevExtreme (esm/renovation/ui/button.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nvar _excluded = [\"accessKey\", \"activeStateEnabled\", \"children\", \"className\", \"disabled\", \"focusStateEnabled\", \"height\", \"hint\", \"hoverStateEnabled\", \"icon\", \"iconPosition\", \"iconTemplate\", \"onClick\", \"onKeyDown\", \"onSubmit\", \"pressed\", \"rtlEnabled\", \"stylingMode\", \"tabIndex\", \"template\", \"templateData\", \"text\", \"type\", \"useInkRipple\", \"useSubmitBehavior\", \"visible\", \"width\"];\nimport { createVNode, createComponentVNode, normalizeProps } from \"inferno\";\nimport { InfernoEffect, InfernoWrapperComponent } from \"@devextreme/runtime/inferno\";\nimport { createDefaultOptionRules, convertRulesToOptions } from \"../../core/options/utils\";\nimport devices from \"../../core/devices\";\nimport { isMaterial, current } from \"../../ui/themes\";\nimport { click } from \"../../events/short\";\nimport { combineClasses } from \"../utils/combine_classes\";\nimport { getImageSourceType } from \"../../core/utils/icon\";\nimport { Icon } from \"./common/icon\";\nimport { InkRipple } from \"./common/ink_ripple\";\nimport { Widget } from \"./common/widget\";\nimport { BaseWidgetProps } from \"./common/base_props\";\nvar stylingModes = [\"outlined\", \"text\", \"contained\"];\n\nvar getCssClasses = model => {\n  var {\n    icon: icon,\n    iconPosition: iconPosition,\n    stylingMode: stylingMode,\n    text: text,\n    type: type\n  } = model;\n  var isValidStylingMode = stylingMode && stylingModes.includes(stylingMode);\n  var classesMap = {\n    \"dx-button\": true,\n    [\"dx-button-mode-\".concat(isValidStylingMode ? stylingMode : \"contained\")]: true,\n    [\"dx-button-\".concat(null !== type && void 0 !== type ? type : \"normal\")]: true,\n    \"dx-button-has-text\": !!text,\n    \"dx-button-has-icon\": !!icon,\n    \"dx-button-icon-right\": \"left\" !== iconPosition\n  };\n  return combineClasses(classesMap);\n};\n\nexport var viewFunction = viewModel => {\n  var {\n    children: children,\n    iconPosition: iconPosition,\n    iconTemplate: IconTemplate,\n    template: ButtonTemplate,\n    text: text\n  } = viewModel.props;\n  var renderText = !viewModel.props.template && !children && \"\" !== text;\n  var isIconLeft = \"left\" === iconPosition;\n  var iconComponent = !viewModel.props.template && !children && (viewModel.iconSource || viewModel.props.iconTemplate) && createComponentVNode(2, Icon, {\n    source: viewModel.iconSource,\n    position: iconPosition,\n    iconTemplate: IconTemplate\n  });\n  return normalizeProps(createComponentVNode(2, Widget, _extends({\n    accessKey: viewModel.props.accessKey,\n    activeStateEnabled: viewModel.props.activeStateEnabled,\n    aria: viewModel.aria,\n    className: viewModel.props.className,\n    classes: viewModel.cssClasses,\n    disabled: viewModel.props.disabled,\n    focusStateEnabled: viewModel.props.focusStateEnabled,\n    height: viewModel.props.height,\n    hint: viewModel.props.hint,\n    hoverStateEnabled: viewModel.props.hoverStateEnabled,\n    onActive: viewModel.onActive,\n    onClick: viewModel.onWidgetClick,\n    onInactive: viewModel.onInactive,\n    onKeyDown: viewModel.keyDown,\n    rtlEnabled: viewModel.props.rtlEnabled,\n    tabIndex: viewModel.props.tabIndex,\n    visible: viewModel.props.visible,\n    width: viewModel.props.width\n  }, viewModel.restAttributes, {\n    children: createVNode(1, \"div\", \"dx-button-content\", [viewModel.props.template && ButtonTemplate({\n      data: viewModel.buttonTemplateData\n    }), !viewModel.props.template && children, isIconLeft && iconComponent, renderText && createVNode(1, \"span\", \"dx-button-text\", text, 0), !isIconLeft && iconComponent, viewModel.props.useSubmitBehavior && createVNode(64, \"input\", \"dx-button-submit-input\", null, 1, {\n      type: \"submit\",\n      tabIndex: -1\n    }, null, viewModel.submitInputRef), viewModel.props.useInkRipple && createComponentVNode(2, InkRipple, {\n      config: viewModel.inkRippleConfig\n    }, null, viewModel.inkRippleRef)], 0, null, null, viewModel.contentRef)\n  }), null, viewModel.widgetRef));\n};\nexport var ButtonProps = Object.create(Object.prototype, _extends(Object.getOwnPropertyDescriptors(BaseWidgetProps), Object.getOwnPropertyDescriptors({\n  activeStateEnabled: true,\n  hoverStateEnabled: true,\n  icon: \"\",\n  iconPosition: \"left\",\n  stylingMode: \"contained\",\n  text: \"\",\n  type: \"normal\",\n  useInkRipple: false,\n  useSubmitBehavior: false,\n  templateData: Object.freeze({})\n})));\nexport var defaultOptionRules = createDefaultOptionRules([{\n  device: () => \"desktop\" === devices.real().deviceType && !devices.isSimulator(),\n  options: {\n    focusStateEnabled: true\n  }\n}, {\n  device: () => isMaterial(current()),\n  options: {\n    useInkRipple: true\n  }\n}]);\nimport { createReRenderEffect } from \"@devextreme/runtime/inferno\";\nimport { createRef as infernoCreateRef } from \"inferno\";\n\nvar getTemplate = TemplateProp => TemplateProp && (TemplateProp.defaultProps ? props => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);\n\nexport class Button extends InfernoWrapperComponent {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.contentRef = infernoCreateRef();\n    this.inkRippleRef = infernoCreateRef();\n    this.submitInputRef = infernoCreateRef();\n    this.widgetRef = infernoCreateRef();\n    this.__getterCache = {};\n    this.focus = this.focus.bind(this);\n    this.activate = this.activate.bind(this);\n    this.deactivate = this.deactivate.bind(this);\n    this.submitEffect = this.submitEffect.bind(this);\n    this.onActive = this.onActive.bind(this);\n    this.onInactive = this.onInactive.bind(this);\n    this.onWidgetClick = this.onWidgetClick.bind(this);\n    this.keyDown = this.keyDown.bind(this);\n  }\n\n  createEffects() {\n    return [new InfernoEffect(this.submitEffect, [this.props.onSubmit, this.props.useSubmitBehavior]), createReRenderEffect()];\n  }\n\n  updateEffects() {\n    var _this$_effects$;\n\n    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ ? void 0 : _this$_effects$.update([this.props.onSubmit, this.props.useSubmitBehavior]);\n  }\n\n  submitEffect() {\n    var {\n      onSubmit: onSubmit,\n      useSubmitBehavior: useSubmitBehavior\n    } = this.props;\n\n    if (useSubmitBehavior && onSubmit) {\n      click.on(this.submitInputRef.current, event => onSubmit({\n        event: event,\n        submitInput: this.submitInputRef.current\n      }), {\n        namespace: \"UIFeedback\"\n      });\n      return () => click.off(this.submitInputRef.current, {\n        namespace: \"UIFeedback\"\n      });\n    }\n\n    return;\n  }\n\n  onActive(event) {\n    var {\n      useInkRipple: useInkRipple\n    } = this.props;\n    useInkRipple && this.inkRippleRef.current.showWave({\n      element: this.contentRef.current,\n      event: event\n    });\n  }\n\n  onInactive(event) {\n    var {\n      useInkRipple: useInkRipple\n    } = this.props;\n    useInkRipple && this.inkRippleRef.current.hideWave({\n      element: this.contentRef.current,\n      event: event\n    });\n  }\n\n  onWidgetClick(event) {\n    var {\n      onClick: onClick,\n      useSubmitBehavior: useSubmitBehavior\n    } = this.props;\n    null === onClick || void 0 === onClick ? void 0 : onClick({\n      event: event\n    });\n    useSubmitBehavior && this.submitInputRef.current.click();\n  }\n\n  keyDown(e) {\n    var {\n      onKeyDown: onKeyDown\n    } = this.props;\n    var {\n      keyName: keyName,\n      originalEvent: originalEvent,\n      which: which\n    } = e;\n    var result = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);\n\n    if (null !== result && void 0 !== result && result.cancel) {\n      return result;\n    }\n\n    if (\"space\" === keyName || \"space\" === which || \"enter\" === keyName || \"enter\" === which) {\n      originalEvent.preventDefault();\n      this.onWidgetClick(originalEvent);\n    }\n\n    return;\n  }\n\n  get aria() {\n    var {\n      icon: icon,\n      text: text\n    } = this.props;\n    var label = (null !== text && void 0 !== text ? text : \"\") || icon;\n\n    if (!text && icon && \"image\" === getImageSourceType(icon)) {\n      label = !icon.includes(\"base64\") ? icon.replace(/.+\\/([^.]+)\\..+$/, \"$1\") : \"Base64\";\n    }\n\n    return _extends({\n      role: \"button\"\n    }, label ? {\n      label: label\n    } : {});\n  }\n\n  get cssClasses() {\n    return getCssClasses(this.props);\n  }\n\n  get iconSource() {\n    var {\n      icon: icon,\n      type: type\n    } = this.props;\n\n    if (icon || \"back\" === type) {\n      return (null !== icon && void 0 !== icon ? icon : \"\") || \"back\";\n    }\n\n    return \"\";\n  }\n\n  get inkRippleConfig() {\n    if (void 0 !== this.__getterCache.inkRippleConfig) {\n      return this.__getterCache.inkRippleConfig;\n    }\n\n    return this.__getterCache.inkRippleConfig = (() => {\n      var {\n        icon: icon,\n        text: text,\n        type: type\n      } = this.props;\n      return !text && icon || \"back\" === type ? {\n        isCentered: true,\n        useHoldAnimation: false,\n        waveSizeCoefficient: 1\n      } : {};\n    })();\n  }\n\n  get buttonTemplateData() {\n    var {\n      icon: icon,\n      templateData: templateData,\n      text: text\n    } = this.props;\n    return _extends({\n      icon: icon,\n      text: text\n    }, templateData);\n  }\n\n  get restAttributes() {\n    var _this$props = this.props,\n        restProps = _objectWithoutPropertiesLoose(_this$props, _excluded);\n\n    return restProps;\n  }\n\n  focus() {\n    this.widgetRef.current.focus();\n  }\n\n  activate() {\n    this.widgetRef.current.activate();\n  }\n\n  deactivate() {\n    this.widgetRef.current.deactivate();\n  }\n\n  componentWillUpdate(nextProps, nextState, context) {\n    super.componentWillUpdate();\n\n    if (this.props.icon !== nextProps.icon || this.props.text !== nextProps.text || this.props.type !== nextProps.type) {\n      this.__getterCache.inkRippleConfig = void 0;\n    }\n  }\n\n  render() {\n    var props = this.props;\n    return viewFunction({\n      props: _extends({}, props, {\n        template: getTemplate(props.template),\n        iconTemplate: getTemplate(props.iconTemplate)\n      }),\n      contentRef: this.contentRef,\n      submitInputRef: this.submitInputRef,\n      inkRippleRef: this.inkRippleRef,\n      widgetRef: this.widgetRef,\n      onActive: this.onActive,\n      onInactive: this.onInactive,\n      onWidgetClick: this.onWidgetClick,\n      keyDown: this.keyDown,\n      aria: this.aria,\n      cssClasses: this.cssClasses,\n      iconSource: this.iconSource,\n      inkRippleConfig: this.inkRippleConfig,\n      buttonTemplateData: this.buttonTemplateData,\n      restAttributes: this.restAttributes\n    });\n  }\n\n}\nButton.defaultProps = Object.create(Object.prototype, _extends(Object.getOwnPropertyDescriptors(ButtonProps), Object.getOwnPropertyDescriptors(_extends({}, convertRulesToOptions(defaultOptionRules)))));\nvar __defaultOptionRules = [];\nexport function defaultOptions(rule) {\n  __defaultOptionRules.push(rule);\n\n  Button.defaultProps = Object.create(Object.prototype, _extends(Object.getOwnPropertyDescriptors(Button.defaultProps), Object.getOwnPropertyDescriptors(convertRulesToOptions(defaultOptionRules)), Object.getOwnPropertyDescriptors(convertRulesToOptions(__defaultOptionRules))));\n}","map":null,"metadata":{},"sourceType":"module"}