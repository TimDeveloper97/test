{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/drawer/ui.drawer.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { isFunction, isDefined } from \"../../core/utils/type\";\nimport { getPublicElement } from \"../../core/element\";\nimport registerComponent from \"../../core/component_registrator\";\nimport { extend } from \"../../core/utils/extend\";\nimport { getBoundingRect } from \"../../core/utils/position\";\nimport Widget from \"../widget/ui.widget\";\nimport { EmptyTemplate } from \"../../core/templates/empty_template\";\nimport { hasWindow } from \"../../core/utils/window\";\nimport PushStrategy from \"./ui.drawer.rendering.strategy.push\";\nimport ShrinkStrategy from \"./ui.drawer.rendering.strategy.shrink\";\nimport OverlapStrategy from \"./ui.drawer.rendering.strategy.overlap\";\nimport { animation } from \"./ui.drawer.animation\";\nimport { name as CLICK_EVENT_NAME } from \"../../events/click\";\nimport fx from \"../../animation/fx\";\nimport { Deferred } from \"../../core/utils/deferred\";\nimport { triggerResizeEvent } from \"../../events/visibility_change\";\nvar DRAWER_CLASS = \"dx-drawer\";\nvar DRAWER_WRAPPER_CLASS = \"dx-drawer-wrapper\";\nvar DRAWER_PANEL_CONTENT_CLASS = \"dx-drawer-panel-content\";\nvar DRAWER_VIEW_CONTENT_CLASS = \"dx-drawer-content\";\nvar DRAWER_SHADER_CLASS = \"dx-drawer-shader\";\nvar INVISIBLE_STATE_CLASS = \"dx-state-invisible\";\nvar OPENED_STATE_CLASS = \"dx-drawer-opened\";\nvar ANONYMOUS_TEMPLATE_NAME = \"content\";\nvar PANEL_TEMPLATE_NAME = \"panel\";\nvar Drawer = Widget.inherit({\n  _getDefaultOptions() {\n    return extend(this.callBase(), {\n      position: \"left\",\n      opened: false,\n      minSize: null,\n      maxSize: null,\n      shading: false,\n      template: PANEL_TEMPLATE_NAME,\n      openedStateMode: \"shrink\",\n      revealMode: \"slide\",\n      animationEnabled: true,\n      animationDuration: 400,\n      closeOnOutsideClick: false,\n      contentTemplate: ANONYMOUS_TEMPLATE_NAME,\n      target: void 0\n    });\n  },\n\n  _setDeprecatedOptions() {\n    this.callBase();\n    extend(this._deprecatedOptions, {\n      target: {\n        since: \"20.1\",\n        message: \"Functionality associated with this option is not intended for the Drawer widget.\"\n      }\n    });\n  },\n\n  _init() {\n    this.callBase();\n\n    this._initStrategy();\n\n    this.$element().addClass(DRAWER_CLASS);\n    this._whenAnimationCompleted = void 0;\n    this._whenPanelContentRendered = void 0;\n    this._whenPanelContentRefreshed = void 0;\n    this._$wrapper = $(\"<div>\").addClass(DRAWER_WRAPPER_CLASS);\n    this._$viewContentWrapper = $(\"<div>\").addClass(DRAWER_VIEW_CONTENT_CLASS);\n\n    this._$wrapper.append(this._$viewContentWrapper);\n\n    this.$element().append(this._$wrapper);\n  },\n\n  _initStrategy() {\n    switch (this.option(\"openedStateMode\")) {\n      case \"push\":\n        this._strategy = new PushStrategy(this);\n        break;\n\n      case \"shrink\":\n        this._strategy = new ShrinkStrategy(this);\n        break;\n\n      case \"overlap\":\n        this._strategy = new OverlapStrategy(this);\n        break;\n\n      default:\n        this._strategy = new PushStrategy(this);\n    }\n  },\n\n  _getAnonymousTemplateName: function () {\n    return ANONYMOUS_TEMPLATE_NAME;\n  },\n\n  _initTemplates() {\n    var defaultTemplates = {};\n    defaultTemplates[PANEL_TEMPLATE_NAME] = new EmptyTemplate();\n    defaultTemplates[ANONYMOUS_TEMPLATE_NAME] = new EmptyTemplate();\n\n    this._templateManager.addDefaultTemplates(defaultTemplates);\n\n    this.callBase();\n  },\n\n  _viewContentWrapperClickHandler(e) {\n    var closeOnOutsideClick = this.option(\"closeOnOutsideClick\");\n\n    if (isFunction(closeOnOutsideClick)) {\n      closeOnOutsideClick = closeOnOutsideClick(e);\n    }\n\n    if (closeOnOutsideClick && this.option(\"opened\")) {\n      this.stopAnimations();\n\n      if (this.option(\"shading\")) {\n        e.preventDefault();\n      }\n\n      this.hide();\n    }\n  },\n\n  _initMarkup() {\n    this.callBase();\n\n    this._toggleOpenedStateClass(this.option(\"opened\"));\n\n    this._renderPanelContentWrapper();\n\n    this._refreshOpenedStateModeClass();\n\n    this._refreshRevealModeClass();\n\n    this._renderShader();\n\n    this._refreshPositionClass();\n\n    this._whenPanelContentRendered = new Deferred();\n\n    this._strategy.renderPanelContent(this._whenPanelContentRendered);\n\n    this._strategy.onPanelContentRendered();\n\n    this._renderViewContent();\n\n    eventsEngine.off(this._$viewContentWrapper, CLICK_EVENT_NAME);\n    eventsEngine.on(this._$viewContentWrapper, CLICK_EVENT_NAME, this._viewContentWrapperClickHandler.bind(this));\n\n    this._refreshWrapperChildrenOrder();\n  },\n\n  _render() {\n    this._initMinMaxSize();\n\n    this.callBase();\n\n    this._whenPanelContentRendered.always(() => {\n      this._initMinMaxSize();\n\n      this._strategy.refreshPanelElementSize(\"slide\" === this.option(\"revealMode\") || !this.isHorizontalDirection());\n\n      this._renderPosition(this.option(\"opened\"), true);\n\n      this._removePanelManualPosition();\n    });\n  },\n\n  _removePanelManualPosition() {\n    if (this._$panelContentWrapper.attr(\"manualposition\")) {\n      this._$panelContentWrapper.removeAttr(\"manualPosition\");\n\n      this._$panelContentWrapper.css({\n        position: \"\",\n        top: \"\",\n        left: \"\",\n        right: \"\",\n        bottom: \"\"\n      });\n    }\n  },\n\n  _renderPanelContentWrapper() {\n    this._$panelContentWrapper = $(\"<div>\").addClass(DRAWER_PANEL_CONTENT_CLASS);\n    var position = this.calcTargetPosition();\n\n    if (\"push\" === this.option(\"openedStateMode\") && [\"top\", \"bottom\"].indexOf(position) > -1) {\n      this._$panelContentWrapper.addClass(DRAWER_PANEL_CONTENT_CLASS + \"-push-top-or-bottom\");\n    }\n\n    if (\"overlap\" !== this.option(\"openedStateMode\") && !this.option(\"opened\") && !this.option(\"minSize\")) {\n      this._$panelContentWrapper.attr(\"manualposition\", true);\n\n      this._$panelContentWrapper.css({\n        position: \"absolute\",\n        top: \"-10000px\",\n        left: \"-10000px\",\n        right: \"auto\",\n        bottom: \"auto\"\n      });\n    }\n\n    this._$wrapper.append(this._$panelContentWrapper);\n  },\n\n  _refreshOpenedStateModeClass(prevOpenedStateMode) {\n    if (prevOpenedStateMode) {\n      this.$element().removeClass(DRAWER_CLASS + \"-\" + prevOpenedStateMode);\n    }\n\n    this.$element().addClass(DRAWER_CLASS + \"-\" + this.option(\"openedStateMode\"));\n  },\n\n  _refreshPositionClass(prevPosition) {\n    if (prevPosition) {\n      this.$element().removeClass(DRAWER_CLASS + \"-\" + prevPosition);\n    }\n\n    this.$element().addClass(DRAWER_CLASS + \"-\" + this.calcTargetPosition());\n  },\n\n  _refreshWrapperChildrenOrder() {\n    var position = this.calcTargetPosition();\n\n    if (this._strategy.isViewContentFirst(position, this.option(\"rtlEnabled\"))) {\n      this._$wrapper.prepend(this._$viewContentWrapper);\n    } else {\n      this._$wrapper.prepend(this._$panelContentWrapper);\n    }\n  },\n\n  _refreshRevealModeClass(prevRevealMode) {\n    if (prevRevealMode) {\n      this.$element().removeClass(DRAWER_CLASS + \"-\" + prevRevealMode);\n    }\n\n    this.$element().addClass(DRAWER_CLASS + \"-\" + this.option(\"revealMode\"));\n  },\n\n  _renderViewContent() {\n    var contentTemplateOption = this.option(\"contentTemplate\");\n\n    var contentTemplate = this._getTemplate(contentTemplateOption);\n\n    if (contentTemplate) {\n      var $viewTemplate = contentTemplate.render({\n        container: this.viewContent(),\n        noModel: true,\n        transclude: this._templateManager.anonymousTemplateName === contentTemplateOption\n      });\n\n      if ($viewTemplate.hasClass(\"ng-scope\")) {\n        $(this._$viewContentWrapper).children().not(\".\".concat(DRAWER_SHADER_CLASS)).replaceWith($viewTemplate);\n      }\n    }\n  },\n\n  _renderShader() {\n    this._$shader = this._$shader || $(\"<div>\").addClass(DRAWER_SHADER_CLASS);\n\n    this._$shader.appendTo(this.viewContent());\n\n    this._toggleShaderVisibility(this.option(\"opened\"));\n  },\n\n  _initSize() {\n    this._initMinMaxSize();\n  },\n\n  _initMinMaxSize() {\n    var realPanelSize = this.isHorizontalDirection() ? this.getRealPanelWidth() : this.getRealPanelHeight();\n    this._maxSize = this.option(\"maxSize\") || realPanelSize;\n    this._minSize = this.option(\"minSize\") || 0;\n  },\n\n  calcTargetPosition() {\n    var position = this.option(\"position\");\n    var rtl = this.option(\"rtlEnabled\");\n    var result = position;\n\n    if (\"before\" === position) {\n      result = rtl ? \"right\" : \"left\";\n    } else if (\"after\" === position) {\n      result = rtl ? \"left\" : \"right\";\n    }\n\n    return result;\n  },\n\n  getOverlayTarget() {\n    return this._options.silent(\"target\") || this._$wrapper;\n  },\n\n  getOverlay() {\n    return this._overlay;\n  },\n\n  getMaxSize() {\n    return this._maxSize;\n  },\n\n  getMinSize() {\n    return this._minSize;\n  },\n\n  getRealPanelWidth() {\n    if (hasWindow()) {\n      if (isDefined(this.option(\"templateSize\"))) {\n        return this.option(\"templateSize\");\n      } else {\n        return getBoundingRect(this._getPanelTemplateElement()).width;\n      }\n    } else {\n      return 0;\n    }\n  },\n\n  getRealPanelHeight() {\n    if (hasWindow()) {\n      if (isDefined(this.option(\"templateSize\"))) {\n        return this.option(\"templateSize\");\n      } else {\n        return getBoundingRect(this._getPanelTemplateElement()).height;\n      }\n    } else {\n      return 0;\n    }\n  },\n\n  _getPanelTemplateElement() {\n    var $panelContent = this._strategy.getPanelContent();\n\n    var $result = $panelContent;\n\n    if ($panelContent.children().length) {\n      $result = $panelContent.children().eq(0);\n\n      if ($panelContent.hasClass(\"dx-overlay-content\") && $result.hasClass(\"dx-template-wrapper\") && $result.children().length) {\n        $result = $result.children().eq(0);\n      }\n    }\n\n    return $result.get(0);\n  },\n\n  getElementHeight($element) {\n    var $children = $element.children();\n    return $children.length ? getBoundingRect($children.eq(0).get(0)).height : getBoundingRect($element.get(0)).height;\n  },\n\n  isHorizontalDirection() {\n    var position = this.calcTargetPosition();\n    return \"left\" === position || \"right\" === position;\n  },\n\n  stopAnimations(jumpToEnd) {\n    fx.stop(this._$shader, jumpToEnd);\n    fx.stop($(this.content()), jumpToEnd);\n    fx.stop($(this.viewContent()), jumpToEnd);\n    var overlay = this.getOverlay();\n\n    if (overlay) {\n      fx.stop($(overlay.$content()), jumpToEnd);\n    }\n  },\n\n  setZIndex(zIndex) {\n    this._$shader.css(\"zIndex\", zIndex - 1);\n\n    this._$panelContentWrapper.css(\"zIndex\", zIndex);\n  },\n\n  resizeContent() {\n    this.resizeViewContent;\n  },\n\n  resizeViewContent() {\n    triggerResizeEvent(this.viewContent());\n  },\n\n  _isInvertedPosition() {\n    var position = this.calcTargetPosition();\n    return \"right\" === position || \"bottom\" === position;\n  },\n\n  _renderPosition(isDrawerOpened, disableAnimation, jumpToEnd) {\n    this.stopAnimations(jumpToEnd);\n\n    if (!hasWindow()) {\n      return;\n    }\n\n    $(this.viewContent()).css(\"paddingLeft\", 0);\n    $(this.viewContent()).css(\"paddingRight\", 0);\n    $(this.viewContent()).css(\"paddingTop\", 0);\n    $(this.viewContent()).css(\"paddingBottom\", 0);\n    var animationEnabled = this.option(\"animationEnabled\");\n\n    if (true === disableAnimation) {\n      animationEnabled = false;\n    }\n\n    if (isDrawerOpened) {\n      this._toggleShaderVisibility(isDrawerOpened);\n    }\n\n    this._strategy.renderPosition(animationEnabled, this.option(\"animationDuration\"));\n  },\n\n  _animationCompleteHandler() {\n    this.resizeViewContent();\n\n    if (this._whenAnimationCompleted) {\n      this._whenAnimationCompleted.resolve();\n    }\n  },\n\n  _getPositionCorrection() {\n    return this._isInvertedPosition() ? -1 : 1;\n  },\n\n  _dispose() {\n    animation.complete($(this.viewContent()));\n    this.callBase();\n  },\n\n  _visibilityChanged(visible) {\n    if (visible) {\n      this._dimensionChanged();\n    }\n  },\n\n  _dimensionChanged() {\n    this._initMinMaxSize();\n\n    this._strategy.refreshPanelElementSize(\"slide\" === this.option(\"revealMode\"));\n\n    this._renderPosition(this.option(\"opened\"), true);\n  },\n\n  _toggleShaderVisibility(visible) {\n    if (this.option(\"shading\")) {\n      this._$shader.toggleClass(INVISIBLE_STATE_CLASS, !visible);\n\n      this._$shader.css(\"visibility\", visible ? \"visible\" : \"hidden\");\n    } else {\n      this._$shader.toggleClass(INVISIBLE_STATE_CLASS, true);\n    }\n  },\n\n  _toggleOpenedStateClass(opened) {\n    this.$element().toggleClass(OPENED_STATE_CLASS, opened);\n  },\n\n  _refreshPanel() {\n    $(this.viewContent()).css(\"left\", 0);\n    $(this.viewContent()).css(\"transform\", \"translate(0px, 0px)\");\n    $(this.viewContent()).removeClass(\"dx-theme-background-color\");\n\n    this._removePanelContentWrapper();\n\n    this._removeOverlay();\n\n    this._renderPanelContentWrapper();\n\n    this._refreshWrapperChildrenOrder();\n\n    this._whenPanelContentRefreshed = new Deferred();\n\n    this._strategy.renderPanelContent(this._whenPanelContentRefreshed);\n\n    this._strategy.onPanelContentRendered();\n\n    if (hasWindow()) {\n      this._whenPanelContentRefreshed.always(() => {\n        this._strategy.refreshPanelElementSize(\"slide\" === this.option(\"revealMode\"));\n\n        this._renderPosition(this.option(\"opened\"), true, true);\n\n        this._removePanelManualPosition();\n      });\n    }\n  },\n\n  _clean() {\n    this._cleanFocusState();\n\n    this._removePanelContentWrapper();\n\n    this._removeOverlay();\n  },\n\n  _removePanelContentWrapper() {\n    if (this._$panelContentWrapper) {\n      this._$panelContentWrapper.remove();\n    }\n  },\n\n  _removeOverlay() {\n    if (this._overlay) {\n      this._overlay.dispose();\n\n      delete this._overlay;\n      delete this._$panelContentWrapper;\n    }\n  },\n\n  _optionChanged(args) {\n    switch (args.name) {\n      case \"width\":\n        this.callBase(args);\n\n        this._dimensionChanged();\n\n        break;\n\n      case \"opened\":\n        this._renderPosition(this.option(\"opened\"));\n\n        this._toggleOpenedStateClass(args.value);\n\n        break;\n\n      case \"position\":\n        this._refreshPositionClass(args.previousValue);\n\n        this._refreshWrapperChildrenOrder();\n\n        this._invalidate();\n\n        break;\n\n      case \"contentTemplate\":\n      case \"template\":\n        this._invalidate();\n\n        break;\n\n      case \"openedStateMode\":\n      case \"target\":\n        this._initStrategy();\n\n        this._refreshOpenedStateModeClass(args.previousValue);\n\n        this._refreshPanel();\n\n        break;\n\n      case \"minSize\":\n      case \"maxSize\":\n        this._initMinMaxSize();\n\n        this._renderPosition(this.option(\"opened\"), true);\n\n        break;\n\n      case \"revealMode\":\n        this._refreshRevealModeClass(args.previousValue);\n\n        this._refreshPanel();\n\n        break;\n\n      case \"shading\":\n        this._toggleShaderVisibility(this.option(\"opened\"));\n\n        break;\n\n      case \"animationEnabled\":\n      case \"animationDuration\":\n      case \"closeOnOutsideClick\":\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n\n  content() {\n    return getPublicElement(this._$panelContentWrapper);\n  },\n\n  viewContent() {\n    return getPublicElement(this._$viewContentWrapper);\n  },\n\n  show() {\n    return this.toggle(true);\n  },\n\n  hide() {\n    return this.toggle(false);\n  },\n\n  toggle(opened) {\n    var targetOpened = void 0 === opened ? !this.option(\"opened\") : opened;\n    this._whenAnimationCompleted = new Deferred();\n    this.option(\"opened\", targetOpened);\n    return this._whenAnimationCompleted.promise();\n  }\n\n});\nregisterComponent(\"dxDrawer\", Drawer);\nexport default Drawer;","map":null,"metadata":{},"sourceType":"module"}