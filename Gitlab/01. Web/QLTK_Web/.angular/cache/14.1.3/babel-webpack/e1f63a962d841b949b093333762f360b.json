{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/grouped_data_map_provider.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../../../core/utils/date\";\nimport { isDateAndTimeView } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nexport class GroupedDataMapProvider {\n  constructor(viewDataGenerator, viewDataMap, completeViewDataMap, viewOptions) {\n    this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\n    this.completeViewDataMap = completeViewDataMap;\n    this._viewOptions = viewOptions;\n  }\n\n  getGroupStartDate(groupIndex) {\n    var firstRow = this.getFirstGroupRow(groupIndex);\n\n    if (firstRow) {\n      var {\n        startDate: startDate\n      } = firstRow[0].cellData;\n      return startDate;\n    }\n  }\n\n  getGroupEndDate(groupIndex) {\n    var lastRow = this.getLastGroupRow(groupIndex);\n\n    if (lastRow) {\n      var lastColumnIndex = lastRow.length - 1;\n      var {\n        cellData: cellData\n      } = lastRow[lastColumnIndex];\n      var {\n        endDate: endDate\n      } = cellData;\n      return endDate;\n    }\n  }\n\n  findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay, isFindByDate) {\n    if (isAllDay) {\n      return this.findAllDayGroupCellStartDate(groupIndex, startDate);\n    }\n\n    var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n    var checkCellStartDate = (rowIndex, columnIndex) => {\n      var {\n        cellData: cellData\n      } = groupData[rowIndex][columnIndex];\n      var {\n        startDate: secondMin,\n        endDate: secondMax\n      } = cellData;\n\n      if (isFindByDate) {\n        secondMin = dateUtils.trimTime(secondMin);\n        secondMax = dateUtils.setToDayEnd(secondMin);\n      }\n\n      if (dateUtils.intervalsOverlap({\n        firstMin: startDate,\n        firstMax: endDate,\n        secondMin: secondMin,\n        secondMax: secondMax\n      })) {\n        return secondMin;\n      }\n    };\n\n    var startDateVerticalSearch = (() => {\n      var cellCount = groupData[0].length;\n\n      for (var columnIndex = 0; columnIndex < cellCount; ++columnIndex) {\n        for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n          var result = checkCellStartDate(rowIndex, columnIndex);\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    })();\n\n    var startDateHorizontalSearch = (() => {\n      for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n        var row = groupData[rowIndex];\n\n        for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n          var result = checkCellStartDate(rowIndex, columnIndex);\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    })();\n\n    return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch;\n  }\n\n  findAllDayGroupCellStartDate(groupIndex, startDate) {\n    var groupStartDate = this.getGroupStartDate(groupIndex);\n    return groupStartDate > startDate ? groupStartDate : startDate;\n  }\n\n  findCellPositionInMap(cellInfo) {\n    var {\n      groupIndex: groupIndex,\n      startDate: startDate,\n      isAllDay: isAllDay,\n      index: index\n    } = cellInfo;\n    var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\n\n    var isStartDateInCell = cellData => {\n      if (!isDateAndTimeView(this._viewOptions.viewType)) {\n        return dateUtils.sameDate(startDate, cellData.startDate);\n      }\n\n      var cellStartTime = cellData.startDate.getTime();\n      var cellEndTime = cellData.endDate.getTime();\n      return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime;\n    };\n\n    var {\n      allDayPanelGroupedMap: allDayPanelGroupedMap,\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var rows = isAllDay && !this._viewOptions.isVerticalGrouping ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];\n\n    for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\n      var row = rows[rowIndex];\n\n      for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n        var cell = row[columnIndex];\n        var {\n          cellData: cellData\n        } = cell;\n\n        if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\n          if (isStartDateInCell(cellData)) {\n            return cell.position;\n          }\n        }\n      }\n    }\n\n    return;\n  }\n\n  _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\n    return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index);\n  }\n\n  getCellsGroup(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var groupData = dateTableGroupedMap[groupIndex];\n\n    if (groupData) {\n      var {\n        cellData: cellData\n      } = groupData[0][0];\n      return cellData.groups;\n    }\n  }\n\n  getCompletedGroupsInfo() {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap.map(groupData => {\n      var firstCell = groupData[0][0];\n      var {\n        allDay: allDay,\n        groupIndex: groupIndex\n      } = firstCell.cellData;\n      return {\n        allDay: allDay,\n        groupIndex: groupIndex,\n        startDate: this.getGroupStartDate(groupIndex),\n        endDate: this.getGroupEndDate(groupIndex)\n      };\n    }).filter(_ref => {\n      var {\n        startDate: startDate\n      } = _ref;\n      return !!startDate;\n    });\n  }\n\n  getGroupIndices() {\n    return this.getCompletedGroupsInfo().map(_ref2 => {\n      var {\n        groupIndex: groupIndex\n      } = _ref2;\n      return groupIndex;\n    });\n  }\n\n  getGroupFromDateTableGroupMap(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap[groupIndex];\n  }\n\n  getFirstGroupRow(groupIndex) {\n    var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n    if (groupedData) {\n      var {\n        cellData: cellData\n      } = groupedData[0][0];\n      return !cellData.allDay ? groupedData[0] : groupedData[1];\n    }\n  }\n\n  getLastGroupRow(groupIndex) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    var groupedData = dateTableGroupedMap[groupIndex];\n\n    if (groupedData) {\n      var lastRowIndex = groupedData.length - 1;\n      return groupedData[lastRowIndex];\n    }\n  }\n\n  getLastGroupCellPosition(groupIndex) {\n    var groupRow = this.getLastGroupRow(groupIndex);\n    return null === groupRow || void 0 === groupRow ? void 0 : groupRow[(null === groupRow || void 0 === groupRow ? void 0 : groupRow.length) - 1].position;\n  }\n\n  getRowCountInGroup(groupIndex) {\n    var groupRow = this.getLastGroupRow(groupIndex);\n    var cellAmount = groupRow.length;\n    var lastCellData = groupRow[cellAmount - 1].cellData;\n    var lastCellIndex = lastCellData.index;\n    return (lastCellIndex + 1) / groupRow.length;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}