{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_generator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport { HORIZONTAL_GROUP_ORIENTATION } from \"../../constants\";\nimport { getAllGroups, getGroupCount } from \"../../resources/utils\";\nimport { calculateCellIndex, calculateDayDuration, isHorizontalView, getStartViewDateWithoutDST, getDisplayedRowCount, getTotalCellCountByCompleteData, getTotalRowCountByCompleteData, getDisplayedCellCount } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { getIsGroupedAllDayPanel, getKeyByGroup } from \"../../../../renovation/ui/scheduler/workspaces/utils\";\nvar HOUR_MS = dateUtils.dateToMilliseconds(\"hour\");\nvar DAY_MS = dateUtils.dateToMilliseconds(\"day\");\nexport class ViewDataGenerator {\n  get daysInInterval() {\n    return 1;\n  }\n\n  get isWorkView() {\n    return false;\n  }\n\n  get tableAllDay() {\n    return false;\n  }\n\n  isSkippedDate() {\n    return false;\n  }\n\n  getStartViewDate(options) {\n    return this._calculateStartViewDate(options);\n  }\n\n  getCompleteViewDataMap(options) {\n    var {\n      groups: groups,\n      isGroupedByDate: isGroupedByDate,\n      isHorizontalGrouping: isHorizontalGrouping,\n      isVerticalGrouping: isVerticalGrouping,\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n\n    this._setVisibilityDates(options);\n\n    this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);\n    var groupsList = getAllGroups(groups);\n    var cellCountInGroupRow = this.getCellCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    });\n    var rowCountInGroup = this.getRowCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      hoursInterval: hoursInterval,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour\n    });\n    var viewDataMap = [];\n\n    var allDayPanelData = this._generateAllDayPanelData(options, rowCountInGroup, cellCountInGroupRow);\n\n    var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, cellCountInGroupRow);\n\n    allDayPanelData && viewDataMap.push(allDayPanelData);\n    viewDataMap.push(...viewCellsData);\n\n    if (isHorizontalGrouping && !isGroupedByDate) {\n      viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);\n    }\n\n    if (isVerticalGrouping) {\n      viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);\n    }\n\n    if (isGroupedByDate) {\n      viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);\n    }\n\n    var completeViewDataMap = this._addKeysToCells(viewDataMap);\n\n    return completeViewDataMap;\n  }\n\n  _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      viewDataMap.forEach((row, rowIndex) => {\n        var nextGroupRow = row.map(cellData => _extends({}, cellData, {\n          groups: groups,\n          groupIndex: groupIndex\n        }));\n        result[rowIndex].push(...nextGroupRow);\n      });\n    });\n    return result;\n  }\n\n  _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\n    var result = viewDataMap.map(row => row.slice());\n    groupsList.slice(1).forEach((groups, index) => {\n      var groupIndex = index + 1;\n      var nextGroupMap = viewDataMap.map(cellsRow => {\n        var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\n          groupIndex: groupIndex,\n          groups: groups\n        }));\n        return nextRow;\n      });\n      result.push(...nextGroupMap);\n    });\n    return result;\n  }\n\n  _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\n    var correctedGroupList = groupsList.slice(1);\n    var correctedGroupCount = correctedGroupList.length;\n    var result = viewDataMap.map(cellsRow => {\n      var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\n        var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\n          isFirstGroupCell: true,\n          isLastGroupCell: 0 === correctedGroupCount\n        }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\n          groups: groups,\n          groupIndex: index + 1,\n          isFirstGroupCell: false,\n          isLastGroupCell: index === correctedGroupCount - 1\n        }))];\n        return rowWithCurrentCell;\n      }, []);\n      return groupedByDateCellsRow;\n    });\n    return result;\n  }\n\n  _addKeysToCells(viewDataMap) {\n    var totalColumnCount = viewDataMap[0].length;\n    var {\n      currentViewDataMap: result\n    } = viewDataMap.reduce((_ref, row, rowIndex) => {\n      var {\n        allDayPanelsCount: allDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      } = _ref;\n      var isAllDay = row[0].allDay;\n      var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\n      var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\n      currentViewDataMap[rowIndex].forEach((cell, columnIndex) => {\n        cell.key = keyBase + columnIndex;\n      });\n      return {\n        allDayPanelsCount: currentAllDayPanelsCount,\n        currentViewDataMap: currentViewDataMap\n      };\n    }, {\n      allDayPanelsCount: 0,\n      currentViewDataMap: viewDataMap\n    });\n    return result;\n  }\n\n  generateViewDataMap(completeViewDataMap, options) {\n    var {\n      rowCount: rowCount,\n      startCellIndex: startCellIndex,\n      startRowIndex: startRowIndex,\n      cellCount: cellCount,\n      isVerticalGrouping: isVerticalGrouping,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = options;\n\n    var sliceCells = (row, rowIndex, startIndex, count) => {\n      var sliceToIndex = void 0 !== count ? startIndex + count : void 0;\n      return row.slice(startIndex, sliceToIndex).map((cellData, columnIndex) => ({\n        cellData: cellData,\n        position: {\n          rowIndex: rowIndex,\n          columnIndex: columnIndex\n        }\n      }));\n    };\n\n    var correctedStartRowIndex = startRowIndex;\n    var allDayPanelMap = [];\n\n    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n      correctedStartRowIndex++;\n      allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);\n    }\n\n    var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n    var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\n    return {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    };\n  }\n\n  _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {\n    return !isVerticalGrouping && isAllDayPanelVisible;\n  }\n\n  getViewDataFromMap(completeViewDataMap, viewDataMap, options) {\n    var {\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: leftVirtualCellWidth,\n      rightVirtualCellWidth: rightVirtualCellWidth,\n      cellCount: cellCount,\n      rowCount: rowCount,\n      startRowIndex: startRowIndex,\n      startCellIndex: startCellIndex,\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      isVerticalGrouping: isVerticalGrouping,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = options;\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      groupedData: groupedData\n    } = dateTableMap.reduce((_ref2, cellsRow) => {\n      var {\n        previousGroupIndex: previousGroupIndex,\n        groupedData: groupedData\n      } = _ref2;\n      var cellDataRow = cellsRow.map(_ref3 => {\n        var {\n          cellData: cellData\n        } = _ref3;\n        return cellData;\n      });\n      var firstCell = cellDataRow[0];\n      var isAllDayRow = firstCell.allDay;\n      var currentGroupIndex = firstCell.groupIndex;\n\n      if (currentGroupIndex !== previousGroupIndex) {\n        groupedData.push({\n          dateTable: [],\n          isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!isAllDayRow, isVerticalGrouping),\n          groupIndex: currentGroupIndex,\n          key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)\n        });\n      }\n\n      if (isAllDayRow) {\n        groupedData[groupedData.length - 1].allDayPanel = cellDataRow;\n      } else {\n        groupedData[groupedData.length - 1].dateTable.push({\n          cells: cellDataRow,\n          key: cellDataRow[0].key - startCellIndex\n        });\n      }\n\n      return {\n        groupedData: groupedData,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupIndex: -1,\n      groupedData: []\n    });\n\n    if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n      groupedData[0].allDayPanel = allDayPanelMap.map(_ref4 => {\n        var {\n          cellData: cellData\n        } = _ref4;\n        return cellData;\n      });\n    }\n\n    var totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);\n    var totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);\n    var displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);\n    var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n    return {\n      groupedData: groupedData,\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\n      rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      leftVirtualCellCount: startCellIndex,\n      rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,\n      topVirtualRowCount: startRowIndex,\n      bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount\n    };\n  }\n\n  _generateViewCellsData(options, rowCount, cellCountInGroupRow) {\n    var viewCellsData = [];\n\n    for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\n      viewCellsData.push(this._generateCellsRow(options, false, rowIndex, rowCount, cellCountInGroupRow));\n    }\n\n    return viewCellsData;\n  }\n\n  _generateAllDayPanelData(options, rowCount, columnCount) {\n    if (!options.isAllDayPanelVisible) {\n      return null;\n    }\n\n    return this._generateCellsRow(options, true, 0, rowCount, columnCount);\n  }\n\n  _generateCellsRow(options, allDay, rowIndex, rowCount, columnCount) {\n    var cellsRow = [];\n\n    for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\n      var cellDataValue = this.getCellData(rowIndex, columnIndex, options, allDay);\n      cellDataValue.index = rowIndex * columnCount + columnIndex;\n      cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n      cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n      cellsRow.push(cellDataValue);\n    }\n\n    return cellsRow;\n  }\n\n  getCellData(rowIndex, columnIndex, options, allDay) {\n    return allDay ? this.prepareAllDayCellData(options, rowIndex, columnIndex) : this.prepareCellData(options, rowIndex, columnIndex);\n  }\n\n  prepareCellData(options, rowIndex, columnIndex) {\n    var {\n      groups: groups,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      interval: interval,\n      hoursInterval: hoursInterval\n    } = options;\n    var groupsList = getAllGroups(groups);\n    var startDate = this.getDateByCellIndices(options, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));\n    var endDate = this.calculateEndDate(startDate, interval, endDayHour);\n    var data = {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: this.tableAllDay,\n      groupIndex: 0\n    };\n\n    if (groupsList.length > 0) {\n      data.groups = groupsList[0];\n    }\n\n    return data;\n  }\n\n  prepareAllDayCellData(options, rowIndex, columnIndex) {\n    var data = this.prepareCellData(options, rowIndex, columnIndex);\n    var startDate = dateUtils.trimTime(data.startDate);\n    return _extends({}, data, {\n      startDate: startDate,\n      endDate: startDate,\n      allDay: true\n    });\n  }\n\n  getDateByCellIndices(options, rowIndex, columnIndex, cellCountInDay) {\n    var startViewDate = options.startViewDate;\n    var {\n      startDayHour: startDayHour,\n      interval: interval,\n      firstDayOfWeek: firstDayOfWeek,\n      intervalCount: intervalCount\n    } = options;\n    var isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);\n\n    if (isStartViewDateDuringDST) {\n      var dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);\n      startViewDate = new Date(dateWithCorrectHours - dateUtils.dateToMilliseconds(\"day\"));\n    }\n\n    var columnCountBase = this.getCellCount(options);\n    var rowCountBase = this.getRowCount(options);\n\n    var cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);\n\n    var millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);\n    var offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;\n    var startViewDateTime = startViewDate.getTime();\n    var currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount);\n    var timeZoneDifference = isStartViewDateDuringDST ? 0 : dateUtils.getTimezonesDifference(startViewDate, currentDate);\n    currentDate.setTime(currentDate.getTime() + timeZoneDifference);\n    return currentDate;\n  }\n\n  getMillisecondsOffset(cellIndex, interval, cellCountInDay) {\n    var dayIndex = Math.floor(cellIndex / cellCountInDay);\n    var realHiddenInterval = dayIndex * this.hiddenInterval;\n    return interval * cellIndex + realHiddenInterval;\n  }\n\n  getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {\n    var firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);\n    var columnsInWeek = columnCount / intervalCount;\n    var weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);\n    return DAY_MS * weekendCount * 2;\n  }\n\n  calculateEndDate(startDate, interval, endDayHour) {\n    var result = new Date(startDate);\n    result.setMilliseconds(result.getMilliseconds() + Math.round(interval));\n    return result;\n  }\n\n  _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {\n    return calculateCellIndex(rowIndex, columnIndex, rowCount);\n  }\n\n  generateGroupedDataMap(viewDataMap) {\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var {\n      previousGroupedDataMap: dateTableGroupedMap\n    } = dateTableMap.reduce((previousOptions, cellsRow) => {\n      var {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: previousRowIndex,\n        previousGroupIndex: previousGroupIndex\n      } = previousOptions;\n      var {\n        groupIndex: currentGroupIndex\n      } = cellsRow[0].cellData;\n      var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\n      cellsRow.forEach(cell => {\n        var {\n          groupIndex: groupIndex\n        } = cell.cellData;\n\n        if (!previousGroupedDataMap[groupIndex]) {\n          previousGroupedDataMap[groupIndex] = [];\n        }\n\n        if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\n          previousGroupedDataMap[groupIndex][currentRowIndex] = [];\n        }\n\n        previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);\n      });\n      return {\n        previousGroupedDataMap: previousGroupedDataMap,\n        previousRowIndex: currentRowIndex,\n        previousGroupIndex: currentGroupIndex\n      };\n    }, {\n      previousGroupedDataMap: [],\n      previousRowIndex: -1,\n      previousGroupIndex: -1\n    });\n    var allDayPanelGroupedMap = [];\n    null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\n      var {\n        groupIndex: groupIndex\n      } = cell.cellData;\n\n      if (!allDayPanelGroupedMap[groupIndex]) {\n        allDayPanelGroupedMap[groupIndex] = [];\n      }\n\n      allDayPanelGroupedMap[groupIndex].push(cell);\n    });\n    return {\n      allDayPanelGroupedMap: allDayPanelGroupedMap,\n      dateTableGroupedMap: dateTableGroupedMap\n    };\n  }\n\n  _isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n    var {\n      groupOrientation: groupOrientation,\n      groups: groups,\n      isGroupedByDate: isGroupedByDate\n    } = options;\n    var groupCount = getGroupCount(groups);\n\n    if (isGroupedByDate) {\n      return columnIndex % groupCount === 0;\n    }\n\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return columnIndex % columnCount === 0;\n    }\n\n    return rowIndex % rowCount === 0;\n  }\n\n  _isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n    var {\n      groupOrientation: groupOrientation,\n      groups: groups,\n      isGroupedByDate: isGroupedByDate\n    } = options;\n    var groupCount = getGroupCount(groups);\n\n    if (isGroupedByDate) {\n      return (columnIndex + 1) % groupCount === 0;\n    }\n\n    if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n      return (columnIndex + 1) % columnCount === 0;\n    }\n\n    return (rowIndex + 1) % rowCount === 0;\n  }\n\n  markSelectedAndFocusedCells(viewDataMap, renderOptions) {\n    var {\n      selectedCells: selectedCells,\n      focusedCell: focusedCell\n    } = renderOptions;\n\n    if (!selectedCells && !focusedCell) {\n      return viewDataMap;\n    }\n\n    var {\n      allDayPanelMap: allDayPanelMap,\n      dateTableMap: dateTableMap\n    } = viewDataMap;\n    var nextDateTableMap = dateTableMap.map(row => this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell));\n\n    var nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);\n\n    return {\n      allDayPanelMap: nextAllDayMap,\n      dateTableMap: nextDateTableMap\n    };\n  }\n\n  _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {\n    return dataRow.map(cell => {\n      var {\n        index: index,\n        groupIndex: groupIndex,\n        allDay: allDay,\n        startDate: startDate\n      } = cell.cellData;\n      var indexInSelectedCells = selectedCells.findIndex(_ref5 => {\n        var {\n          index: selectedCellIndex,\n          groupIndex: selectedCellGroupIndex,\n          allDay: selectedCellAllDay,\n          startDate: selectedCellStartDate\n        } = _ref5;\n        return groupIndex === selectedCellGroupIndex && (index === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay;\n      });\n      var isFocused = !!focusedCell && index === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;\n\n      if (!isFocused && -1 === indexInSelectedCells) {\n        return cell;\n      }\n\n      return _extends({}, cell, {\n        cellData: _extends({}, cell.cellData, {\n          isSelected: indexInSelectedCells > -1,\n          isFocused: isFocused\n        })\n      });\n    });\n  }\n\n  getInterval(hoursInterval) {\n    return hoursInterval * HOUR_MS;\n  }\n\n  _getIntervalDuration(intervalCount) {\n    return dateUtils.dateToMilliseconds(\"day\") * intervalCount;\n  }\n\n  _setVisibilityDates() {}\n\n  getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\n    var result = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;\n    return Math.ceil(result);\n  }\n\n  getCellCount(options) {\n    var {\n      intervalCount: intervalCount,\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    var columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;\n    return this.daysInInterval * intervalCount * columnCountInDay;\n  }\n\n  getRowCount(options) {\n    var {\n      viewType: viewType,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval\n    } = options;\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    var rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;\n    return rowCountInDay;\n  }\n\n  setHiddenInterval(startDayHour, endDayHour, hoursInterval) {\n    this.hiddenInterval = DAY_MS - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);\n  }\n\n  getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\n    var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    return hoursInterval * cellCountInDay * HOUR_MS;\n  }\n\n  getFirstDayOfWeek(firstDayOfWeekOption) {\n    return firstDayOfWeekOption;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}