{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/multi_view.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getWidth } from \"../core/utils/size\";\nimport $ from \"../core/renderer\";\nimport { locate } from \"../animation/translator\";\nimport { _translator, animation } from \"./multi_view/ui.multi_view.animation\";\nimport { sign } from \"../core/utils/math\";\nimport { extend } from \"../core/utils/extend\";\nimport { noop, deferRender } from \"../core/utils/common\";\nimport { triggerResizeEvent } from \"../events/visibility_change\";\nimport { getPublicElement } from \"../core/element\";\nimport { isDefined } from \"../core/utils/type\";\nimport devices from \"../core/devices\";\nimport registerComponent from \"../core/component_registrator\";\nimport CollectionWidget from \"./collection/ui.collection_widget.live_update\";\nimport Swipeable from \"../events/gesture/swipeable\";\nimport { Deferred } from \"../core/utils/deferred\";\nvar MULTIVIEW_CLASS = \"dx-multiview\";\nvar MULTIVIEW_WRAPPER_CLASS = \"dx-multiview-wrapper\";\nvar MULTIVIEW_ITEM_CONTAINER_CLASS = \"dx-multiview-item-container\";\nvar MULTIVIEW_ITEM_CLASS = \"dx-multiview-item\";\nvar MULTIVIEW_ITEM_HIDDEN_CLASS = \"dx-multiview-item-hidden\";\nvar MULTIVIEW_ITEM_DATA_KEY = \"dxMultiViewItemData\";\nvar MULTIVIEW_ANIMATION_DURATION = 200;\n\nvar toNumber = value => +value;\n\nvar position = $element => locate($element).left;\n\nvar MultiView = CollectionWidget.inherit({\n  _activeStateUnit: \".\" + MULTIVIEW_ITEM_CLASS,\n  _supportedKeys: function () {\n    return extend(this.callBase(), {\n      pageUp: noop,\n      pageDown: noop\n    });\n  },\n  _getDefaultOptions: function () {\n    return extend(this.callBase(), {\n      selectedIndex: 0,\n      swipeEnabled: true,\n      animationEnabled: true,\n      loop: false,\n      deferRendering: true,\n      _itemAttributes: {\n        role: \"tabpanel\"\n      },\n      loopItemFocus: false,\n      selectOnFocus: true,\n      selectionMode: \"single\",\n      selectionRequired: true,\n      selectionByClick: false\n    });\n  },\n  _defaultOptionsRules: function () {\n    return this.callBase().concat([{\n      device: function () {\n        return \"desktop\" === devices.real().deviceType && !devices.isSimulator();\n      },\n      options: {\n        focusStateEnabled: true\n      }\n    }]);\n  },\n  _itemClass: function () {\n    return MULTIVIEW_ITEM_CLASS;\n  },\n  _itemDataKey: function () {\n    return MULTIVIEW_ITEM_DATA_KEY;\n  },\n  _itemContainer: function () {\n    return this._$itemContainer;\n  },\n  _itemElements: function () {\n    return this._itemContainer().children(this._itemSelector());\n  },\n  _itemWidth: function () {\n    if (!this._itemWidthValue) {\n      this._itemWidthValue = getWidth(this._$wrapper);\n    }\n\n    return this._itemWidthValue;\n  },\n  _clearItemWidthCache: function () {\n    delete this._itemWidthValue;\n  },\n  _itemsCount: function () {\n    return this.option(\"items\").length;\n  },\n  _normalizeIndex: function (index) {\n    var count = this._itemsCount();\n\n    if (index < 0) {\n      index += count;\n    }\n\n    if (index >= count) {\n      index -= count;\n    }\n\n    return index;\n  },\n  _getRTLSignCorrection: function () {\n    return this.option(\"rtlEnabled\") ? -1 : 1;\n  },\n  _init: function () {\n    this.callBase.apply(this, arguments);\n    var $element = this.$element();\n    $element.addClass(MULTIVIEW_CLASS);\n    this._$wrapper = $(\"<div>\").addClass(MULTIVIEW_WRAPPER_CLASS);\n\n    this._$wrapper.appendTo($element);\n\n    this._$itemContainer = $(\"<div>\").addClass(MULTIVIEW_ITEM_CONTAINER_CLASS);\n\n    this._$itemContainer.appendTo(this._$wrapper);\n\n    this.option(\"loopItemFocus\", this.option(\"loop\"));\n\n    this._initSwipeable();\n  },\n  _initMarkup: function () {\n    this._deferredItems = [];\n    this.callBase();\n\n    var selectedItemIndices = this._getSelectedItemIndices();\n\n    this._updateItemsVisibility(selectedItemIndices[0]);\n  },\n  _afterItemElementDeleted: function ($item, deletedActionArgs) {\n    this.callBase($item, deletedActionArgs);\n\n    if (this._deferredItems) {\n      this._deferredItems.splice(deletedActionArgs.itemIndex, 1);\n    }\n  },\n  _beforeItemElementInserted: function (change) {\n    this.callBase.apply(this, arguments);\n\n    if (this._deferredItems) {\n      this._deferredItems.splice(change.index, 0, null);\n    }\n  },\n  _executeItemRenderAction: function (index, itemData, itemElement) {\n    index = (this.option(\"items\") || []).indexOf(itemData);\n    this.callBase(index, itemData, itemElement);\n  },\n  _renderItemContent: function (args) {\n    var renderContentDeferred = new Deferred();\n    var that = this;\n    var callBase = this.callBase;\n    var deferred = new Deferred();\n    deferred.done(function () {\n      var $itemContent = callBase.call(that, args);\n      renderContentDeferred.resolve($itemContent);\n    });\n    this._deferredItems[args.index] = deferred;\n    this.option(\"deferRendering\") || deferred.resolve();\n    return renderContentDeferred.promise();\n  },\n  _render: function () {\n    this.callBase();\n    deferRender(() => {\n      var selectedItemIndices = this._getSelectedItemIndices();\n\n      this._updateItems(selectedItemIndices[0]);\n    });\n  },\n  _updateItems: function (selectedIndex, newIndex) {\n    this._updateItemsPosition(selectedIndex, newIndex);\n\n    this._updateItemsVisibility(selectedIndex, newIndex);\n  },\n  _modifyByChanges: function () {\n    this.callBase.apply(this, arguments);\n\n    var selectedItemIndices = this._getSelectedItemIndices();\n\n    this._updateItemsVisibility(selectedItemIndices[0]);\n  },\n  _updateItemsPosition: function (selectedIndex, newIndex) {\n    var $itemElements = this._itemElements();\n\n    var positionSign = isDefined(newIndex) ? -this._animationDirection(newIndex, selectedIndex) : void 0;\n    var $selectedItem = $itemElements.eq(selectedIndex);\n\n    _translator.move($selectedItem, 0);\n\n    if (isDefined(newIndex)) {\n      _translator.move($itemElements.eq(newIndex), 100 * positionSign + \"%\");\n    }\n  },\n  _updateItemsVisibility: function (selectedIndex, newIndex) {\n    var $itemElements = this._itemElements();\n\n    $itemElements.each(function (itemIndex, item) {\n      var $item = $(item);\n      var isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;\n\n      if (!isHidden) {\n        this._renderSpecificItem(itemIndex);\n      }\n\n      $item.toggleClass(MULTIVIEW_ITEM_HIDDEN_CLASS, isHidden);\n      this.setAria(\"hidden\", isHidden || void 0, $item);\n    }.bind(this));\n  },\n  _renderSpecificItem: function (index) {\n    var $item = this._itemElements().eq(index);\n\n    var hasItemContent = $item.find(this._itemContentClass()).length > 0;\n\n    if (isDefined(index) && !hasItemContent) {\n      this._deferredItems[index].resolve();\n\n      triggerResizeEvent($item);\n    }\n  },\n  _refreshItem: function ($item, item) {\n    this.callBase($item, item);\n\n    this._updateItemsVisibility(this.option(\"selectedIndex\"));\n  },\n  _setAriaSelected: noop,\n  _updateSelection: function (addedSelection, removedSelection) {\n    var newIndex = addedSelection[0];\n    var prevIndex = removedSelection[0];\n    animation.complete(this._$itemContainer);\n\n    this._updateItems(prevIndex, newIndex);\n\n    var animationDirection = this._animationDirection(newIndex, prevIndex);\n\n    this._animateItemContainer(animationDirection * this._itemWidth(), function () {\n      _translator.move(this._$itemContainer, 0);\n\n      this._updateItems(newIndex);\n\n      getWidth(this._$itemContainer);\n    }.bind(this));\n  },\n  _animateItemContainer: function (position, completeCallback) {\n    var duration = this.option(\"animationEnabled\") ? MULTIVIEW_ANIMATION_DURATION : 0;\n    animation.moveTo(this._$itemContainer, position, duration, completeCallback);\n  },\n  _animationDirection: function (newIndex, prevIndex) {\n    var containerPosition = position(this._$itemContainer);\n\n    var indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection();\n\n    var isSwipePresent = 0 !== containerPosition;\n    var directionSignVariable = isSwipePresent ? containerPosition : indexDifference;\n    return sign(directionSignVariable);\n  },\n\n  _getSwipeDisabledState() {\n    return !this.option(\"swipeEnabled\") || this._itemsCount() <= 1;\n  },\n\n  _initSwipeable() {\n    this._createComponent(this.$element(), Swipeable, {\n      disabled: this._getSwipeDisabledState(),\n      elastic: false,\n      itemSizeFunc: this._itemWidth.bind(this),\n      onStart: args => this._swipeStartHandler(args.event),\n      onUpdated: args => this._swipeUpdateHandler(args.event),\n      onEnd: args => this._swipeEndHandler(args.event)\n    });\n  },\n\n  _swipeStartHandler: function (e) {\n    animation.complete(this._$itemContainer);\n    var selectedIndex = this.option(\"selectedIndex\");\n    var loop = this.option(\"loop\");\n    var lastIndex = this._itemsCount() - 1;\n    var rtl = this.option(\"rtlEnabled\");\n    e.maxLeftOffset = toNumber(loop || (rtl ? selectedIndex > 0 : selectedIndex < lastIndex));\n    e.maxRightOffset = toNumber(loop || (rtl ? selectedIndex < lastIndex : selectedIndex > 0));\n    this._swipeDirection = null;\n  },\n  _swipeUpdateHandler: function (e) {\n    var offset = e.offset;\n\n    var swipeDirection = sign(offset) * this._getRTLSignCorrection();\n\n    _translator.move(this._$itemContainer, offset * this._itemWidth());\n\n    if (swipeDirection !== this._swipeDirection) {\n      this._swipeDirection = swipeDirection;\n      var selectedIndex = this.option(\"selectedIndex\");\n\n      var newIndex = this._normalizeIndex(selectedIndex - swipeDirection);\n\n      this._updateItems(selectedIndex, newIndex);\n    }\n  },\n  _swipeEndHandler: function (e) {\n    var targetOffset = e.targetOffset * this._getRTLSignCorrection();\n\n    if (targetOffset) {\n      this.option(\"selectedIndex\", this._normalizeIndex(this.option(\"selectedIndex\") - targetOffset));\n      var $selectedElement = this.itemElements().filter(\".dx-item-selected\");\n      this.option(\"focusStateEnabled\") && this.option(\"focusedElement\", getPublicElement($selectedElement));\n    } else {\n      this._animateItemContainer(0, noop);\n    }\n  },\n  _getItemFocusLoopSignCorrection: function () {\n    return this._itemFocusLooped ? -1 : 1;\n  },\n  _moveFocus: function () {\n    this.callBase.apply(this, arguments);\n    this._itemFocusLooped = false;\n  },\n  _prevItem: function ($items) {\n    var $result = this.callBase.apply(this, arguments);\n    this._itemFocusLooped = $result.is($items.last());\n    return $result;\n  },\n  _nextItem: function ($items) {\n    var $result = this.callBase.apply(this, arguments);\n    this._itemFocusLooped = $result.is($items.first());\n    return $result;\n  },\n  _dimensionChanged: function () {\n    this._clearItemWidthCache();\n  },\n  _visibilityChanged: function (visible) {\n    if (visible) {\n      this._dimensionChanged();\n    }\n  },\n\n  _updateSwipeDisabledState() {\n    var disabled = this._getSwipeDisabledState();\n\n    Swipeable.getInstance(this.$element()).option(\"disabled\", disabled);\n  },\n\n  _optionChanged: function (args) {\n    var value = args.value;\n\n    switch (args.name) {\n      case \"loop\":\n        this.option(\"loopItemFocus\", value);\n        break;\n\n      case \"animationEnabled\":\n        break;\n\n      case \"swipeEnabled\":\n        this._updateSwipeDisabledState();\n\n        break;\n\n      case \"deferRendering\":\n        this._invalidate();\n\n        break;\n\n      case \"items\":\n        this._updateSwipeDisabledState();\n\n        this.callBase(args);\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  }\n});\nregisterComponent(\"dxMultiView\", MultiView);\nexport default MultiView;","map":null,"metadata":{},"sourceType":"module"}