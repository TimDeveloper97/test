{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/core/annotations.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport domAdapter from \"../../core/dom_adapter\";\nimport { isDefined, isFunction } from \"../../core/utils/type\";\nimport { Tooltip } from \"../core/tooltip\";\nimport { extend } from \"../../core/utils/extend\";\nimport { patchFontOptions } from \"./utils\";\nimport { Plaque } from \"./plaque\";\nimport pointerEvents from \"../../events/pointer\";\nimport { start as dragEventStart, move as dragEventMove, end as dragEventEnd } from \"../../events/drag\";\nimport { addNamespace } from \"../../events/utils/index\";\nimport eventsEngine from \"../../events/core/events_engine\";\nvar getDocument = domAdapter.getDocument;\nvar EVENT_NS = \"annotations\";\nvar DOT_EVENT_NS = \".\" + EVENT_NS;\nvar POINTER_ACTION = addNamespace([pointerEvents.down, pointerEvents.move], EVENT_NS);\nvar POINTER_UP_EVENT_NAME = addNamespace(pointerEvents.up, EVENT_NS);\nvar DRAG_START_EVENT_NAME = dragEventStart + DOT_EVENT_NS;\nvar DRAG_EVENT_NAME = dragEventMove + DOT_EVENT_NS;\nvar DRAG_END_EVENT_NAME = dragEventEnd + DOT_EVENT_NS;\n\nfunction coreAnnotation(options, contentTemplate) {\n  return {\n    draw: function (widget, group) {\n      var annotationGroup = widget._renderer.g().append(group).css(patchFontOptions(options.font));\n\n      if (this.plaque) {\n        this.plaque.clear();\n      }\n\n      this.plaque = new Plaque(extend(true, {}, options, {\n        cornerRadius: (options.border || {}).cornerRadius\n      }), widget, annotationGroup, contentTemplate, widget._isAnnotationBounded(options));\n      this.plaque.draw(widget._getAnnotationCoords(this));\n\n      if (options.allowDragging) {\n        annotationGroup.on(DRAG_START_EVENT_NAME, {\n          immediate: true\n        }, e => {\n          this._dragOffsetX = this.plaque.x - e.pageX;\n          this._dragOffsetY = this.plaque.y - e.pageY;\n        }).on(DRAG_EVENT_NAME, e => {\n          this.plaque.move(e.pageX + this._dragOffsetX, e.pageY + this._dragOffsetY);\n        }).on(DRAG_END_EVENT_NAME, e => {\n          this.offsetX = (this.offsetX || 0) + e.offset.x;\n          this.offsetY = (this.offsetY || 0) + e.offset.y;\n        });\n      }\n    },\n\n    hitTest(x, y) {\n      return this.plaque.hitTest(x, y);\n    },\n\n    showTooltip(tooltip, _ref) {\n      var {\n        x: x,\n        y: y\n      } = _ref;\n      var that = this;\n      var options = that.options;\n\n      if (tooltip.annotation !== that) {\n        tooltip.setTemplate(options.tooltipTemplate);\n\n        var callback = result => {\n          result && (tooltip.annotation = that);\n        };\n\n        callback(tooltip.show(options, {\n          x: x,\n          y: y\n        }, {\n          target: options\n        }, options.customizeTooltip, callback));\n      } else if (!tooltip.isCursorOnTooltip(x, y)) {\n        tooltip.move(x, y);\n      }\n    }\n\n  };\n}\n\nfunction getTemplateFunction(options, widget) {\n  var template;\n\n  if (\"text\" === options.type) {\n    template = function (item, groupElement) {\n      var text = widget._renderer.text(item.text).attr({\n        class: item.cssClass\n      }).append({\n        element: groupElement\n      });\n\n      if (item.width > 0 || item.height > 0) {\n        text.setMaxSize(item.width, item.height, {\n          wordWrap: item.wordWrap,\n          textOverflow: item.textOverflow\n        });\n      }\n    };\n  } else if (\"image\" === options.type) {\n    template = function (item, groupElement) {\n      var {\n        width: width,\n        height: height,\n        url: url,\n        location: location\n      } = item.image || {};\n      var {\n        width: outerWidth,\n        height: outerHeight\n      } = item;\n      var imageWidth = outerWidth > 0 ? Math.min(width, outerWidth) : width;\n      var imageHeight = outerHeight > 0 ? Math.min(height, outerHeight) : height;\n\n      widget._renderer.image(0, 0, imageWidth, imageHeight, url, location || \"center\").append({\n        element: groupElement\n      });\n    };\n  } else if (\"custom\" === options.type) {\n    template = options.template;\n  }\n\n  return template;\n}\n\nfunction getImageObject(image) {\n  return \"string\" === typeof image ? {\n    url: image\n  } : image;\n}\n\nexport var createAnnotations = function (widget, items) {\n  var commonAnnotationSettings = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n  var customizeAnnotation = arguments.length > 3 ? arguments[3] : void 0;\n  var pullOptions = arguments.length > 4 ? arguments[4] : void 0;\n  var commonImageOptions = getImageObject(commonAnnotationSettings.image);\n  return items.reduce((arr, item) => {\n    var currentImageOptions = getImageObject(item.image);\n    var customizedItem = isFunction(customizeAnnotation) ? customizeAnnotation(item) : {};\n\n    if (customizedItem) {\n      customizedItem.image = getImageObject(customizedItem.image);\n    }\n\n    var options = extend(true, {}, commonAnnotationSettings, item, {\n      image: commonImageOptions\n    }, {\n      image: currentImageOptions\n    }, customizedItem);\n    var templateFunction = getTemplateFunction(options, widget);\n    var annotation = templateFunction && extend(true, pullOptions(options), coreAnnotation(options, widget._getTemplate(templateFunction)));\n    annotation && arr.push(annotation);\n    return arr;\n  }, []);\n};\nvar chartPlugin = {\n  name: \"annotations_chart\",\n\n  init() {},\n\n  dispose() {},\n\n  members: {\n    _getAnnotationCoords(annotation) {\n      var _axis, _axis2;\n\n      var coords = {\n        offsetX: annotation.offsetX,\n        offsetY: annotation.offsetY\n      };\n      var argCoordName = this._options.silent(\"rotated\") ? \"y\" : \"x\";\n      var valCoordName = this._options.silent(\"rotated\") ? \"x\" : \"y\";\n      var argAxis = this.getArgumentAxis();\n      var argument = argAxis.validateUnit(annotation.argument);\n      var axis = this.getValueAxis(annotation.axis);\n      var series;\n      var pane = null === (_axis = axis) || void 0 === _axis ? void 0 : _axis.pane;\n\n      if (annotation.series) {\n        var _series;\n\n        series = this.series.filter(s => s.name === annotation.series)[0];\n        axis = null === (_series = series) || void 0 === _series ? void 0 : _series.getValueAxis();\n        isDefined(axis) && (pane = axis.pane);\n      }\n\n      if (isDefined(argument)) {\n        if (series) {\n          var center = series.getPointCenterByArg(argument);\n          center && (coords[argCoordName] = center[argCoordName]);\n        } else {\n          coords[argCoordName] = argAxis.getTranslator().translate(argument);\n        }\n\n        !isDefined(pane) && (pane = argAxis.pane);\n      }\n\n      var value = null === (_axis2 = axis) || void 0 === _axis2 ? void 0 : _axis2.validateUnit(annotation.value);\n\n      if (isDefined(value)) {\n        var _axis3;\n\n        coords[valCoordName] = null === (_axis3 = axis) || void 0 === _axis3 ? void 0 : _axis3.getTranslator().translate(value);\n        !isDefined(pane) && isDefined(axis) && (pane = axis.pane);\n      }\n\n      coords.canvas = this._getCanvasForPane(pane);\n\n      if (isDefined(coords[argCoordName]) && !isDefined(value)) {\n        var _series2;\n\n        if (!isDefined(axis) && !isDefined(series)) {\n          coords[valCoordName] = argAxis.getAxisPosition();\n        } else if (isDefined(axis) && !isDefined(series)) {\n          coords[valCoordName] = this._argumentAxes.filter(a => a.pane === axis.pane)[0].getAxisPosition();\n        } else if (null !== (_series2 = series) && void 0 !== _series2 && _series2.checkSeriesViewportCoord(argAxis, coords[argCoordName])) {\n          coords[valCoordName] = series.getSeriesPairCoord(coords[argCoordName], true);\n        }\n      }\n\n      if (!isDefined(argument) && isDefined(coords[valCoordName])) {\n        if (isDefined(axis) && !isDefined(series)) {\n          coords[argCoordName] = axis.getAxisPosition();\n        } else if (isDefined(series)) {\n          if (series.checkSeriesViewportCoord(axis, coords[valCoordName])) {\n            coords[argCoordName] = series.getSeriesPairCoord(coords[valCoordName], false);\n          }\n        }\n      }\n\n      return coords;\n    },\n\n    _annotationsPointerEventHandler(event) {\n      if (this._disposed) {\n        return;\n      }\n\n      var originalEvent = event.originalEvent || {};\n      var touch = originalEvent.touches && originalEvent.touches[0] || {};\n\n      var rootOffset = this._renderer.getRootOffset();\n\n      var coords = {\n        x: touch.pageX || originalEvent.pageX || event.pageX,\n        y: touch.pageY || originalEvent.pageY || event.pageY\n      };\n\n      var annotation = this._annotations.items.filter(a => a.hitTest(coords.x - rootOffset.left, coords.y - rootOffset.top))[0];\n\n      if (!annotation || !annotation.options.tooltipEnabled) {\n        this._annotations.hideTooltip();\n\n        return;\n      }\n\n      this._clear();\n\n      if (annotation.options.allowDragging && event.type === pointerEvents.down) {\n        this._annotations._hideToolTipForDrag = true;\n      }\n\n      if (!this._annotations._hideToolTipForDrag) {\n        annotation.showTooltip(this._annotations.tooltip, coords);\n        event.stopPropagation();\n      }\n    },\n\n    _isAnnotationBounded: options => isDefined(options.value) || isDefined(options.argument),\n    _pullOptions: options => ({\n      type: options.type,\n      name: options.name,\n      x: options.x,\n      y: options.y,\n      value: options.value,\n      argument: options.argument,\n      axis: options.axis,\n      series: options.series,\n      options: options,\n      offsetX: options.offsetX,\n      offsetY: options.offsetY\n    }),\n\n    _forceAnnotationRender() {\n      this._change([\"FORCE_RENDER\"]);\n    },\n\n    _clear() {\n      this.hideTooltip();\n      this.clearHover();\n    }\n\n  }\n};\nvar polarChartPlugin = {\n  name: \"annotations_polar_chart\",\n\n  init() {},\n\n  dispose() {},\n\n  members: {\n    _getAnnotationCoords(annotation) {\n      var coords = {\n        offsetX: annotation.offsetX,\n        offsetY: annotation.offsetY,\n        canvas: this._calcCanvas()\n      };\n      var argAxis = this.getArgumentAxis();\n      var argument = argAxis.validateUnit(annotation.argument);\n      var value = this.getValueAxis().validateUnit(annotation.value);\n      var radius = annotation.radius;\n      var angle = annotation.angle;\n      var pointCoords;\n      var series;\n\n      if (annotation.series) {\n        series = this.series.filter(s => s.name === annotation.series)[0];\n      }\n\n      extend(true, coords, this.getXYFromPolar(angle, radius, argument, value));\n\n      if (isDefined(series)) {\n        if (isDefined(coords.angle) && !isDefined(value) && !isDefined(radius)) {\n          if (!isDefined(argument)) {\n            argument = argAxis.getTranslator().from(isFinite(angle) ? this.getActualAngle(angle) : coords.angle);\n          }\n\n          pointCoords = series.getSeriesPairCoord({\n            argument: argument,\n            angle: -coords.angle\n          }, true);\n        } else if (isDefined(coords.radius) && !isDefined(argument) && !isDefined(angle)) {\n          pointCoords = series.getSeriesPairCoord({\n            radius: coords.radius\n          }, false);\n        }\n\n        if (isDefined(pointCoords)) {\n          coords.x = pointCoords.x;\n          coords.y = pointCoords.y;\n        }\n      }\n\n      if (annotation.series && !isDefined(pointCoords)) {\n        coords.x = coords.y = void 0;\n      }\n\n      return coords;\n    },\n\n    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,\n    _isAnnotationBounded: chartPlugin.members._isAnnotationBounded,\n\n    _pullOptions(options) {\n      var polarOptions = extend({}, {\n        radius: options.radius,\n        angle: options.angle\n      }, chartPlugin.members._pullOptions(options));\n      delete polarOptions.axis;\n      return polarOptions;\n    },\n\n    _forceAnnotationRender: chartPlugin.members._forceAnnotationRender,\n    _clear: chartPlugin.members._clear\n  }\n};\nvar vectorMapPlugin = {\n  name: \"annotations_vector_map\",\n\n  init() {},\n\n  dispose() {\n    this._annotations._offTracker();\n\n    this._annotations._offTracker = null;\n  },\n\n  members: {\n    _getAnnotationCoords(annotation) {\n      var coords = {\n        offsetX: annotation.offsetX,\n        offsetY: annotation.offsetY\n      };\n      coords.canvas = this._projection.getCanvas();\n\n      if (annotation.coordinates) {\n        var data = this._projection.toScreenPoint(annotation.coordinates);\n\n        coords.x = data[0];\n        coords.y = data[1];\n      }\n\n      return coords;\n    },\n\n    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,\n    _isAnnotationBounded: options => isDefined(options.coordinates),\n\n    _pullOptions(options) {\n      var vectorMapOptions = extend({}, {\n        coordinates: options.coordinates\n      }, chartPlugin.members._pullOptions(options));\n      delete vectorMapOptions.axis;\n      delete vectorMapOptions.series;\n      delete vectorMapOptions.argument;\n      delete vectorMapOptions.value;\n      return vectorMapOptions;\n    },\n\n    _forceAnnotationRender() {\n      this._change([\"EXTRA_ELEMENTS\"]);\n    },\n\n    _getAnnotationStyles: () => ({\n      \"text-anchor\": \"start\"\n    }),\n\n    _clear() {}\n\n  },\n  extenders: {\n    _prepareExtraElements() {\n      var that = this;\n\n      var renderElements = () => {\n        that._renderExtraElements();\n      };\n\n      that._annotations._offTracker = that._tracker.on({\n        move: renderElements,\n        zoom: renderElements,\n        end: renderElements\n      });\n    }\n\n  }\n};\nvar pieChartPlugin = {\n  name: \"annotations_pie_chart\",\n\n  init() {},\n\n  dispose() {},\n\n  members: {\n    _getAnnotationCoords(annotation) {\n      var series;\n      var coords = {\n        offsetX: annotation.offsetX,\n        offsetY: annotation.offsetY,\n        canvas: this._canvas\n      };\n\n      if (annotation.argument) {\n        if (annotation.series) {\n          series = this.getSeriesByName(annotation.series);\n        } else {\n          series = this.series[0];\n        }\n\n        var argument = series.getPointsByArg(annotation.argument)[0];\n        var {\n          x: x,\n          y: y\n        } = argument.getAnnotationCoords(annotation.location);\n        coords.x = x;\n        coords.y = y;\n      }\n\n      return coords;\n    },\n\n    _isAnnotationBounded: options => options.argument,\n    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,\n\n    _pullOptions(options) {\n      var pieChartOptions = extend({}, {\n        location: options.location\n      }, chartPlugin.members._pullOptions(options));\n      delete pieChartOptions.axis;\n      return pieChartOptions;\n    },\n\n    _clear: chartPlugin.members._clear,\n    _forceAnnotationRender: chartPlugin.members._forceAnnotationRender\n  }\n};\nvar corePlugin = {\n  name: \"annotations_core\",\n\n  init() {\n    this._annotations = {\n      items: [],\n      _hideToolTipForDrag: false,\n      tooltip: new Tooltip({\n        cssClass: \"\".concat(this._rootClassPrefix, \"-annotation-tooltip\"),\n        eventTrigger: this._eventTrigger,\n        widgetRoot: this.element(),\n        widget: this\n      }),\n\n      hideTooltip() {\n        this.tooltip.annotation = null;\n        this.tooltip.hide();\n      },\n\n      clearItems() {\n        this.items.forEach(i => i.plaque.clear());\n        this.items = [];\n      }\n\n    };\n\n    this._annotations.tooltip.setRendererOptions(this._getRendererOptions());\n  },\n\n  dispose() {\n    this._annotationsGroup.linkRemove().linkOff();\n\n    eventsEngine.off(getDocument(), DOT_EVENT_NS);\n\n    this._annotationsGroup.off(DOT_EVENT_NS);\n\n    this._annotations.tooltip && this._annotations.tooltip.dispose();\n  },\n\n  extenders: {\n    _createHtmlStructure() {\n      this._annotationsGroup = this._renderer.g().attr({\n        class: \"\".concat(this._rootClassPrefix, \"-annotations\")\n      }).css(this._getAnnotationStyles()).linkOn(this._renderer.root, \"annotations\").linkAppend();\n      eventsEngine.on(getDocument(), POINTER_ACTION, e => {\n        if (this._disposed) {\n          return;\n        }\n\n        if (!this._annotations.tooltip.isCursorOnTooltip(e.pageX, e.pageY)) {\n          this._annotations.hideTooltip();\n        }\n      });\n      eventsEngine.on(getDocument(), POINTER_UP_EVENT_NAME, event => {\n        this._annotations._hideToolTipForDrag = false;\n\n        this._annotationsPointerEventHandler(event);\n      });\n\n      this._annotationsGroup.on(POINTER_ACTION, this._annotationsPointerEventHandler.bind(this));\n    },\n\n    _renderExtraElements() {\n      this._annotationsGroup.clear();\n\n      this._annotations.items.forEach(item => item.draw(this, this._annotationsGroup));\n    },\n\n    _stopCurrentHandling() {\n      this._annotations.hideTooltip();\n    }\n\n  },\n  members: {\n    _buildAnnotations() {\n      this._annotations.clearItems();\n\n      var items = this._getOption(\"annotations\", true);\n\n      if (!(null !== items && void 0 !== items && items.length)) {\n        return;\n      }\n\n      this._annotations.items = createAnnotations(this, items, this._getOption(\"commonAnnotationSettings\"), this._getOption(\"customizeAnnotation\", true), this._pullOptions);\n    },\n\n    _setAnnotationTooltipOptions() {\n      var tooltipOptions = extend({}, this._getOption(\"tooltip\"));\n      tooltipOptions.contentTemplate = tooltipOptions.customizeTooltip = void 0;\n\n      this._annotations.tooltip.update(tooltipOptions);\n    },\n\n    _getAnnotationCoords: () => ({}),\n    _pullOptions: () => ({}),\n    _getAnnotationStyles: () => ({})\n  },\n\n  customize(constructor) {\n    constructor.addChange({\n      code: \"ANNOTATIONITEMS\",\n\n      handler() {\n        this._requestChange([\"ANNOTATIONS\"]);\n      },\n\n      isOptionChange: true,\n      option: \"annotations\"\n    });\n    constructor.addChange({\n      code: \"ANNOTATIONSSETTINGS\",\n\n      handler() {\n        this._requestChange([\"ANNOTATIONS\"]);\n      },\n\n      isOptionChange: true,\n      option: \"commonAnnotationSettings\"\n    });\n    constructor.addChange({\n      code: \"ANNOTATIONS\",\n\n      handler() {\n        this._buildAnnotations();\n\n        this._setAnnotationTooltipOptions();\n\n        this._forceAnnotationRender();\n      },\n\n      isThemeDependent: true,\n      isOptionChange: true\n    });\n  },\n\n  fontFields: [\"commonAnnotationSettings.font\"]\n};\nexport var plugins = {\n  core: corePlugin,\n  chart: chartPlugin,\n  polarChart: polarChartPlugin,\n  vectorMap: vectorMapPlugin,\n  pieChart: pieChartPlugin\n};","map":null,"metadata":{},"sourceType":"module"}