{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/recurrence.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport errors from \"../../core/errors\";\nimport { each } from \"../../core/utils/iterator\";\nimport { RRule, RRuleSet } from \"rrule\";\nimport dateUtils from \"../../core/utils/date\";\nimport timeZoneUtils from \"./utils.timeZone\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\nvar days = {\n  SU: 0,\n  MO: 1,\n  TU: 2,\n  WE: 3,\n  TH: 4,\n  FR: 5,\n  SA: 6\n};\nvar loggedWarnings = [];\nvar recurrence = null;\nexport function getRecurrenceProcessor() {\n  if (!recurrence) {\n    recurrence = new RecurrenceProcessor();\n  }\n\n  return recurrence;\n}\n\nclass RecurrenceProcessor {\n  constructor() {\n    this.rRule = null;\n    this.rRuleSet = null;\n    this.validator = new RecurrenceValidator();\n  }\n\n  generateDates(options) {\n    var recurrenceRule = this.evalRecurrenceRule(options.rule);\n    var rule = recurrenceRule.rule;\n\n    if (!recurrenceRule.isValid || !rule.freq) {\n      return [];\n    }\n\n    var clientOffsets_startDate = timeZoneUtils.getClientTimezoneOffset(options.start),\n        clientOffsets_minViewDate = timeZoneUtils.getClientTimezoneOffset(options.min),\n        clientOffsets_maxViewDate = timeZoneUtils.getClientTimezoneOffset(options.max);\n    var appointmentOffset = options.appointmentTimezoneOffset;\n    var duration = options.end ? options.end.getTime() - options.start.getTime() : 0;\n    var startDate = timeZoneUtils.setOffsetsToDate(options.start, [-clientOffsets_startDate, appointmentOffset]);\n    var minViewTime = options.min.getTime() - clientOffsets_minViewDate + appointmentOffset;\n    var minViewDate = new Date(minViewTime - duration);\n    var maxViewDate = timeZoneUtils.setOffsetsToDate(options.max, [-clientOffsets_maxViewDate, appointmentOffset]);\n\n    this._initializeRRule(options, startDate, rule.until);\n\n    return this.rRuleSet.between(minViewDate, maxViewDate, true).filter(date => date.getTime() + duration >= minViewTime).map(date => timeZoneUtils.setOffsetsToDate(date, [timeZoneUtils.getClientTimezoneOffset(date), -appointmentOffset]));\n  }\n\n  hasRecurrence(options) {\n    return !!this.generateDates(options).length;\n  }\n\n  evalRecurrenceRule(rule) {\n    var result = {\n      rule: {},\n      isValid: false\n    };\n\n    if (rule) {\n      result.rule = this._parseRecurrenceRule(rule);\n      result.isValid = this.validator.validateRRule(result.rule, rule);\n    }\n\n    return result;\n  }\n\n  isValidRecurrenceRule(rule) {\n    return this.evalRecurrenceRule(rule).isValid;\n  }\n\n  daysFromByDayRule(rule) {\n    var result = [];\n\n    if (rule.byday) {\n      if (Array.isArray(rule.byday)) {\n        result = rule.byday;\n      } else {\n        result = rule.byday.split(\",\");\n      }\n    }\n\n    return result.map(item => {\n      var match = item.match(/[A-Za-z]+/);\n      return !!match && match[0];\n    }).filter(item => !!item);\n  }\n\n  getAsciiStringByDate(date) {\n    var currentOffset = date.getTimezoneOffset() * toMs(\"minute\");\n    var offsetDate = new Date(date.getTime() + currentOffset);\n    return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\";\n  }\n\n  getRecurrenceString(object) {\n    if (!object || !object.freq) {\n      return;\n    }\n\n    var result = \"\";\n\n    for (var field in object) {\n      var value = object[field];\n\n      if (\"interval\" === field && value < 2) {\n        continue;\n      }\n\n      if (\"until\" === field) {\n        value = this.getAsciiStringByDate(value);\n      }\n\n      result += field + \"=\" + value + \";\";\n    }\n\n    result = result.substring(0, result.length - 1);\n    return result.toUpperCase();\n  }\n\n  _parseExceptionToRawArray(value) {\n    return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/);\n  }\n\n  getDateByAsciiString(exceptionText) {\n    if (\"string\" !== typeof exceptionText) {\n      return exceptionText;\n    }\n\n    var result = this._parseExceptionToRawArray(exceptionText);\n\n    if (!result) {\n      return null;\n    }\n\n    var [year, month, date, hours, minutes, seconds, isUtc] = this._createDateTuple(result);\n\n    if (isUtc) {\n      return new Date(Date.UTC(year, month, date, hours, minutes, seconds));\n    }\n\n    return new Date(year, month, date, hours, minutes, seconds);\n  }\n\n  _dispose() {\n    if (this.rRuleSet) {\n      delete this.rRuleSet;\n      this.rRuleSet = null;\n    }\n\n    if (this.rRule) {\n      delete this.rRule;\n      this.rRule = null;\n    }\n  }\n\n  _getTimeZoneOffset() {\n    return new Date().getTimezoneOffset();\n  }\n\n  _initializeRRule(options, startDateUtc, until) {\n    var ruleOptions = RRule.parseString(options.rule);\n    var firstDayOfWeek = options.firstDayOfWeek;\n    ruleOptions.dtstart = startDateUtc;\n\n    if (!ruleOptions.wkst && firstDayOfWeek) {\n      ruleOptions.wkst = [6, 0, 1, 2, 3, 4, 5][firstDayOfWeek];\n    }\n\n    if (until) {\n      ruleOptions.until = timeZoneUtils.setOffsetsToDate(until, [-timeZoneUtils.getClientTimezoneOffset(until), options.appointmentTimezoneOffset]);\n    }\n\n    this._createRRule(ruleOptions);\n\n    if (options.exception) {\n      var exceptionStrings = options.exception;\n      var exceptionDates = exceptionStrings.split(\",\").map(rule => this.getDateByAsciiString(rule));\n      exceptionDates.forEach(date => {\n        if (options.getPostProcessedException) {\n          date = options.getPostProcessedException(date);\n        }\n\n        var utcDate = timeZoneUtils.setOffsetsToDate(date, [-timeZoneUtils.getClientTimezoneOffset(date), options.appointmentTimezoneOffset]);\n        var originClientOffset = date.getTimezoneOffset();\n        var utcDateClientOffset = utcDate.getTimezoneOffset();\n\n        if (utcDateClientOffset !== originClientOffset) {\n          utcDate.setMilliseconds(utcDate.getMilliseconds() - 6e4 * (utcDateClientOffset - originClientOffset));\n        }\n\n        this.rRuleSet.exdate(utcDate);\n      });\n    }\n  }\n\n  _createRRule(ruleOptions) {\n    this._dispose();\n\n    this.rRuleSet = new RRuleSet();\n    this.rRule = new RRule(ruleOptions);\n    this.rRuleSet.rrule(this.rRule);\n  }\n\n  _parseRecurrenceRule(recurrence) {\n    var ruleObject = {};\n    var ruleParts = recurrence.split(\";\");\n\n    for (var i = 0, len = ruleParts.length; i < len; i++) {\n      var rule = ruleParts[i].split(\"=\");\n      var ruleName = rule[0].toLowerCase();\n      var ruleValue = rule[1];\n      ruleObject[ruleName] = ruleValue;\n    }\n\n    var count = parseInt(ruleObject.count);\n\n    if (!isNaN(count)) {\n      ruleObject.count = count;\n    }\n\n    if (ruleObject.interval) {\n      var interval = parseInt(ruleObject.interval);\n\n      if (!isNaN(interval)) {\n        ruleObject.interval = interval;\n      }\n    } else {\n      ruleObject.interval = 1;\n    }\n\n    if (ruleObject.freq && ruleObject.until) {\n      ruleObject.until = this.getDateByAsciiString(ruleObject.until);\n    }\n\n    return ruleObject;\n  }\n\n  _createDateTuple(parseResult) {\n    var isUtc = void 0 !== parseResult[8];\n    parseResult.shift();\n\n    if (void 0 === parseResult[3]) {\n      parseResult.splice(3);\n    } else {\n      parseResult.splice(3, 1);\n      parseResult.splice(6);\n    }\n\n    parseResult[1]--;\n    parseResult.unshift(null);\n    return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc];\n  }\n\n}\n\nclass RecurrenceValidator {\n  validateRRule(rule, recurrence) {\n    if (this._brokenRuleNameExists(rule) || !freqNames.includes(rule.freq) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\n      this._logBrokenRule(recurrence);\n\n      return false;\n    }\n\n    return true;\n  }\n\n  _wrongUntilRule(rule) {\n    var wrongUntil = false;\n    var until = rule.until;\n\n    if (void 0 !== until && !(until instanceof Date)) {\n      wrongUntil = true;\n    }\n\n    return wrongUntil;\n  }\n\n  _wrongCountRule(rule) {\n    var wrongCount = false;\n    var count = rule.count;\n\n    if (count && \"string\" === typeof count) {\n      wrongCount = true;\n    }\n\n    return wrongCount;\n  }\n\n  _wrongByMonthDayRule(rule) {\n    var wrongByMonthDay = false;\n    var byMonthDay = rule.bymonthday;\n\n    if (byMonthDay && isNaN(parseInt(byMonthDay))) {\n      wrongByMonthDay = true;\n    }\n\n    return wrongByMonthDay;\n  }\n\n  _wrongByMonth(rule) {\n    var wrongByMonth = false;\n    var byMonth = rule.bymonth;\n\n    if (byMonth && isNaN(parseInt(byMonth))) {\n      wrongByMonth = true;\n    }\n\n    return wrongByMonth;\n  }\n\n  _wrongIntervalRule(rule) {\n    var wrongInterval = false;\n    var interval = rule.interval;\n\n    if (interval && \"string\" === typeof interval) {\n      wrongInterval = true;\n    }\n\n    return wrongInterval;\n  }\n\n  _wrongDayOfWeek(rule) {\n    var byDay = rule.byday;\n    var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\n    var brokenDaysExist = false;\n\n    if (\"\" === byDay) {\n      brokenDaysExist = true;\n    }\n\n    each(daysByRule, function (_, day) {\n      if (!Object.prototype.hasOwnProperty.call(days, day)) {\n        brokenDaysExist = true;\n        return false;\n      }\n    });\n    return brokenDaysExist;\n  }\n\n  _brokenRuleNameExists(rule) {\n    var brokenRuleExists = false;\n    each(rule, function (ruleName) {\n      if (!ruleNames.includes(ruleName)) {\n        brokenRuleExists = true;\n        return false;\n      }\n    });\n    return brokenRuleExists;\n  }\n\n  _logBrokenRule(recurrence) {\n    if (!loggedWarnings.includes(recurrence)) {\n      errors.log(\"W0006\", recurrence);\n      loggedWarnings.push(recurrence);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}