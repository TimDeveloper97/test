{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_provider.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nvar _excluded = [\"groups\", \"groupOrientation\", \"groupByDate\", \"isAllDayPanelVisible\"];\nimport dateUtils from \"../../../../core/utils/date\";\nimport { getGroupPanelData } from \"../../../../renovation/ui/scheduler/view_model/group_panel/utils\";\nimport { isGroupingByDate, isHorizontalGroupingApplied, isVerticalGroupingApplied } from \"../../../../renovation/ui/scheduler/workspaces/utils\";\nimport { calculateIsGroupedAllDayPanel } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { DateHeaderDataGenerator } from \"./date_header_data_generator\";\nimport { GroupedDataMapProvider } from \"./grouped_data_map_provider\";\nimport { TimePanelDataGenerator } from \"./time_panel_data_generator\";\nimport { getViewDataGeneratorByViewType } from \"./utils\";\nimport timeZoneUtils from \"../../utils.timeZone\";\nexport default class ViewDataProvider {\n  constructor(viewType) {\n    this.viewDataGenerator = getViewDataGeneratorByViewType(viewType);\n    this.viewData = {};\n    this.completeViewDataMap = [];\n    this.completeDateHeaderMap = [];\n    this.viewDataMap = {};\n    this._groupedDataMapProvider = null;\n  }\n\n  get groupedDataMap() {\n    return this._groupedDataMapProvider.groupedDataMap;\n  }\n\n  get hiddenInterval() {\n    return this.viewDataGenerator.hiddenInterval;\n  }\n\n  isSkippedDate(date) {\n    return this.viewDataGenerator.isSkippedDate(date);\n  }\n\n  update(options, isGenerateNewViewData) {\n    this.viewDataGenerator = getViewDataGeneratorByViewType(options.viewType);\n    var viewDataGenerator = this.viewDataGenerator;\n    var dateHeaderDataGenerator = new DateHeaderDataGenerator(viewDataGenerator);\n    var timePanelDataGenerator = new TimePanelDataGenerator(viewDataGenerator);\n\n    var renderOptions = this._transformRenderOptions(options);\n\n    renderOptions.interval = this.viewDataGenerator.getInterval(renderOptions.hoursInterval);\n    this._options = renderOptions;\n\n    if (isGenerateNewViewData) {\n      this.completeViewDataMap = viewDataGenerator.getCompleteViewDataMap(renderOptions);\n      this.completeDateHeaderMap = dateHeaderDataGenerator.getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);\n\n      if (renderOptions.isGenerateTimePanelData) {\n        this.completeTimePanelMap = timePanelDataGenerator.getCompleteTimePanelMap(renderOptions, this.completeViewDataMap);\n      }\n    }\n\n    this.viewDataMap = viewDataGenerator.generateViewDataMap(this.completeViewDataMap, renderOptions);\n    this.updateViewData(renderOptions);\n    this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, {\n      isVerticalGrouping: renderOptions.isVerticalGrouping,\n      viewType: renderOptions.viewType\n    });\n    this.dateHeaderData = dateHeaderDataGenerator.generateDateHeaderData(this.completeDateHeaderMap, this.completeViewDataMap, renderOptions);\n\n    if (renderOptions.isGenerateTimePanelData) {\n      this.timePanelData = timePanelDataGenerator.generateTimePanelData(this.completeTimePanelMap, renderOptions);\n    }\n  }\n\n  createGroupedDataMapProvider() {\n    this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, {\n      isVerticalGrouping: this._options.isVerticalGrouping,\n      viewType: this._options.viewType\n    });\n  }\n\n  updateViewData(options) {\n    var renderOptions = this._transformRenderOptions(options);\n\n    this.viewDataMapWithSelection = this.viewDataGenerator.markSelectedAndFocusedCells(this.viewDataMap, renderOptions);\n    this.viewData = this.viewDataGenerator.getViewDataFromMap(this.completeViewDataMap, this.viewDataMapWithSelection, renderOptions);\n  }\n\n  _transformRenderOptions(renderOptions) {\n    var {\n      groups: groups,\n      groupOrientation: groupOrientation,\n      groupByDate: groupByDate,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = renderOptions,\n        restOptions = _objectWithoutPropertiesLoose(renderOptions, _excluded);\n\n    return _extends({}, restOptions, {\n      startViewDate: this.viewDataGenerator._calculateStartViewDate(renderOptions),\n      isVerticalGrouping: isVerticalGroupingApplied(groups, groupOrientation),\n      isHorizontalGrouping: isHorizontalGroupingApplied(groups, groupOrientation),\n      isGroupedByDate: isGroupingByDate(groups, groupOrientation, groupByDate),\n      isGroupedAllDayPanel: calculateIsGroupedAllDayPanel(groups, groupOrientation, isAllDayPanelVisible),\n      groups: groups,\n      groupOrientation: groupOrientation,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    });\n  }\n\n  getGroupPanelData(options) {\n    var renderOptions = this._transformRenderOptions(options);\n\n    if (renderOptions.groups.length > 0) {\n      var cellCount = this.getCellCount(renderOptions);\n      return getGroupPanelData(renderOptions.groups, cellCount, renderOptions.isGroupedByDate, renderOptions.isGroupedByDate ? 1 : cellCount);\n    }\n\n    return;\n  }\n\n  getGroupStartDate(groupIndex) {\n    return this._groupedDataMapProvider.getGroupStartDate(groupIndex);\n  }\n\n  getGroupEndDate(groupIndex) {\n    return this._groupedDataMapProvider.getGroupEndDate(groupIndex);\n  }\n\n  findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay, isFindByDate) {\n    return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay, isFindByDate);\n  }\n\n  findAllDayGroupCellStartDate(groupIndex, startDate) {\n    return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex, startDate);\n  }\n\n  findCellPositionInMap(cellInfo) {\n    return this._groupedDataMapProvider.findCellPositionInMap(cellInfo);\n  }\n\n  hasAllDayPanel() {\n    var {\n      viewData: viewData\n    } = this.viewDataMap;\n    var {\n      allDayPanel: allDayPanel\n    } = viewData.groupedData[0];\n    return !viewData.isGroupedAllDayPanel && (null === allDayPanel || void 0 === allDayPanel ? void 0 : allDayPanel.length) > 0;\n  }\n\n  getCellsGroup(groupIndex) {\n    return this._groupedDataMapProvider.getCellsGroup(groupIndex);\n  }\n\n  getCompletedGroupsInfo() {\n    return this._groupedDataMapProvider.getCompletedGroupsInfo();\n  }\n\n  getGroupIndices() {\n    return this._groupedDataMapProvider.getGroupIndices();\n  }\n\n  getLastGroupCellPosition(groupIndex) {\n    return this._groupedDataMapProvider.getLastGroupCellPosition(groupIndex);\n  }\n\n  getRowCountInGroup(groupIndex) {\n    return this._groupedDataMapProvider.getRowCountInGroup(groupIndex);\n  }\n\n  getCellData(rowIndex, columnIndex, isAllDay, rtlEnabled) {\n    var row = isAllDay && !this._options.isVerticalGrouping ? this.viewDataMap.allDayPanelMap : this.viewDataMap.dateTableMap[rowIndex];\n    var actualColumnIndex = !rtlEnabled ? columnIndex : row.length - 1 - columnIndex;\n    var {\n      cellData: cellData\n    } = row[actualColumnIndex];\n    return cellData;\n  }\n\n  getCellsByGroupIndexAndAllDay(groupIndex, allDay) {\n    var rowsPerGroup = this._getRowCountWithAllDayRows();\n\n    var isShowAllDayPanel = this._options.isAllDayPanelVisible;\n    var firstRowInGroup = this._options.isVerticalGrouping ? groupIndex * rowsPerGroup : 0;\n    var lastRowInGroup = this._options.isVerticalGrouping ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;\n    var correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;\n    var correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;\n    return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map(row => row.filter(_ref => {\n      var {\n        groupIndex: currentGroupIndex\n      } = _ref;\n      return groupIndex === currentGroupIndex;\n    }));\n  }\n\n  getCellCountWithGroup(groupIndex) {\n    var rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return dateTableGroupedMap.filter((_, index) => index <= groupIndex).reduce((previous, row) => previous + row[rowIndex].length, 0);\n  }\n\n  hasGroupAllDayPanel(groupIndex) {\n    var _this$groupedDataMap$2;\n\n    if (this._options.isVerticalGrouping) {\n      var _this$groupedDataMap$;\n\n      return !!(null !== (_this$groupedDataMap$ = this.groupedDataMap.dateTableGroupedMap[groupIndex]) && void 0 !== _this$groupedDataMap$ && _this$groupedDataMap$[0][0].cellData.allDay);\n    }\n\n    return (null === (_this$groupedDataMap$2 = this.groupedDataMap.allDayPanelGroupedMap[groupIndex]) || void 0 === _this$groupedDataMap$2 ? void 0 : _this$groupedDataMap$2.length) > 0;\n  }\n\n  isGroupIntersectDateInterval(groupIndex, startDate, endDate) {\n    var groupStartDate = this.getGroupStartDate(groupIndex);\n    var groupEndDate = this.getGroupEndDate(groupIndex);\n    return startDate < groupEndDate && endDate > groupStartDate;\n  }\n\n  findGlobalCellPosition(date) {\n    var groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n    var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n    var {\n      completeViewDataMap: completeViewDataMap\n    } = this;\n    var showAllDayPanel = this._options.isAllDayPanelVisible;\n\n    for (var rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {\n      var currentRow = completeViewDataMap[rowIndex];\n\n      for (var columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {\n        var cellData = currentRow[columnIndex];\n        var {\n          startDate: currentStartDate,\n          endDate: currentEndDate,\n          groupIndex: currentGroupIndex,\n          allDay: currentAllDay\n        } = cellData;\n\n        if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {\n          return {\n            position: {\n              columnIndex: columnIndex,\n              rowIndex: showAllDayPanel && !this._options.isVerticalGrouping ? rowIndex - 1 : rowIndex\n            },\n            cellData: cellData\n          };\n        }\n      }\n    }\n  }\n\n  _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {\n    var time = date.getTime();\n    var trimmedTime = dateUtils.trimTime(date).getTime();\n    var cellStartTime = cellStartDate.getTime();\n    var cellEndTime = cellEndDate.getTime();\n    return !allDay && time >= cellStartTime && time < cellEndTime || allDay && trimmedTime === cellStartTime;\n  }\n\n  getSkippedDaysCount(groupIndex, startDate, endDate, daysCount) {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this._groupedDataMapProvider.groupedDataMap;\n    var groupedData = dateTableGroupedMap[groupIndex];\n    var includedDays = 0;\n\n    for (var rowIndex = 0; rowIndex < groupedData.length; rowIndex += 1) {\n      for (var columnIndex = 0; columnIndex < groupedData[rowIndex].length; columnIndex += 1) {\n        var cell = groupedData[rowIndex][columnIndex].cellData;\n\n        if (startDate.getTime() < cell.endDate.getTime() && endDate.getTime() > cell.startDate.getTime()) {\n          includedDays += 1;\n        }\n      }\n    }\n\n    var lastCell = groupedData[groupedData.length - 1][groupedData[0].length - 1].cellData;\n    var lastCellStart = dateUtils.trimTime(lastCell.startDate);\n    var daysAfterView = Math.floor((endDate.getTime() - lastCellStart.getTime()) / dateUtils.dateToMilliseconds(\"day\"));\n    var deltaDays = daysAfterView > 0 ? daysAfterView : 0;\n    return daysCount - includedDays - deltaDays;\n  }\n\n  getColumnsCount() {\n    var {\n      dateTableMap: dateTableMap\n    } = this.viewDataMap;\n    return dateTableMap ? dateTableMap[0].length : 0;\n  }\n\n  getViewEdgeIndices(isAllDayPanel) {\n    if (isAllDayPanel) {\n      return {\n        firstColumnIndex: 0,\n        lastColumnIndex: this.viewDataMap.allDayPanelMap.length - 1,\n        firstRowIndex: 0,\n        lastRowIndex: 0\n      };\n    }\n\n    return {\n      firstColumnIndex: 0,\n      lastColumnIndex: this.viewDataMap.dateTableMap[0].length - 1,\n      firstRowIndex: 0,\n      lastRowIndex: this.viewDataMap.dateTableMap.length - 1\n    };\n  }\n\n  getGroupEdgeIndices(groupIndex, isAllDay) {\n    var groupedDataMap = this.groupedDataMap.dateTableGroupedMap[groupIndex];\n    var cellsCount = groupedDataMap[0].length;\n    var rowsCount = groupedDataMap.length;\n    var firstColumnIndex = groupedDataMap[0][0].position.columnIndex;\n    var lastColumnIndex = groupedDataMap[0][cellsCount - 1].position.columnIndex;\n\n    if (isAllDay) {\n      return {\n        firstColumnIndex: firstColumnIndex,\n        lastColumnIndex: lastColumnIndex,\n        firstRowIndex: 0,\n        lastRowIndex: 0\n      };\n    }\n\n    return {\n      firstColumnIndex: firstColumnIndex,\n      lastColumnIndex: lastColumnIndex,\n      firstRowIndex: groupedDataMap[0][0].position.rowIndex,\n      lastRowIndex: groupedDataMap[rowsCount - 1][0].position.rowIndex\n    };\n  }\n\n  isSameCell(firstCellData, secondCellData) {\n    var {\n      startDate: firstStartDate,\n      groupIndex: firstGroupIndex,\n      allDay: firstAllDay,\n      index: firstIndex\n    } = firstCellData;\n    var {\n      startDate: secondStartDate,\n      groupIndex: secondGroupIndex,\n      allDay: secondAllDay,\n      index: secondIndex\n    } = secondCellData;\n    return firstStartDate.getTime() === secondStartDate.getTime() && firstGroupIndex === secondGroupIndex && firstAllDay === secondAllDay && firstIndex === secondIndex;\n  }\n\n  getLastViewDate() {\n    var completeViewDataMap = this.completeViewDataMap;\n    var rowsCount = completeViewDataMap.length - 1;\n    return completeViewDataMap[rowsCount][completeViewDataMap[rowsCount].length - 1].endDate;\n  }\n\n  getStartViewDate() {\n    return this._options.startViewDate;\n  }\n\n  getIntervalDuration(intervalCount) {\n    return this.viewDataGenerator._getIntervalDuration(intervalCount);\n  }\n\n  getLastCellEndDate() {\n    return new Date(this.getLastViewDate().getTime() - dateUtils.dateToMilliseconds(\"minute\"));\n  }\n\n  getLastViewDateByEndDayHour(endDayHour) {\n    var lastCellEndDate = this.getLastCellEndDate();\n    var endTime = dateUtils.dateTimeFromDecimal(endDayHour);\n    var endDateOfLastViewCell = new Date(lastCellEndDate.setHours(endTime.hours, endTime.minutes));\n    return this._adjustEndDateByDaylightDiff(lastCellEndDate, endDateOfLastViewCell);\n  }\n\n  _adjustEndDateByDaylightDiff(startDate, endDate) {\n    var daylightDiff = timeZoneUtils.getDaylightOffsetInMs(startDate, endDate);\n    var endDateOfLastViewCell = new Date(endDate.getTime() - daylightDiff);\n    return new Date(endDateOfLastViewCell.getTime() - dateUtils.dateToMilliseconds(\"minute\"));\n  }\n\n  getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\n    return this.viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n  }\n\n  getCellCount(options) {\n    return this.viewDataGenerator.getCellCount(options);\n  }\n\n  getRowCount(options) {\n    return this.viewDataGenerator.getRowCount(options);\n  }\n\n  getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\n    return this.viewDataGenerator.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);\n  }\n\n  _getRowCountWithAllDayRows() {\n    var allDayRowCount = this._options.isAllDayPanelVisible ? 1 : 0;\n    return this.getRowCount(this._options) + allDayRowCount;\n  }\n\n  getFirstDayOfWeek(firstDayOfWeekOption) {\n    return this.viewDataGenerator.getFirstDayOfWeek(firstDayOfWeekOption);\n  }\n\n  setViewOptions(options) {\n    this._options = this._transformRenderOptions(options);\n  }\n\n  getViewOptions() {\n    return this._options;\n  }\n\n  getViewPortGroupCount() {\n    var {\n      dateTableGroupedMap: dateTableGroupedMap\n    } = this.groupedDataMap;\n    return (null === dateTableGroupedMap || void 0 === dateTableGroupedMap ? void 0 : dateTableGroupedMap.length) || 0;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}