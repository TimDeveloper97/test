{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/date_header_data_generator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nvar _excluded = [\"startDate\", \"endDate\", \"isFirstGroupCell\", \"isLastGroupCell\"];\nimport dateUtils from \"../../../../core/utils/date\";\nimport { getGroupCount } from \"../../resources/utils\";\nimport { getHeaderCellText, formatWeekdayAndDay, getHorizontalGroupCount, getTotalCellCountByCompleteData, getDisplayedCellCount } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nexport class DateHeaderDataGenerator {\n  constructor(viewDataGenerator) {\n    this._viewDataGenerator = viewDataGenerator;\n  }\n\n  getCompleteDateHeaderMap(options, completeViewDataMap) {\n    var {\n      isGenerateWeekDaysHeaderData: isGenerateWeekDaysHeaderData\n    } = options;\n    var result = [];\n\n    if (isGenerateWeekDaysHeaderData) {\n      var weekDaysRow = this._generateWeekDaysHeaderRowMap(options, completeViewDataMap);\n\n      result.push(weekDaysRow);\n    }\n\n    var dateRow = this._generateHeaderDateRow(options, completeViewDataMap);\n\n    result.push(dateRow);\n    return result;\n  }\n\n  _generateWeekDaysHeaderRowMap(options, completeViewDataMap) {\n    var {\n      isGroupedByDate: isGroupedByDate,\n      groups: groups,\n      groupOrientation: groupOrientation,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval,\n      isHorizontalGrouping: isHorizontalGrouping,\n      intervalCount: intervalCount\n    } = options;\n\n    var cellCountInDay = this._viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n\n    var horizontalGroupCount = getHorizontalGroupCount(groups, groupOrientation);\n    var index = completeViewDataMap[0][0].allDay ? 1 : 0;\n    var colSpan = isGroupedByDate ? horizontalGroupCount * cellCountInDay : cellCountInDay;\n    var groupCount = getGroupCount(groups);\n    var datesRepeatCount = isHorizontalGrouping && !isGroupedByDate ? groupCount : 1;\n    var daysInGroup = this._viewDataGenerator.daysInInterval * intervalCount;\n    var daysInView = daysInGroup * datesRepeatCount;\n    var weekDaysRow = [];\n\n    for (var dayIndex = 0; dayIndex < daysInView; dayIndex += 1) {\n      var cell = completeViewDataMap[index][dayIndex * colSpan];\n      weekDaysRow.push(_extends({}, cell, {\n        colSpan: colSpan,\n        text: formatWeekdayAndDay(cell.startDate),\n        isFirstGroupCell: false,\n        isLastGroupCell: false\n      }));\n    }\n\n    return weekDaysRow;\n  }\n\n  _generateHeaderDateRow(options, completeViewDataMap) {\n    var {\n      today: today,\n      isGroupedByDate: isGroupedByDate,\n      groupOrientation: groupOrientation,\n      groups: groups,\n      headerCellTextFormat: headerCellTextFormat,\n      getDateForHeaderText: getDateForHeaderText,\n      interval: interval,\n      startViewDate: startViewDate,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval,\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType\n    } = options;\n    var horizontalGroupCount = getHorizontalGroupCount(groups, groupOrientation);\n    var index = completeViewDataMap[0][0].allDay ? 1 : 0;\n    var colSpan = isGroupedByDate ? horizontalGroupCount : 1;\n    var isVerticalGrouping = \"vertical\" === groupOrientation;\n\n    var cellCountInGroupRow = this._viewDataGenerator.getCellCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      hoursInterval: hoursInterval,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour\n    });\n\n    var cellCountInDay = this._viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n\n    var slicedByColumnsData = isGroupedByDate ? completeViewDataMap[index].filter((_, columnIndex) => columnIndex % horizontalGroupCount === 0) : completeViewDataMap[index];\n    return slicedByColumnsData.map((_ref, index) => {\n      var {\n        startDate: startDate,\n        isFirstGroupCell: isFirstGroupCell,\n        isLastGroupCell: isLastGroupCell\n      } = _ref,\n          restProps = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      var text = getHeaderCellText(index % cellCountInGroupRow, startDate, headerCellTextFormat, getDateForHeaderText, {\n        interval: interval,\n        startViewDate: startViewDate,\n        startDayHour: startDayHour,\n        cellCountInDay: cellCountInDay\n      });\n      return _extends({}, restProps, {\n        startDate: startDate,\n        text: text,\n        today: dateUtils.sameDate(startDate, today),\n        colSpan: colSpan,\n        isFirstGroupCell: isGroupedByDate || isFirstGroupCell && !isVerticalGrouping,\n        isLastGroupCell: isGroupedByDate || isLastGroupCell && !isVerticalGrouping\n      });\n    });\n  }\n\n  generateDateHeaderData(completeDateHeaderMap, completeViewDataMap, options) {\n    var {\n      isGenerateWeekDaysHeaderData: isGenerateWeekDaysHeaderData,\n      cellWidth: cellWidth,\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      hoursInterval: hoursInterval,\n      isMonthDateHeader: isMonthDateHeader\n    } = options;\n    var dataMap = [];\n    var weekDayRowConfig = {};\n    var validCellWidth = cellWidth || 0;\n\n    if (isGenerateWeekDaysHeaderData) {\n      weekDayRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, completeViewDataMap, this._viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval), 0, validCellWidth);\n      dataMap.push(weekDayRowConfig.dateRow);\n    }\n\n    var datesRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, completeViewDataMap, 1, isGenerateWeekDaysHeaderData ? 1 : 0, validCellWidth);\n\n    dataMap.push(datesRowConfig.dateRow);\n    return {\n      dataMap: dataMap,\n      leftVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.leftVirtualCellWidth : void 0,\n      rightVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.rightVirtualCellWidth : void 0,\n      leftVirtualCellCount: datesRowConfig.leftVirtualCellCount,\n      rightVirtualCellCount: datesRowConfig.rightVirtualCellCount,\n      weekDayLeftVirtualCellWidth: weekDayRowConfig.leftVirtualCellWidth,\n      weekDayRightVirtualCellWidth: weekDayRowConfig.rightVirtualCellWidth,\n      weekDayLeftVirtualCellCount: weekDayRowConfig.leftVirtualCellCount,\n      weekDayRightVirtualCellCount: weekDayRowConfig.rightVirtualCellCount,\n      isMonthDateHeader: isMonthDateHeader\n    };\n  }\n\n  _generateDateHeaderDataRow(options, completeDateHeaderMap, completeViewDataMap, baseColSpan, rowIndex, cellWidth) {\n    var {\n      startCellIndex: startCellIndex,\n      cellCount: cellCount,\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\n      groups: groups,\n      groupOrientation: groupOrientation,\n      isGroupedByDate: isGroupedByDate\n    } = options;\n    var horizontalGroupCount = getHorizontalGroupCount(groups, groupOrientation);\n    var colSpan = isGroupedByDate ? horizontalGroupCount * baseColSpan : baseColSpan;\n    var leftVirtualCellCount = Math.floor(startCellIndex / colSpan);\n    var displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);\n    var actualCellCount = Math.ceil((startCellIndex + displayedCellCount) / colSpan);\n    var totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);\n    var dateRow = completeDateHeaderMap[rowIndex].slice(leftVirtualCellCount, actualCellCount);\n    var finalLeftVirtualCellCount = leftVirtualCellCount * colSpan;\n    var finalLeftVirtualCellWidth = finalLeftVirtualCellCount * cellWidth;\n    var finalRightVirtualCellCount = totalCellCount - actualCellCount * colSpan;\n    var finalRightVirtualCellWidth = finalRightVirtualCellCount * cellWidth;\n    return {\n      dateRow: dateRow,\n      leftVirtualCellCount: finalLeftVirtualCellCount,\n      leftVirtualCellWidth: isProvideVirtualCellsWidth ? finalLeftVirtualCellWidth : void 0,\n      rightVirtualCellCount: finalRightVirtualCellCount,\n      rightVirtualCellWidth: isProvideVirtualCellsWidth ? finalRightVirtualCellWidth : void 0\n    };\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}