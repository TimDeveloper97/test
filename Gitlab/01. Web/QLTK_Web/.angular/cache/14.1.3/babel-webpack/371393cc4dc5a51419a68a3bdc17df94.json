{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/dataProvider/utils.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../../../core/utils/date\";\nimport timeZoneUtils from \"../../utils.timeZone\";\nimport dateSerialization from \"../../../../core/utils/date_serialization\";\nimport { ExpressionUtils } from \"../../expressionUtils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar FULL_DATE_FORMAT = \"yyyyMMddTHHmmss\";\nexport var compareDateWithStartDayHour = (startDate, endDate, startDayHour, allDay, severalDays) => {\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var result = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;\n  return result;\n};\nexport var compareDateWithEndDayHour = options => {\n  var {\n    startDate: startDate,\n    endDate: endDate,\n    startDayHour: startDayHour,\n    endDayHour: endDayHour,\n    viewStartDayHour: viewStartDayHour,\n    viewEndDayHour: viewEndDayHour,\n    allDay: allDay,\n    severalDays: severalDays,\n    min: min,\n    max: max,\n    checkIntersectViewport: checkIntersectViewport\n  } = options;\n  var hiddenInterval = (24 - viewEndDayHour + viewStartDayHour) * toMs(\"hour\");\n  var apptDuration = endDate.getTime() - startDate.getTime();\n  var delta = (hiddenInterval - apptDuration) / toMs(\"hour\");\n  var apptStartHour = startDate.getHours();\n  var apptStartMinutes = startDate.getMinutes();\n  var result;\n  var endTime = dateUtils.dateTimeFromDecimal(endDayHour);\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var apptIntersectViewport = startDate < max && endDate > min;\n  result = checkIntersectViewport && apptIntersectViewport || apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max || severalDays && apptIntersectViewport && (apptStartHour < endTime.hours || 60 * endDate.getHours() + endDate.getMinutes() > 60 * startTime.hours);\n\n  if (apptDuration < hiddenInterval) {\n    if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {\n      result = false;\n    }\n  }\n\n  return result;\n};\nexport var getAppointmentTakesSeveralDays = adapter => !dateUtils.sameDate(adapter.startDate, adapter.endDate);\nexport var _isEndDateWrong = (startDate, endDate) => !endDate || isNaN(endDate.getTime()) || startDate.getTime() > endDate.getTime();\nexport var _appointmentPartInInterval = (startDate, endDate, startDayHour, endDayHour) => {\n  var apptStartDayHour = startDate.getHours();\n  var apptEndDayHour = endDate.getHours();\n  return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour;\n};\nexport var getRecurrenceException = (appointmentAdapter, timeZoneCalculator, timeZone) => {\n  var recurrenceException = appointmentAdapter.recurrenceException;\n\n  if (recurrenceException) {\n    var exceptions = recurrenceException.split(\",\");\n\n    for (var i = 0; i < exceptions.length; i++) {\n      exceptions[i] = _convertRecurrenceException(exceptions[i], appointmentAdapter.startDate, timeZoneCalculator, timeZone);\n    }\n\n    return exceptions.join();\n  }\n\n  return recurrenceException;\n};\nexport var _convertRecurrenceException = (exceptionString, startDate, timeZoneCalculator, timeZone) => {\n  exceptionString = exceptionString.replace(/\\s/g, \"\");\n\n  var getConvertedToTimeZone = date => timeZoneCalculator.createDate(date, {\n    path: \"toGrid\"\n  });\n\n  var exceptionDate = dateSerialization.deserializeDate(exceptionString);\n  var convertedStartDate = getConvertedToTimeZone(startDate);\n  var convertedExceptionDate = getConvertedToTimeZone(exceptionDate);\n  convertedExceptionDate = timeZoneUtils.correctRecurrenceExceptionByTimezone(convertedExceptionDate, convertedStartDate, timeZone);\n  exceptionString = dateSerialization.serializeDate(convertedExceptionDate, FULL_DATE_FORMAT);\n  return exceptionString;\n};\nexport var replaceWrongEndDate = (appointment, startDate, endDate, appointmentDuration, dataAccessors) => {\n  if (_isEndDateWrong(startDate, endDate)) {\n    var calculatedEndDate = ((isAllDay, startDate) => {\n      if (isAllDay) {\n        return dateUtils.setToDayEnd(new Date(startDate));\n      }\n\n      return new Date(startDate.getTime() + appointmentDuration * toMs(\"minute\"));\n    })(appointment.allDay, startDate);\n\n    dataAccessors.setter.endDate(appointment, calculatedEndDate);\n  }\n};\nexport var sortAppointmentsByStartDate = (appointments, dataAccessors) => {\n  appointments.sort((a, b) => {\n    var firstDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", a.settings || a));\n    var secondDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", b.settings || b));\n    return Math.sign(firstDate.getTime() - secondDate.getTime());\n  });\n};","map":null,"metadata":{},"sourceType":"module"}