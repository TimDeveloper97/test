{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/chart_components/zoom_and_pan.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { normalizeEnum, getVizRangeObject } from \"../core/utils\";\nimport { name as wheelEvent } from \"../../events/core/wheel\";\nimport * as transformEvents from \"../../events/transform\";\nimport { start as dragEventStart, move as dragEventMove, end as dragEventEnd } from \"../../events/drag\";\nvar EVENTS_NS = \".zoomAndPanNS\";\nvar DRAG_START_EVENT_NAME = dragEventStart + EVENTS_NS;\nvar DRAG_EVENT_NAME = dragEventMove + EVENTS_NS;\nvar DRAG_END_EVENT_NAME = dragEventEnd + EVENTS_NS;\nvar PINCH_START_EVENT_NAME = transformEvents.pinchstart + EVENTS_NS;\nvar PINCH_EVENT_NAME = transformEvents.pinch + EVENTS_NS;\nvar PINCH_END_EVENT_NAME = transformEvents.pinchend + EVENTS_NS;\nvar SCROLL_BAR_START_EVENT_NAME = \"dxc-scroll-start\" + EVENTS_NS;\nvar SCROLL_BAR_MOVE_EVENT_NAME = \"dxc-scroll-move\" + EVENTS_NS;\nvar SCROLL_BAR_END_EVENT_NAME = \"dxc-scroll-end\" + EVENTS_NS;\nvar GESTURE_TIMEOUT = 300;\nvar MIN_DRAG_DELTA = 5;\nvar _min = Math.min;\nvar _max = Math.max;\nvar _abs = Math.abs;\n\nfunction canvasToRect(canvas) {\n  return {\n    x: canvas.left,\n    y: canvas.top,\n    width: canvas.width - canvas.left - canvas.right,\n    height: canvas.height - canvas.top - canvas.bottom\n  };\n}\n\nfunction checkCoords(rect, coords) {\n  var x = coords.x;\n  var y = coords.y;\n  return x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.height + rect.y;\n}\n\nfunction sortAxes(axes, onlyAxisToNotify) {\n  if (onlyAxisToNotify) {\n    axes = axes.sort((a, b) => {\n      if (a === onlyAxisToNotify) {\n        return -1;\n      }\n\n      if (b === onlyAxisToNotify) {\n        return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  return axes;\n}\n\nfunction getFilteredAxes(axes) {\n  return axes.filter(a => !a.getTranslator().getBusinessRange().isEmpty());\n}\n\nfunction isAxisAvailablePanning(axes) {\n  return axes.some(axis => !axis.isExtremePosition(false) || !axis.isExtremePosition(true));\n}\n\nfunction axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e) {\n  var silent = onlyAxisToNotify && axis !== onlyAxisToNotify;\n  var range = getRange(axis);\n  var {\n    stopInteraction: stopInteraction,\n    correctedRange: correctedRange\n  } = axis.checkZoomingLowerLimitOvercome(actionField, scale, range);\n  var result = axis.handleZooming(stopInteraction ? null : correctedRange, getParameters(silent), e, actionField);\n  stopInteraction && axis.handleZoomEnd();\n  return {\n    stopInteraction: stopInteraction,\n    result: result\n  };\n}\n\nfunction zoomAxes(e, axes, getRange, zoom, params, onlyAxisToNotify) {\n  axes = sortAxes(axes, onlyAxisToNotify);\n  var zoomStarted = false;\n\n  var getParameters = silent => ({\n    start: !!silent,\n    end: !!silent\n  });\n\n  getFilteredAxes(axes).some(axis => {\n    var translator = axis.getTranslator();\n    var scale = translator.getMinScale(zoom);\n    var {\n      stopInteraction: stopInteraction,\n      result: result\n    } = axisZoom(axis, onlyAxisToNotify, getRange(_extends({\n      scale: scale,\n      translator: translator,\n      axis: axis\n    }, params)), getParameters, \"zoom\", scale, e);\n    zoomStarted = !stopInteraction;\n    return onlyAxisToNotify && result.isPrevented;\n  });\n  return zoomStarted;\n}\n\nfunction cancelEvent(e) {\n  if (e.originalEvent) {\n    cancelEvent(e.originalEvent);\n  }\n\n  if (false !== e.cancelable) {\n    e.cancel = true;\n  }\n}\n\nexport default {\n  name: \"zoom_and_pan\",\n  init: function () {\n    var chart = this;\n    var renderer = this._renderer;\n\n    function getAxesCopy(zoomAndPan, actionField) {\n      var axes = [];\n      var options = zoomAndPan.options;\n      var actionData = zoomAndPan.actionData;\n\n      if (options.argumentAxis[actionField]) {\n        axes.push(chart.getArgumentAxis());\n      }\n\n      if (options.valueAxis[actionField]) {\n        axes = axes.concat(actionData.valueAxes);\n      }\n\n      return axes;\n    }\n\n    function startAxesViewportChanging(zoomAndPan, actionField, e) {\n      var axes = getAxesCopy(zoomAndPan, actionField);\n      getFilteredAxes(axes).some(axis => axis.handleZooming(null, {\n        end: true\n      }, e, actionField).isPrevented) && cancelEvent(e);\n    }\n\n    function axesViewportChanging(zoomAndPan, actionField, e, offsetCalc, centerCalc) {\n      function zoomAxes(axes, criteria, coordField, e, actionData) {\n        var zoom = {\n          zoomed: false\n        };\n        criteria && getFilteredAxes(axes).forEach(axis => {\n          var options = axis.getOptions();\n          var viewport = axis.visualRange();\n          var scale = axis.getTranslator().getEventScale(e);\n          var translate = -offsetCalc(e, actionData, coordField, scale);\n          zoom = extend(true, zoom, axis.getTranslator().zoom(translate, scale, axis.getZoomBounds()));\n          var range = axis.adjustRange(getVizRangeObject([zoom.min, zoom.max]));\n          var {\n            stopInteraction: stopInteraction,\n            correctedRange: correctedRange\n          } = axis.checkZoomingLowerLimitOvercome(actionField, scale, range);\n\n          if (!isDefined(viewport) || viewport.startValue.valueOf() !== correctedRange.startValue.valueOf() || viewport.endValue.valueOf() !== correctedRange.endValue.valueOf()) {\n            axis.handleZooming(stopInteraction ? null : correctedRange, {\n              start: true,\n              end: true\n            }, e, actionField);\n\n            if (!stopInteraction) {\n              zoom.zoomed = true;\n              zoom.deltaTranslate = translate - zoom.translate;\n            }\n          } else if (\"touch\" === e.pointerType && \"discrete\" === options.type) {\n            var isMinPosition = axis.isExtremePosition(false);\n            var isMaxPosition = axis.isExtremePosition(true);\n            var zoomInEnabled = scale > 1 && !stopInteraction;\n            var zoomOutEnabled = scale < 1 && (!isMinPosition || !isMaxPosition);\n            var panningEnabled = 1 === scale && !(isMinPosition && (translate < 0 && !options.inverted || translate > 0 && options.inverted) || isMaxPosition && (translate > 0 && !options.inverted || translate < 0 && options.inverted));\n            zoom.enabled = zoomInEnabled || zoomOutEnabled || panningEnabled;\n          }\n        });\n        return zoom;\n      }\n\n      function storeOffset(e, actionData, zoom, coordField) {\n        if (zoom.zoomed) {\n          actionData.offset[coordField] = (e.offset ? e.offset[coordField] : actionData.offset[coordField]) + zoom.deltaTranslate;\n        }\n      }\n\n      function storeCenter(center, actionData, zoom, coordField) {\n        if (zoom.zoomed) {\n          actionData.center[coordField] = center[coordField] + zoom.deltaTranslate;\n        }\n      }\n\n      var rotated = chart.option(\"rotated\");\n      var actionData = zoomAndPan.actionData;\n      var options = zoomAndPan.options;\n      var argZoom = {};\n      var valZoom = {};\n\n      if (!actionData.fallback) {\n        argZoom = zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? \"y\" : \"x\", e, actionData);\n        valZoom = zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? \"x\" : \"y\", e, actionData);\n\n        chart._requestChange([\"VISUAL_RANGE\"]);\n\n        storeOffset(e, actionData, argZoom, rotated ? \"y\" : \"x\");\n        storeOffset(e, actionData, valZoom, rotated ? \"x\" : \"y\");\n      }\n\n      var center = centerCalc(e);\n      storeCenter(center, actionData, argZoom, rotated ? \"y\" : \"x\");\n      storeCenter(center, actionData, valZoom, rotated ? \"x\" : \"y\");\n\n      if (!argZoom.zoomed && !valZoom.zoomed) {\n        actionData.center = center;\n      }\n\n      return argZoom.zoomed || valZoom.zoomed || actionData.fallback || argZoom.enabled || valZoom.enabled;\n    }\n\n    function finishAxesViewportChanging(zoomAndPan, actionField, e, offsetCalc) {\n      function zoomAxes(axes, coordField, actionData, onlyAxisToNotify) {\n        var zoomStarted = false;\n        var scale = e.scale || 1;\n\n        var getRange = axis => {\n          var zoom = axis.getTranslator().zoom(-offsetCalc(e, actionData, coordField, scale), scale, axis.getZoomBounds());\n          return {\n            startValue: zoom.min,\n            endValue: zoom.max\n          };\n        };\n\n        var getParameters = silent => ({\n          start: true,\n          end: silent\n        });\n\n        getFilteredAxes(axes).forEach(axis => {\n          zoomStarted = !axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e).stopInteraction;\n        });\n        return zoomStarted;\n      }\n\n      var rotated = chart.option(\"rotated\");\n      var actionData = zoomAndPan.actionData;\n      var options = zoomAndPan.options;\n      var zoomStarted = true;\n\n      if (actionData.fallback) {\n        zoomStarted &= options.argumentAxis[actionField] && zoomAxes(chart._argumentAxes, rotated ? \"y\" : \"x\", actionData, chart.getArgumentAxis());\n        zoomStarted |= options.valueAxis[actionField] && zoomAxes(actionData.valueAxes, rotated ? \"x\" : \"y\", actionData);\n      } else {\n        var axes = getAxesCopy(zoomAndPan, actionField);\n        getFilteredAxes(axes).forEach(axis => {\n          axis.handleZooming(null, {\n            start: true\n          }, e, actionField);\n        });\n        zoomStarted = axes.length;\n      }\n\n      zoomStarted && chart._requestChange([\"VISUAL_RANGE\"]);\n    }\n\n    function prepareActionData(coords, action) {\n      var axes = chart._argumentAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), coords));\n\n      return {\n        fallback: chart._lastRenderingTime > GESTURE_TIMEOUT,\n        cancel: !axes.length || !isDefined(action),\n        action: action,\n        curAxisRect: axes.length && canvasToRect(axes[0].getCanvas()),\n        valueAxes: axes.length && chart._valueAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), coords)),\n        offset: {\n          x: 0,\n          y: 0\n        },\n        center: coords,\n        startCenter: coords\n      };\n    }\n\n    function getPointerCoord(rect, e) {\n      var rootOffset = renderer.getRootOffset();\n      return {\n        x: _min(_max(e.pageX - rootOffset.left, rect.x), rect.width + rect.x),\n        y: _min(_max(e.pageY - rootOffset.top, rect.y), rect.height + rect.y)\n      };\n    }\n\n    function calcCenterForPinch(e) {\n      var rootOffset = renderer.getRootOffset();\n      var x1 = e.pointers[0].pageX;\n      var x2 = e.pointers[1].pageX;\n      var y1 = e.pointers[0].pageY;\n      var y2 = e.pointers[1].pageY;\n      return {\n        x: _min(x1, x2) + _abs(x2 - x1) / 2 - rootOffset.left,\n        y: _min(y1, y2) + _abs(y2 - y1) / 2 - rootOffset.top\n      };\n    }\n\n    function calcCenterForDrag(e) {\n      var rootOffset = renderer.getRootOffset();\n      return {\n        x: e.pageX - rootOffset.left,\n        y: e.pageY - rootOffset.top\n      };\n    }\n\n    function calcOffsetForDrag(e, actionData, coordField) {\n      return e.offset[coordField] - actionData.offset[coordField];\n    }\n\n    function preventDefaults(e) {\n      if (false !== e.cancelable) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n\n      chart._stopCurrentHandling();\n    }\n\n    var zoomAndPan = {\n      dragStartHandler: function (e) {\n        var options = zoomAndPan.options;\n        var isTouch = \"touch\" === e.pointerType;\n        var wantPan = options.argumentAxis.pan || options.valueAxis.pan;\n        var wantZoom = options.argumentAxis.zoom || options.valueAxis.zoom;\n        var panKeyPressed = isDefined(options.panKey) && e[normalizeEnum(options.panKey) + \"Key\"];\n        var dragToZoom = options.dragToZoom;\n        var action;\n        e._cancelPreventDefault = true;\n\n        if (isTouch) {\n          if (options.allowTouchGestures && wantPan) {\n            var cancelPanning = !zoomAndPan.panningVisualRangeEnabled() || zoomAndPan.skipEvent;\n            action = cancelPanning ? null : \"pan\";\n          }\n        } else if (dragToZoom && wantPan && panKeyPressed || !dragToZoom && wantPan) {\n          action = \"pan\";\n        } else if (dragToZoom && wantZoom) {\n          action = \"zoom\";\n        }\n\n        var actionData = prepareActionData(calcCenterForDrag(e), action);\n\n        if (actionData.cancel) {\n          zoomAndPan.skipEvent = false;\n\n          if (false !== e.cancelable) {\n            e.cancel = true;\n          }\n\n          return;\n        }\n\n        zoomAndPan.actionData = actionData;\n\n        if (\"zoom\" === action) {\n          actionData.startCoords = getPointerCoord(actionData.curAxisRect, e);\n          actionData.rect = renderer.rect(0, 0, 0, 0).attr(options.dragBoxStyle).append(renderer.root);\n        } else {\n          startAxesViewportChanging(zoomAndPan, \"pan\", e);\n        }\n      },\n      dragHandler: function (e) {\n        var rotated = chart.option(\"rotated\");\n        var options = zoomAndPan.options;\n        var actionData = zoomAndPan.actionData;\n        var isTouch = \"touch\" === e.pointerType;\n        e._cancelPreventDefault = true;\n\n        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled()) {\n          return;\n        }\n\n        if (\"zoom\" === actionData.action) {\n          preventDefaults(e);\n          var curCanvas = actionData.curAxisRect;\n          var startCoords = actionData.startCoords;\n          var curCoords = getPointerCoord(curCanvas, e);\n          var zoomArg = options.argumentAxis.zoom;\n          var zoomVal = options.valueAxis.zoom;\n          var rect = {\n            x: _min(startCoords.x, curCoords.x),\n            y: _min(startCoords.y, curCoords.y),\n            width: _abs(startCoords.x - curCoords.x),\n            height: _abs(startCoords.y - curCoords.y)\n          };\n\n          if (!zoomArg || !zoomVal) {\n            if (!zoomArg && !rotated || !zoomVal && rotated) {\n              rect.x = curCanvas.x;\n              rect.width = curCanvas.width;\n            } else {\n              rect.y = curCanvas.y;\n              rect.height = curCanvas.height;\n            }\n          }\n\n          actionData.rect.attr(rect);\n        } else if (\"pan\" === actionData.action) {\n          axesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag, e => e.offset);\n          var deltaOffsetY = Math.abs(e.offset.y - actionData.offset.y);\n          var deltaOffsetX = Math.abs(e.offset.x - actionData.offset.x);\n\n          if (isTouch && (deltaOffsetY > MIN_DRAG_DELTA && deltaOffsetY > Math.abs(actionData.offset.x) || deltaOffsetX > MIN_DRAG_DELTA && deltaOffsetX > Math.abs(actionData.offset.y))) {\n            return;\n          }\n\n          preventDefaults(e);\n        }\n      },\n      dragEndHandler: function (e) {\n        var rotated = chart.option(\"rotated\");\n        var options = zoomAndPan.options;\n        var actionData = zoomAndPan.actionData;\n        var isTouch = \"touch\" === e.pointerType;\n\n        var getRange = _ref => {\n          var {\n            translator: translator,\n            startCoord: startCoord,\n            curCoord: curCoord\n          } = _ref;\n          return () => [translator.from(startCoord), translator.from(curCoord)];\n        };\n\n        var getCoords = (curCoords, startCoords, field) => ({\n          curCoord: curCoords[field],\n          startCoord: startCoords[field]\n        });\n\n        var needToZoom = (axisOption, coords) => axisOption.zoom && _abs(coords.curCoord - coords.startCoord) > MIN_DRAG_DELTA;\n\n        var panIsEmpty = actionData && \"pan\" === actionData.action && !actionData.fallback && 0 === actionData.offset.x && 0 === actionData.offset.y;\n\n        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled() || panIsEmpty) {\n          return;\n        }\n\n        !isTouch && preventDefaults(e);\n\n        if (\"zoom\" === actionData.action) {\n          var curCoords = getPointerCoord(actionData.curAxisRect, e);\n          var argumentCoords = getCoords(curCoords, actionData.startCoords, rotated ? \"y\" : \"x\");\n          var valueCoords = getCoords(curCoords, actionData.startCoords, rotated ? \"x\" : \"y\");\n          var argumentAxesZoomed = needToZoom(options.argumentAxis, argumentCoords) && zoomAxes(e, chart._argumentAxes, getRange, true, argumentCoords, chart.getArgumentAxis());\n          var valueAxesZoomed = needToZoom(options.valueAxis, valueCoords) && zoomAxes(e, actionData.valueAxes, getRange, true, valueCoords);\n\n          if (valueAxesZoomed || argumentAxesZoomed) {\n            chart._requestChange([\"VISUAL_RANGE\"]);\n          }\n\n          actionData.rect.dispose();\n        } else if (\"pan\" === actionData.action) {\n          finishAxesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag);\n        }\n\n        zoomAndPan.actionData = null;\n      },\n      pinchStartHandler: function (e) {\n        var actionData = prepareActionData(calcCenterForPinch(e), \"zoom\");\n\n        if (actionData.cancel) {\n          cancelEvent(e);\n          return;\n        }\n\n        zoomAndPan.actionData = actionData;\n        startAxesViewportChanging(zoomAndPan, \"zoom\", e);\n      },\n      pinchHandler: function (e) {\n        if (!zoomAndPan.actionData) {\n          return;\n        }\n\n        axesViewportChanging(zoomAndPan, \"zoom\", e, (e, actionData, coordField, scale) => calcCenterForPinch(e)[coordField] - actionData.center[coordField] + (actionData.center[coordField] - actionData.center[coordField] * scale), calcCenterForPinch);\n        preventDefaults(e);\n      },\n      pinchEndHandler: function (e) {\n        if (!zoomAndPan.actionData) {\n          return;\n        }\n\n        finishAxesViewportChanging(zoomAndPan, \"zoom\", e, (e, actionData, coordField, scale) => actionData.center[coordField] - actionData.startCenter[coordField] + (actionData.startCenter[coordField] - actionData.startCenter[coordField] * scale));\n        zoomAndPan.actionData = null;\n      },\n      mouseWheelHandler: function (e) {\n        var options = zoomAndPan.options;\n        var rotated = chart.option(\"rotated\");\n\n        var getRange = _ref2 => {\n          var {\n            translator: translator,\n            coord: coord,\n            scale: scale,\n            axis: axis\n          } = _ref2;\n          return () => {\n            var zoom = translator.zoom(-(coord - coord * scale), scale, axis.getZoomBounds());\n            return {\n              startValue: zoom.min,\n              endValue: zoom.max\n            };\n          };\n        };\n\n        var coords = calcCenterForDrag(e);\n        var axesZoomed = false;\n        var targetAxes;\n\n        if (options.valueAxis.zoom) {\n          targetAxes = chart._valueAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), coords));\n\n          if (0 === targetAxes.length) {\n            var targetCanvas = chart._valueAxes.reduce((r, axis) => {\n              if (!r && axis.coordsIn(coords.x, coords.y)) {\n                r = axis.getCanvas();\n              }\n\n              return r;\n            }, null);\n\n            if (targetCanvas) {\n              targetAxes = chart._valueAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), {\n                x: targetCanvas.left,\n                y: targetCanvas.top\n              }));\n            }\n          }\n\n          axesZoomed |= zoomAxes(e, targetAxes, getRange, e.delta > 0, {\n            coord: rotated ? coords.x : coords.y\n          });\n        }\n\n        if (options.argumentAxis.zoom) {\n          var canZoom = chart._argumentAxes.some(axis => {\n            if (checkCoords(canvasToRect(axis.getCanvas()), coords) || axis.coordsIn(coords.x, coords.y)) {\n              return true;\n            }\n\n            return false;\n          });\n\n          axesZoomed |= canZoom && zoomAxes(e, chart._argumentAxes, getRange, e.delta > 0, {\n            coord: rotated ? coords.y : coords.x\n          }, chart.getArgumentAxis());\n        }\n\n        if (axesZoomed) {\n          chart._requestChange([\"VISUAL_RANGE\"]);\n\n          if (targetAxes && isAxisAvailablePanning(targetAxes) || !targetAxes && zoomAndPan.panningVisualRangeEnabled()) {\n            preventDefaults(e);\n          }\n        }\n      },\n      cleanup: function () {\n        renderer.root.off(EVENTS_NS);\n        zoomAndPan.actionData && zoomAndPan.actionData.rect && zoomAndPan.actionData.rect.dispose();\n        zoomAndPan.actionData = null;\n        renderer.root.css({\n          \"touch-action\": \"\",\n          \"-ms-touch-action\": \"\"\n        });\n      },\n      setup: function (options) {\n        zoomAndPan.cleanup();\n\n        if (!options.argumentAxis.pan) {\n          renderer.root.on(SCROLL_BAR_START_EVENT_NAME, cancelEvent);\n        }\n\n        if (options.argumentAxis.none && options.valueAxis.none) {\n          return;\n        }\n\n        zoomAndPan.options = options;\n\n        if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowMouseWheel) {\n          renderer.root.on(wheelEvent + EVENTS_NS, zoomAndPan.mouseWheelHandler);\n        }\n\n        if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowTouchGestures) {\n          renderer.root.on(PINCH_START_EVENT_NAME, {\n            passive: false\n          }, zoomAndPan.pinchStartHandler).on(PINCH_EVENT_NAME, {\n            passive: false\n          }, zoomAndPan.pinchHandler).on(PINCH_END_EVENT_NAME, zoomAndPan.pinchEndHandler);\n        }\n\n        renderer.root.on(DRAG_START_EVENT_NAME, {\n          immediate: true,\n          passive: false\n        }, zoomAndPan.dragStartHandler).on(DRAG_EVENT_NAME, {\n          immediate: true,\n          passive: false\n        }, zoomAndPan.dragHandler).on(DRAG_END_EVENT_NAME, zoomAndPan.dragEndHandler);\n        renderer.root.on(SCROLL_BAR_START_EVENT_NAME, function (e) {\n          zoomAndPan.actionData = {\n            valueAxes: [],\n            offset: {\n              x: 0,\n              y: 0\n            },\n            center: {\n              x: 0,\n              y: 0\n            }\n          };\n          preventDefaults(e);\n          startAxesViewportChanging(zoomAndPan, \"pan\", e);\n        }).on(SCROLL_BAR_MOVE_EVENT_NAME, function (e) {\n          preventDefaults(e);\n          axesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag, e => e.offset);\n        }).on(SCROLL_BAR_END_EVENT_NAME, function (e) {\n          preventDefaults(e);\n          finishAxesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag);\n          zoomAndPan.actionData = null;\n        });\n      },\n      panningVisualRangeEnabled: function () {\n        return isAxisAvailablePanning(chart._valueAxes) || isAxisAvailablePanning(chart._argumentAxes);\n      }\n    };\n    this._zoomAndPan = zoomAndPan;\n  },\n  members: {\n    _setupZoomAndPan: function () {\n      this._zoomAndPan.setup(this._themeManager.getOptions(\"zoomAndPan\"));\n    }\n  },\n  dispose: function () {\n    this._zoomAndPan.cleanup();\n  },\n  customize: function (constructor) {\n    constructor.addChange({\n      code: \"ZOOM_AND_PAN\",\n      handler: function () {\n        this._setupZoomAndPan();\n      },\n      isThemeDependent: true,\n      isOptionChange: true,\n      option: \"zoomAndPan\"\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"module"}