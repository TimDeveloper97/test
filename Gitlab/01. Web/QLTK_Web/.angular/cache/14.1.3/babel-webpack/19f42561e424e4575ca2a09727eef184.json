{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/html_editor/modules/toolbar.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport Quill from \"devextreme-quill\";\nimport $ from \"../../../core/renderer\";\nimport BaseModule from \"./base\";\nimport Toolbar from \"../../toolbar\";\nimport \"../../select_box\";\nimport \"../../color_box/color_view\";\nimport \"../../number_box\";\nimport errors from \"../../widget/ui.errors\";\nimport WidgetCollector from \"./widget_collector\";\nimport { each } from \"../../../core/utils/iterator\";\nimport { isString, isObject, isDefined, isEmptyObject } from \"../../../core/utils/type\";\nimport { extend } from \"../../../core/utils/extend\";\nimport localizationMessage from \"../../../localization/message\";\nimport { titleize, camelize } from \"../../../core/utils/inflector\";\nimport eventsEngine from \"../../../events/core/events_engine\";\nimport { addNamespace } from \"../../../events/utils/index\";\nimport { getTableFormats, TABLE_OPERATIONS } from \"../utils/table_helper\";\nimport { getFormatHandlers, getDefaultClickHandler, ICON_MAP, applyFormat } from \"../utils/toolbar_helper\";\nvar ToolbarModule = BaseModule;\n\nif (Quill) {\n  var TOOLBAR_WRAPPER_CLASS = \"dx-htmleditor-toolbar-wrapper\";\n  var TOOLBAR_CLASS = \"dx-htmleditor-toolbar\";\n  var TOOLBAR_FORMAT_WIDGET_CLASS = \"dx-htmleditor-toolbar-format\";\n  var TOOLBAR_SEPARATOR_CLASS = \"dx-htmleditor-toolbar-separator\";\n  var TOOLBAR_MENU_SEPARATOR_CLASS = \"dx-htmleditor-toolbar-menu-separator\";\n  var ACTIVE_FORMAT_CLASS = \"dx-format-active\";\n  var ICON_CLASS = \"dx-icon\";\n  var SELECTION_CHANGE_EVENT = \"selection-change\";\n  var USER_ACTION = \"user\";\n  var SILENT_ACTION = \"silent\";\n  var FORMAT_HOTKEYS = {\n    66: \"bold\",\n    73: \"italic\",\n    85: \"underline\"\n  };\n  var KEY_CODES = {\n    b: 66,\n    i: 73,\n    u: 85\n  };\n\n  var localize = name => localizationMessage.format(\"dxHtmlEditor-\".concat(camelize(name)));\n\n  var localizeValue = (value, name) => {\n    if (\"header\" === name) {\n      var isHeaderValue = isDefined(value) && false !== value;\n      return isHeaderValue ? \"\".concat(localize(\"heading\"), \" \").concat(value) : localize(\"normalText\");\n    }\n\n    return localize(value) || value;\n  };\n\n  ToolbarModule = class extends BaseModule {\n    constructor(quill, options) {\n      super(quill, options);\n      this._toolbarWidgets = new WidgetCollector();\n      this._formatHandlers = getFormatHandlers(this);\n      this._tableFormats = getTableFormats(quill);\n\n      if (isDefined(options.items)) {\n        this._addCallbacks();\n\n        this._renderToolbar();\n\n        this.quill.on(\"editor-change\", (eventName, newValue, oldValue, eventSource) => {\n          var isSilentMode = eventSource === SILENT_ACTION && isEmptyObject(this.quill.getFormat());\n\n          if (!isSilentMode) {\n            var isSelectionChanged = eventName === SELECTION_CHANGE_EVENT;\n\n            this._updateToolbar(isSelectionChanged);\n          }\n        });\n      }\n    }\n\n    _addCallbacks() {\n      this.addCleanCallback(this.clean.bind(this));\n      this.editorInstance.addContentInitializedCallback(this.updateHistoryWidgets.bind(this));\n    }\n\n    _updateToolbar(isSelectionChanged) {\n      this.updateFormatWidgets(isSelectionChanged);\n      this.updateHistoryWidgets();\n      this.updateTableWidgets();\n    }\n\n    _updateFormatWidget(name, isApplied, formats) {\n      var widget = this._toolbarWidgets.getByName(name);\n\n      if (!widget) {\n        return;\n      }\n\n      if (isApplied) {\n        this._markActiveFormatWidget(name, widget, formats);\n      } else {\n        this._resetFormatWidget(name, widget);\n\n        if (Object.prototype.hasOwnProperty.call(name)) {\n          delete formats[name];\n        }\n      }\n\n      this._toggleClearFormatting(isApplied || !isEmptyObject(formats));\n    }\n\n    _renderToolbar() {\n      var container = this.options.container || this._getContainer();\n\n      this._$toolbar = $(\"<div>\").addClass(TOOLBAR_CLASS).appendTo(container);\n      this._$toolbarContainer = $(container).addClass(TOOLBAR_WRAPPER_CLASS);\n      eventsEngine.on(this._$toolbarContainer, addNamespace(\"mousedown\", this.editorInstance.NAME), e => {\n        e.preventDefault();\n      });\n\n      this._subscribeFormatHotKeys();\n\n      this.toolbarInstance = this.editorInstance._createComponent(this._$toolbar, Toolbar, this.toolbarConfig);\n      this.editorInstance.on(\"optionChanged\", _ref => {\n        var {\n          name: name\n        } = _ref;\n\n        if (\"readOnly\" === name || \"disabled\" === name) {\n          this.toolbarInstance.option(\"disabled\", this.isInteractionDisabled);\n        }\n      });\n    }\n\n    get toolbarConfig() {\n      return {\n        dataSource: this._prepareToolbarItems(),\n        disabled: this.isInteractionDisabled,\n        menuContainer: this._$toolbarContainer,\n        multiline: this.isMultilineMode()\n      };\n    }\n\n    get isInteractionDisabled() {\n      return this.editorInstance.option(\"readOnly\") || this.editorInstance.option(\"disabled\");\n    }\n\n    isMultilineMode() {\n      var _this$options$multili;\n\n      return null !== (_this$options$multili = this.options.multiline) && void 0 !== _this$options$multili ? _this$options$multili : true;\n    }\n\n    clean() {\n      this._toolbarWidgets.clear();\n\n      if (this._$toolbarContainer) {\n        this._$toolbarContainer.empty().removeClass(TOOLBAR_WRAPPER_CLASS);\n      }\n    }\n\n    repaint() {\n      this.toolbarInstance && this.toolbarInstance.repaint();\n    }\n\n    _getContainer() {\n      var $container = $(\"<div>\");\n      this.editorInstance.$element().prepend($container);\n      return $container;\n    }\n\n    _detectRenamedOptions(item) {\n      if (isObject(item)) {\n        each([{\n          newName: \"name\",\n          oldName: \"formatName\"\n        }, {\n          newName: \"acceptedValues\",\n          oldName: \"formatValues\"\n        }], (index, optionName) => {\n          if (Object.prototype.hasOwnProperty.call(item, optionName.oldName)) {\n            errors.log(\"W1016\", optionName.oldName, optionName.newName);\n          }\n        });\n      }\n    }\n\n    _subscribeFormatHotKeys() {\n      this.quill.keyboard.addBinding({\n        which: KEY_CODES.b,\n        shortKey: true\n      }, this._handleFormatHotKey.bind(this));\n      this.quill.keyboard.addBinding({\n        which: KEY_CODES.i,\n        shortKey: true\n      }, this._handleFormatHotKey.bind(this));\n      this.quill.keyboard.addBinding({\n        which: KEY_CODES.u,\n        shortKey: true\n      }, this._handleFormatHotKey.bind(this));\n    }\n\n    _handleFormatHotKey(range, context, _ref2) {\n      var {\n        which: which\n      } = _ref2;\n      var formatName = FORMAT_HOTKEYS[which];\n\n      this._updateButtonState(formatName);\n    }\n\n    _updateButtonState(formatName) {\n      var formatWidget = this._toolbarWidgets.getByName(formatName);\n\n      var currentFormat = this.quill.getFormat();\n      var formatValue = currentFormat[formatName];\n\n      if (formatValue) {\n        this._markActiveFormatWidget(formatName, formatWidget, currentFormat);\n      } else {\n        this._resetFormatWidget(formatName, formatWidget);\n      }\n    }\n\n    _prepareToolbarItems() {\n      var resultItems = [];\n      each(this.options.items, (index, item) => {\n        var newItem;\n\n        this._detectRenamedOptions(item);\n\n        if (isObject(item)) {\n          newItem = this._handleObjectItem(item);\n        } else if (isString(item)) {\n          var buttonItemConfig = this._prepareButtonItemConfig(item);\n\n          newItem = this._getToolbarItem(buttonItemConfig);\n        }\n\n        if (newItem) {\n          resultItems.push(newItem);\n        }\n      });\n      return resultItems;\n    }\n\n    _handleObjectItem(item) {\n      if (item.name && item.acceptedValues && this._isAcceptableItem(item.widget, \"dxSelectBox\")) {\n        var selectItemConfig = this._prepareSelectItemConfig(item);\n\n        return this._getToolbarItem(selectItemConfig);\n      } else if (item.name && this._isAcceptableItem(item.widget, \"dxButton\")) {\n        var defaultButtonItemConfig = this._prepareButtonItemConfig(item.name);\n\n        var buttonItemConfig = extend(true, defaultButtonItemConfig, item);\n        return this._getToolbarItem(buttonItemConfig);\n      } else {\n        return this._getToolbarItem(item);\n      }\n    }\n\n    _isAcceptableItem(widget, acceptableWidgetName) {\n      return !widget || widget === acceptableWidgetName;\n    }\n\n    _prepareButtonItemConfig(name) {\n      var _ICON_MAP$name;\n\n      var iconName = null !== (_ICON_MAP$name = ICON_MAP[name]) && void 0 !== _ICON_MAP$name ? _ICON_MAP$name : name;\n      var buttonText = titleize(name);\n      return {\n        widget: \"dxButton\",\n        name: name,\n        options: {\n          hint: localize(buttonText),\n          text: localize(buttonText),\n          icon: iconName.toLowerCase(),\n          onClick: this._formatHandlers[name] || getDefaultClickHandler(this, name),\n          stylingMode: \"text\"\n        },\n        showText: \"inMenu\"\n      };\n    }\n\n    _prepareSelectItemConfig(item) {\n      var {\n        name: name,\n        acceptedValues: acceptedValues\n      } = item;\n      return extend(true, {\n        widget: \"dxSelectBox\",\n        name: name,\n        options: {\n          stylingMode: \"filled\",\n          dataSource: acceptedValues,\n          displayExpr: value => localizeValue(value, name),\n          placeholder: localize(name),\n          onValueChanged: e => {\n            if (!this._isReset) {\n              this._hideAdaptiveMenu();\n\n              applyFormat(this, [name, e.value, USER_ACTION], e.event);\n\n              this._setValueSilent(e.component, e.value);\n            }\n          }\n        }\n      }, item);\n    }\n\n    _hideAdaptiveMenu() {\n      if (this.toolbarInstance.option(\"overflowMenuVisible\")) {\n        this.toolbarInstance.option(\"overflowMenuVisible\", false);\n      }\n    }\n\n    _getToolbarItem(item) {\n      var baseItem = {\n        options: {\n          onInitialized: e => {\n            if (item.name) {\n              e.component.$element().addClass(TOOLBAR_FORMAT_WIDGET_CLASS);\n              e.component.$element().toggleClass(\"dx-\".concat(item.name.toLowerCase(), \"-format\"), !!item.name);\n\n              this._toolbarWidgets.add(item.name, e.component);\n            }\n          }\n        }\n      };\n      var multilineItem = this.isMultilineMode() ? {\n        location: \"before\",\n        locateInMenu: \"never\"\n      } : {};\n      return extend(true, {\n        location: \"before\",\n        locateInMenu: \"auto\"\n      }, this._getDefaultConfig(item.name), item, baseItem, multilineItem);\n    }\n\n    _getDefaultItemsConfig() {\n      return {\n        clear: {\n          options: {\n            disabled: true\n          }\n        },\n        undo: {\n          options: {\n            disabled: true\n          }\n        },\n        redo: {\n          options: {\n            disabled: true\n          }\n        },\n        insertRowAbove: {\n          options: {\n            disabled: true\n          }\n        },\n        insertRowBelow: {\n          options: {\n            disabled: true\n          }\n        },\n        insertHeaderRow: {\n          options: {\n            disabled: true\n          }\n        },\n        insertColumnLeft: {\n          options: {\n            disabled: true\n          }\n        },\n        insertColumnRight: {\n          options: {\n            disabled: true\n          }\n        },\n        deleteRow: {\n          options: {\n            disabled: true\n          }\n        },\n        deleteColumn: {\n          options: {\n            disabled: true\n          }\n        },\n        deleteTable: {\n          options: {\n            disabled: true\n          }\n        },\n        cellProperties: {\n          options: {\n            disabled: true\n          }\n        },\n        tableProperties: {\n          options: {\n            disabled: true\n          }\n        },\n        separator: {\n          template: (data, index, element) => {\n            $(element).addClass(TOOLBAR_SEPARATOR_CLASS);\n          },\n          menuItemTemplate: (data, index, element) => {\n            $(element).addClass(TOOLBAR_MENU_SEPARATOR_CLASS);\n          }\n        }\n      };\n    }\n\n    _getDefaultConfig(name) {\n      return this._getDefaultItemsConfig()[name];\n    }\n\n    updateHistoryWidgets() {\n      var historyModule = this.quill.history;\n\n      if (!historyModule) {\n        return;\n      }\n\n      var {\n        undo: undoOps,\n        redo: redoOps\n      } = historyModule.stack;\n\n      this._updateManipulationWidget(this._toolbarWidgets.getByName(\"undo\"), Boolean(undoOps.length));\n\n      this._updateManipulationWidget(this._toolbarWidgets.getByName(\"redo\"), Boolean(redoOps.length));\n    }\n\n    updateTableWidgets() {\n      var table = this.quill.getModule(\"table\");\n\n      if (!table) {\n        return;\n      }\n\n      var selection = this.quill.getSelection();\n      var formats = selection && this.quill.getFormat(selection) || {};\n\n      var isTableOperationsEnabled = this._tableFormats.some(format => Boolean(formats[format]));\n\n      TABLE_OPERATIONS.forEach(operationName => {\n        var isInsertTable = \"insertTable\" === operationName;\n\n        var widget = this._toolbarWidgets.getByName(operationName);\n\n        this._updateManipulationWidget(widget, isInsertTable ? !isTableOperationsEnabled : isTableOperationsEnabled);\n      });\n    }\n\n    _updateManipulationWidget(widget, isOperationEnabled) {\n      if (!widget) {\n        return;\n      }\n\n      widget.option(\"disabled\", !isOperationEnabled);\n    }\n\n    updateFormatWidgets(isResetRequired) {\n      var selection = this.quill.getSelection();\n\n      if (!selection) {\n        return;\n      }\n\n      var formats = this.quill.getFormat(selection);\n      var hasFormats = !isEmptyObject(formats);\n\n      if (!hasFormats || isResetRequired) {\n        this._resetFormatWidgets();\n      }\n\n      for (var formatName in formats) {\n        var widgetName = this._getFormatWidgetName(formatName, formats);\n\n        var formatWidget = this._toolbarWidgets.getByName(widgetName) || this._toolbarWidgets.getByName(formatName);\n\n        if (!formatWidget) {\n          continue;\n        }\n\n        this._markActiveFormatWidget(formatName, formatWidget, formats);\n      }\n\n      this._toggleClearFormatting(hasFormats || selection.length > 1);\n    }\n\n    _markActiveFormatWidget(name, widget, formats) {\n      if (this._isColorFormat(name)) {\n        this._updateColorWidget(name, formats[name]);\n      }\n\n      if (\"value\" in widget.option()) {\n        this._setValueSilent(widget, formats[name]);\n      } else {\n        widget.$element().addClass(ACTIVE_FORMAT_CLASS);\n      }\n    }\n\n    _toggleClearFormatting(hasFormats) {\n      var clearWidget = this._toolbarWidgets.getByName(\"clear\");\n\n      if (clearWidget) {\n        clearWidget.option(\"disabled\", !hasFormats);\n      }\n    }\n\n    _isColorFormat(name) {\n      return \"color\" === name || \"background\" === name;\n    }\n\n    _updateColorWidget(name, color) {\n      var formatWidget = this._toolbarWidgets.getByName(name);\n\n      if (!formatWidget) {\n        return;\n      }\n\n      formatWidget.$element().find(\".\".concat(ICON_CLASS)).css(\"borderBottomColor\", color || \"transparent\");\n    }\n\n    _getFormatWidgetName(name, formats) {\n      var widgetName;\n\n      switch (name) {\n        case \"align\":\n          widgetName = name + titleize(formats[name]);\n          break;\n\n        case \"list\":\n          widgetName = formats[name] + titleize(name);\n          break;\n\n        case \"code-block\":\n          widgetName = \"codeBlock\";\n          break;\n\n        case \"script\":\n          widgetName = formats[name] + name;\n          break;\n\n        case \"imageSrc\":\n          widgetName = \"image\";\n          break;\n\n        default:\n          widgetName = name;\n      }\n\n      return widgetName;\n    }\n\n    _setValueSilent(widget, value) {\n      this._isReset = true;\n      widget.option(\"value\", value);\n      this._isReset = false;\n    }\n\n    _resetFormatWidgets() {\n      this._toolbarWidgets.each((name, widget) => {\n        this._resetFormatWidget(name, widget);\n      });\n    }\n\n    _resetFormatWidget(name, widget) {\n      widget.$element().removeClass(ACTIVE_FORMAT_CLASS);\n\n      if (this._isColorFormat(name)) {\n        this._updateColorWidget(name);\n      }\n\n      if (\"clear\" === name) {\n        widget.option(\"disabled\", true);\n      }\n\n      if (\"dxSelectBox\" === widget.NAME) {\n        this._setValueSilent(widget, null);\n      }\n    }\n\n    addClickHandler(name, handler) {\n      this._formatHandlers[name] = handler;\n\n      var formatWidget = this._toolbarWidgets.getByName(name);\n\n      if (formatWidget && \"dxButton\" === formatWidget.NAME) {\n        formatWidget.option(\"onClick\", handler);\n      }\n    }\n\n  };\n}\n\nexport default ToolbarModule;","map":null,"metadata":{},"sourceType":"module"}