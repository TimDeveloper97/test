{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/grid_core/ui.grid_core.virtual_scrolling_core.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport { getWindow } from \"../../core/utils/window\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport browser from \"../../core/utils/browser\";\nimport positionUtils from \"../../animation/position\";\nimport { each } from \"../../core/utils/iterator\";\nimport Class from \"../../core/class\";\nimport { Deferred } from \"../../core/utils/deferred\";\nimport Callbacks from \"../../core/utils/callbacks\";\nimport { VirtualDataLoader } from \"./ui.grid.core.virtual_data_loader\";\nimport { isDefined } from \"../../core/utils/type\";\nimport gridCoreUtils from \"./ui.grid_core.utils\";\nvar SCROLLING_MODE_INFINITE = \"infinite\";\nvar SCROLLING_MODE_VIRTUAL = \"virtual\";\nvar LEGACY_SCROLLING_MODE = \"scrolling.legacyMode\";\n\nvar _isVirtualMode = that => that.option(\"scrolling.mode\") === SCROLLING_MODE_VIRTUAL || that._isVirtual;\n\nvar _isAppendMode = that => that.option(\"scrolling.mode\") === SCROLLING_MODE_INFINITE && !that._isVirtual;\n\nexport function subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {\n  var $scrollElement;\n  var scrollableArray = [];\n  var scrollToArray = [];\n  var disposeArray = [];\n  $targetElement = $targetElement || $element;\n\n  function getElementOffset(scrollable) {\n    var $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;\n    var scrollableOffset = positionUtils.offset($scrollableElement);\n\n    if (!scrollableOffset) {\n      return $element.offset().top;\n    }\n\n    return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top);\n  }\n\n  var widgetScrollStrategy = {\n    on: function (scrollable, eventName, handler) {\n      scrollable.on(\"scroll\", handler);\n    },\n    off: function (scrollable, eventName, handler) {\n      scrollable.off(\"scroll\", handler);\n    }\n  };\n\n  function subscribeToScrollEvents($scrollElement) {\n    var isDocument = \"#document\" === $scrollElement.get(0).nodeName;\n    var scrollable = $scrollElement.data(\"dxScrollable\");\n    var eventsStrategy = widgetScrollStrategy;\n\n    if (!scrollable) {\n      scrollable = isDocument && $(getWindow()) || \"auto\" === $scrollElement.css(\"overflowY\") && $scrollElement;\n      eventsStrategy = eventsEngine;\n\n      if (!scrollable) {\n        return;\n      }\n    }\n\n    var handler = function (scrollable) {\n      return function () {\n        var scrollTop = scrollable.scrollTop() - getElementOffset(scrollable);\n        scrollTop = scrollTop > 0 ? scrollTop : 0;\n        scrollChangedHandler(scrollTop);\n      };\n    }(scrollable);\n\n    eventsStrategy.on(scrollable, \"scroll\", handler);\n    scrollToArray.push(function (pos) {\n      var topOffset = getElementOffset(scrollable);\n      var scrollMethod = scrollable.scrollTo ? \"scrollTo\" : \"scrollTop\";\n\n      if (pos - topOffset >= 0) {\n        scrollable[scrollMethod](pos + topOffset);\n      }\n    });\n    scrollableArray.push(scrollable);\n    disposeArray.push(function () {\n      eventsStrategy.off(scrollable, \"scroll\", handler);\n    });\n  }\n\n  for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = $scrollElement.parent()) {\n    subscribeToScrollEvents($scrollElement);\n  }\n\n  return {\n    scrollTo: function (pos) {\n      each(scrollToArray, function (_, scrollTo) {\n        scrollTo(pos);\n      });\n    },\n    dispose: function () {\n      each(disposeArray, function (_, dispose) {\n        dispose();\n      });\n    }\n  };\n}\nexport var VirtualScrollController = Class.inherit(function () {\n  var members = {\n    ctor: function (component, dataOptions, isVirtual) {\n      this._dataOptions = dataOptions;\n      this.component = component;\n      this._viewportSize = false === component.option(LEGACY_SCROLLING_MODE) ? 15 : 0;\n      this._viewportItemSize = 20;\n      this._viewportItemIndex = 0;\n      this._position = 0;\n      this._isScrollingBack = false;\n      this._contentSize = 0;\n      this._itemSizes = {};\n      this._sizeRatio = 1;\n      this._isVirtual = isVirtual;\n      this.positionChanged = Callbacks();\n      this._dataLoader = new VirtualDataLoader(this, this._dataOptions);\n    },\n    getItemSizes: function () {\n      return this._itemSizes;\n    },\n    option: function () {\n      return this.component.option.apply(this.component, arguments);\n    },\n    isVirtual: function () {\n      return this._isVirtual;\n    },\n    virtualItemsCount: function () {\n      if (_isVirtualMode(this)) {\n        var dataOptions = this._dataOptions;\n        var totalItemsCount = dataOptions.totalItemsCount();\n\n        if (false === this.option(LEGACY_SCROLLING_MODE) && -1 !== totalItemsCount) {\n          var viewportParams = this.getViewportParams();\n          var loadedOffset = dataOptions.loadedOffset();\n          var loadedItemCount = dataOptions.loadedItemCount();\n          var skip = Math.max(viewportParams.skip, loadedOffset);\n          var take = Math.min(viewportParams.take, loadedItemCount);\n          var endItemsCount = Math.max(totalItemsCount - (skip + take), 0);\n          return {\n            begin: skip,\n            end: endItemsCount\n          };\n        }\n\n        return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments);\n      }\n    },\n    getScrollingTimeout: function () {\n      var renderAsync = this.option(\"scrolling.renderAsync\");\n      var scrollingTimeout = 0;\n\n      if (!isDefined(renderAsync)) {\n        scrollingTimeout = Math.min(this.option(\"scrolling.timeout\") || 0, this._dataOptions.changingDuration());\n\n        if (scrollingTimeout < this.option(\"scrolling.renderingThreshold\")) {\n          scrollingTimeout = this.option(\"scrolling.minTimeout\") || 0;\n        }\n      } else if (renderAsync) {\n        var _this$option;\n\n        scrollingTimeout = null !== (_this$option = this.option(\"scrolling.timeout\")) && void 0 !== _this$option ? _this$option : 0;\n      }\n\n      return scrollingTimeout;\n    },\n    setViewportPosition: function (position) {\n      var result = new Deferred();\n      var scrollingTimeout = this.getScrollingTimeout();\n      clearTimeout(this._scrollTimeoutID);\n\n      if (scrollingTimeout > 0) {\n        this._scrollTimeoutID = setTimeout(() => {\n          this._setViewportPositionCore(position);\n\n          result.resolve();\n        }, scrollingTimeout);\n      } else {\n        this._setViewportPositionCore(position);\n\n        result.resolve();\n      }\n\n      return result.promise();\n    },\n    getViewportPosition: function () {\n      return this._position;\n    },\n    getItemIndexByPosition: function (position) {\n      var _position;\n\n      position = null !== (_position = position) && void 0 !== _position ? _position : this._position;\n      var defaultItemSize = this.getItemSize();\n      var offset = 0;\n      var itemOffset = 0;\n      var itemOffsetsWithSize = Object.keys(this._itemSizes).concat(-1);\n\n      for (var i = 0; i < itemOffsetsWithSize.length && offset < position; i++) {\n        var itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);\n        var itemOffsetDiff = (position - offset) / defaultItemSize;\n\n        if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {\n          itemOffset += itemOffsetDiff;\n          break;\n        } else {\n          itemOffsetDiff = itemOffsetWithSize - itemOffset;\n          offset += itemOffsetDiff * defaultItemSize;\n          itemOffset += itemOffsetDiff;\n        }\n\n        var itemSize = this._itemSizes[itemOffsetWithSize];\n        offset += itemSize;\n        itemOffset += offset < position ? 1 : (position - offset + itemSize) / itemSize;\n      }\n\n      return Math.round(50 * itemOffset) / 50;\n    },\n    isScrollingBack: function () {\n      return this._isScrollingBack;\n    },\n    _setViewportPositionCore: function (position) {\n      var prevPosition = this._position || 0;\n      this._position = position;\n\n      if (prevPosition !== this._position) {\n        this._isScrollingBack = this._position < prevPosition;\n      }\n\n      var itemIndex = this.getItemIndexByPosition();\n      var result = this.setViewportItemIndex(itemIndex);\n      this.positionChanged.fire();\n      return result;\n    },\n    setContentItemSizes: function (sizes) {\n      var virtualItemsCount = this.virtualItemsCount();\n      this._contentSize = sizes.reduce((a, b) => a + b, 0);\n\n      if (virtualItemsCount) {\n        sizes.forEach((size, index) => {\n          this._itemSizes[virtualItemsCount.begin + index] = size;\n        });\n\n        var virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + this.itemsCount()) * this._viewportItemSize;\n\n        var contentHeightLimit = gridCoreUtils.getContentHeightLimit(browser);\n\n        if (virtualContentSize > contentHeightLimit) {\n          this._sizeRatio = contentHeightLimit / virtualContentSize;\n        } else {\n          this._sizeRatio = 1;\n        }\n      }\n    },\n    getItemSize: function () {\n      return this._viewportItemSize * this._sizeRatio;\n    },\n    getItemOffset: function (itemIndex, isEnd) {\n      var virtualItemsCount = this.virtualItemsCount();\n      var itemCount = itemIndex;\n\n      if (!virtualItemsCount) {\n        return 0;\n      }\n\n      var offset = 0;\n\n      var totalItemsCount = this._dataOptions.totalItemsCount();\n\n      Object.keys(this._itemSizes).forEach(currentItemIndex => {\n        if (!itemCount) {\n          return;\n        }\n\n        if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {\n          offset += this._itemSizes[currentItemIndex];\n          itemCount--;\n        }\n      });\n      return Math.floor(offset + itemCount * this._viewportItemSize * this._sizeRatio);\n    },\n    getContentOffset: function (type) {\n      var isEnd = \"end\" === type;\n      var virtualItemsCount = this.virtualItemsCount();\n\n      if (!virtualItemsCount) {\n        return 0;\n      }\n\n      return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd);\n    },\n    getVirtualContentSize: function () {\n      var virtualItemsCount = this.virtualItemsCount();\n      return virtualItemsCount ? this.getContentOffset(\"begin\") + this.getContentOffset(\"end\") + this._contentSize : 0;\n    },\n    getViewportItemIndex: function () {\n      return this._viewportItemIndex;\n    },\n    setViewportItemIndex: function (itemIndex) {\n      this._viewportItemIndex = itemIndex;\n\n      if (false === this.option(LEGACY_SCROLLING_MODE)) {\n        return;\n      }\n\n      return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments);\n    },\n    viewportItemSize: function (size) {\n      if (void 0 !== size) {\n        this._viewportItemSize = size;\n      }\n\n      return this._viewportItemSize;\n    },\n    viewportSize: function (size) {\n      if (void 0 !== size) {\n        this._viewportSize = size;\n      }\n\n      return this._viewportSize;\n    },\n    viewportHeight: function (height) {\n      var begin = this.getItemIndexByPosition();\n      var end = this.getItemIndexByPosition(this._position + height);\n      this.viewportSize(Math.ceil(end - begin));\n\n      if (this._viewportItemIndex !== begin) {\n        this._setViewportPositionCore(this._position);\n      }\n    },\n    reset: function (isRefresh) {\n      this._dataLoader.reset();\n\n      if (!isRefresh) {\n        this._itemSizes = {};\n      }\n    },\n    subscribeToWindowScrollEvents: function ($element) {\n      this._windowScroll = this._windowScroll || subscribeToExternalScrollers($element, scrollTop => {\n        if (this.viewportItemSize()) {\n          this.setViewportPosition(scrollTop);\n        }\n      });\n    },\n    dispose: function () {\n      clearTimeout(this._scrollTimeoutID);\n      this._windowScroll && this._windowScroll.dispose();\n      this._windowScroll = null;\n    },\n    scrollTo: function (pos) {\n      this._windowScroll && this._windowScroll.scrollTo(pos);\n    },\n    isVirtualMode: function () {\n      return _isVirtualMode(this);\n    },\n    isAppendMode: function () {\n      return _isAppendMode(this);\n    },\n    getViewportParams: function () {\n      var _this$option2;\n\n      var virtualMode = this.option(\"scrolling.mode\") === SCROLLING_MODE_VIRTUAL;\n\n      var totalItemsCount = this._dataOptions.totalItemsCount();\n\n      var hasKnownLastPage = this._dataOptions.hasKnownLastPage();\n\n      var topIndex = hasKnownLastPage && this._viewportItemIndex > totalItemsCount ? totalItemsCount : this._viewportItemIndex;\n      var bottomIndex = this._viewportSize + topIndex;\n      var maxGap = this.option(\"scrolling.prerenderedRowChunkSize\") || 1;\n      var isScrollingBack = this.isScrollingBack();\n      var minGap = null !== (_this$option2 = this.option(\"scrolling.prerenderedRowCount\")) && void 0 !== _this$option2 ? _this$option2 : 1;\n      var topMinGap = isScrollingBack ? minGap : 0;\n      var bottomMinGap = isScrollingBack ? 0 : minGap;\n      var skip = Math.floor(Math.max(0, topIndex - topMinGap) / maxGap) * maxGap;\n      var take = Math.ceil((bottomIndex + bottomMinGap - skip) / maxGap) * maxGap;\n\n      if (virtualMode) {\n        var remainedItems = Math.max(0, totalItemsCount - skip);\n        take = Math.min(take, remainedItems);\n      }\n\n      return {\n        skip: skip,\n        take: take\n      };\n    },\n    itemsCount: function () {\n      var result = 0;\n\n      if (this.option(LEGACY_SCROLLING_MODE)) {\n        result = this._dataLoader.itemsCount.apply(this._dataLoader, arguments);\n      } else {\n        result = this._dataOptions.itemsCount();\n      }\n\n      return result;\n    }\n  };\n  [\"pageIndex\", \"beginPageIndex\", \"endPageIndex\", \"pageSize\", \"load\", \"loadIfNeed\", \"handleDataChanged\", \"getDelayDeferred\"].forEach(function (name) {\n    members[name] = function () {\n      return this._dataLoader[name].apply(this._dataLoader, arguments);\n    };\n  });\n  return members;\n}());","map":null,"metadata":{},"sourceType":"module"}