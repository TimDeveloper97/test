{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/drawer/ui.drawer.rendering.strategy.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { setWidth, setHeight } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport { animation } from \"./ui.drawer.animation\";\nimport { Deferred, when } from \"../../core/utils/deferred\";\n\nclass DrawerStrategy {\n  constructor(drawer) {\n    this._drawer = drawer;\n  }\n\n  getDrawerInstance() {\n    return this._drawer;\n  }\n\n  renderPanelContent(whenPanelContentRendered) {\n    var drawer = this.getDrawerInstance();\n\n    var template = drawer._getTemplate(drawer.option(\"template\"));\n\n    if (template) {\n      template.render({\n        container: drawer.content(),\n        onRendered: () => {\n          whenPanelContentRendered.resolve();\n        }\n      });\n    }\n  }\n\n  renderPosition(changePositionUsingFxAnimation, animationDuration) {\n    var whenPositionAnimationCompleted = new Deferred();\n    var whenShaderAnimationCompleted = new Deferred();\n    var drawer = this.getDrawerInstance();\n\n    if (changePositionUsingFxAnimation) {\n      when.apply($, [whenPositionAnimationCompleted, whenShaderAnimationCompleted]).done(() => {\n        drawer._animationCompleteHandler();\n      });\n    }\n\n    this._internalRenderPosition(changePositionUsingFxAnimation, whenPositionAnimationCompleted);\n\n    if (!changePositionUsingFxAnimation) {\n      drawer.resizeViewContent();\n    }\n\n    this.renderShaderVisibility(changePositionUsingFxAnimation, animationDuration, whenShaderAnimationCompleted);\n  }\n\n  _getPanelOffset(isDrawerOpened) {\n    var drawer = this.getDrawerInstance();\n    var size = drawer.isHorizontalDirection() ? drawer.getRealPanelWidth() : drawer.getRealPanelHeight();\n\n    if (isDrawerOpened) {\n      return -(size - drawer.getMaxSize());\n    } else {\n      return -(size - drawer.getMinSize());\n    }\n  }\n\n  _getPanelSize(isDrawerOpened) {\n    return isDrawerOpened ? this.getDrawerInstance().getMaxSize() : this.getDrawerInstance().getMinSize();\n  }\n\n  renderShaderVisibility(changePositionUsingFxAnimation, duration, whenAnimationCompleted) {\n    var drawer = this.getDrawerInstance();\n    var isShaderVisible = drawer.option(\"opened\");\n    var fadeConfig = isShaderVisible ? {\n      from: 0,\n      to: 1\n    } : {\n      from: 1,\n      to: 0\n    };\n\n    if (changePositionUsingFxAnimation) {\n      animation.fade($(drawer._$shader), fadeConfig, duration, () => {\n        this._drawer._toggleShaderVisibility(isShaderVisible);\n\n        whenAnimationCompleted.resolve();\n      });\n    } else {\n      drawer._toggleShaderVisibility(isShaderVisible);\n\n      drawer._$shader.css(\"opacity\", fadeConfig.to);\n    }\n  }\n\n  getPanelContent() {\n    return $(this.getDrawerInstance().content());\n  }\n\n  setPanelSize(calcFromRealPanelSize) {\n    this.refreshPanelElementSize(calcFromRealPanelSize);\n  }\n\n  refreshPanelElementSize(calcFromRealPanelSize) {\n    var drawer = this.getDrawerInstance();\n\n    var panelSize = this._getPanelSize(drawer.option(\"opened\"));\n\n    if (drawer.isHorizontalDirection()) {\n      setWidth($(drawer.content()), calcFromRealPanelSize ? drawer.getRealPanelWidth() : panelSize);\n    } else {\n      setHeight($(drawer.content()), calcFromRealPanelSize ? drawer.getRealPanelHeight() : panelSize);\n    }\n  }\n\n  isViewContentFirst() {\n    return false;\n  }\n\n  onPanelContentRendered() {}\n\n}\n\nexport default DrawerStrategy;","map":null,"metadata":{},"sourceType":"module"}