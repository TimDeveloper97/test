{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/time_panel_data_generator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nvar _excluded = [\"allDay\", \"startDate\", \"endDate\", \"groups\", \"groupIndex\", \"isFirstGroupCell\", \"isLastGroupCell\", \"index\"];\nimport { getIsGroupedAllDayPanel, getKeyByGroup } from \"../../../../renovation/ui/scheduler/workspaces/utils\";\nimport { getDisplayedRowCount } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { getTimePanelCellText } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/week\";\nexport class TimePanelDataGenerator {\n  constructor(viewDataGenerator) {\n    this._viewDataGenerator = viewDataGenerator;\n  }\n\n  getCompleteTimePanelMap(options, completeViewDataMap) {\n    var {\n      startViewDate: startViewDate,\n      cellDuration: cellDuration,\n      startDayHour: startDayHour,\n      isVerticalGrouping: isVerticalGrouping,\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      hoursInterval: hoursInterval,\n      endDayHour: endDayHour\n    } = options;\n\n    var rowCountInGroup = this._viewDataGenerator.getRowCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      hoursInterval: hoursInterval,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour\n    });\n\n    var cellCountInGroupRow = this._viewDataGenerator.getCellCount({\n      intervalCount: intervalCount,\n      currentDate: currentDate,\n      viewType: viewType,\n      hoursInterval: hoursInterval,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour\n    });\n\n    var allDayRowsCount = 0;\n    return completeViewDataMap.map((row, index) => {\n      var _row$ = row[0],\n          {\n        allDay: allDay,\n        startDate: startDate,\n        groups: groups,\n        groupIndex: groupIndex,\n        isFirstGroupCell: isFirstGroupCell,\n        isLastGroupCell: isLastGroupCell,\n        index: cellIndex\n      } = _row$,\n          restCellProps = _objectWithoutPropertiesLoose(_row$, _excluded);\n\n      if (allDay) {\n        allDayRowsCount += 1;\n      }\n\n      var timeIndex = (index - allDayRowsCount) % rowCountInGroup;\n      return _extends({}, restCellProps, {\n        startDate: startDate,\n        allDay: allDay,\n        text: getTimePanelCellText(timeIndex, startDate, startViewDate, cellDuration, startDayHour),\n        groups: isVerticalGrouping ? groups : void 0,\n        groupIndex: isVerticalGrouping ? groupIndex : void 0,\n        isFirstGroupCell: isVerticalGrouping && isFirstGroupCell,\n        isLastGroupCell: isVerticalGrouping && isLastGroupCell,\n        index: Math.floor(cellIndex / cellCountInGroupRow)\n      });\n    });\n  }\n\n  generateTimePanelData(completeTimePanelMap, options) {\n    var {\n      startRowIndex: startRowIndex,\n      rowCount: rowCount,\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      isGroupedAllDayPanel: isGroupedAllDayPanel,\n      isVerticalGrouping: isVerticalGrouping,\n      isAllDayPanelVisible: isAllDayPanelVisible\n    } = options;\n    var indexDifference = isVerticalGrouping || !isAllDayPanelVisible ? 0 : 1;\n    var correctedStartRowIndex = startRowIndex + indexDifference;\n    var displayedRowCount = getDisplayedRowCount(rowCount, completeTimePanelMap);\n    var timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount);\n    var timePanelData = {\n      topVirtualRowHeight: topVirtualRowHeight,\n      bottomVirtualRowHeight: bottomVirtualRowHeight,\n      isGroupedAllDayPanel: isGroupedAllDayPanel\n    };\n\n    var {\n      previousGroupedData: groupedData\n    } = this._generateTimePanelDataFromMap(timePanelMap, isVerticalGrouping);\n\n    timePanelData.groupedData = groupedData;\n    return timePanelData;\n  }\n\n  _generateTimePanelDataFromMap(timePanelMap, isVerticalGrouping) {\n    return timePanelMap.reduce((_ref, cellData) => {\n      var {\n        previousGroupIndex: previousGroupIndex,\n        previousGroupedData: previousGroupedData\n      } = _ref;\n      var currentGroupIndex = cellData.groupIndex;\n\n      if (currentGroupIndex !== previousGroupIndex) {\n        previousGroupedData.push({\n          dateTable: [],\n          isGroupedAllDayPanel: getIsGroupedAllDayPanel(!!cellData.allDay, isVerticalGrouping),\n          groupIndex: currentGroupIndex,\n          key: getKeyByGroup(currentGroupIndex, isVerticalGrouping)\n        });\n      }\n\n      if (cellData.allDay) {\n        previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData;\n      } else {\n        previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData);\n      }\n\n      return {\n        previousGroupIndex: currentGroupIndex,\n        previousGroupedData: previousGroupedData\n      };\n    }, {\n      previousGroupIndex: -1,\n      previousGroupedData: []\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}