{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/bubble_series.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { chart as lineChart } from \"./line_series\";\nimport { chart as scatterSeries } from \"./scatter_series\";\nimport { chart as areaChart } from \"./area_series\";\nimport { chart as barChart, polar as barPolar } from \"./bar_series\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { noop } from \"../../core/utils/common\";\nvar lineSeries = lineChart.line;\nvar areaSeries = areaChart.area;\nvar chartBarSeries = barChart.bar;\nvar polarBarSeries = barPolar.bar;\nvar _extend = extend;\nvar _each = each;\nvar _noop = noop;\nvar chart = {};\nchart.bubble = _extend({}, scatterSeries, {\n  _calculateErrorBars: _noop,\n  _getMainColor: chartBarSeries._getMainColor,\n  _createPointStyles: chartBarSeries._createPointStyles,\n  _updatePointsVisibility: chartBarSeries._updatePointsVisibility,\n  _getOptionsForPoint: chartBarSeries._getOptionsForPoint,\n  _applyMarkerClipRect: lineSeries._applyElementsClipRect,\n  _parsePointStyle: polarBarSeries._parsePointStyle,\n  _createLegendState: areaSeries._createLegendState,\n  _setMarkerGroupSettings: polarBarSeries._setMarkerGroupSettings,\n  areErrorBarsVisible: _noop,\n  _createErrorBarGroup: _noop,\n  _checkData: function (data, skippedFields) {\n    return scatterSeries._checkData.call(this, data, skippedFields, {\n      value: this.getValueFields()[0],\n      size: this.getSizeField()\n    });\n  },\n  _getPointDataSelector: function (data, options) {\n    var sizeField = this.getSizeField();\n\n    var baseGetter = scatterSeries._getPointDataSelector.call(this);\n\n    return data => {\n      var pointData = baseGetter(data);\n      pointData.size = data[sizeField];\n      return pointData;\n    };\n  },\n  _aggregators: {\n    avg(_ref, series) {\n      var {\n        data: data,\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd\n      } = _ref;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueField = series.getValueFields()[0];\n      var sizeField = series.getSizeField();\n      var aggregate = data.reduce((result, item) => {\n        result[0] += item[valueField];\n        result[1] += item[sizeField];\n        result[2]++;\n        return result;\n      }, [0, 0, 0]);\n      return {\n        [valueField]: aggregate[0] / aggregate[2],\n        [sizeField]: aggregate[1] / aggregate[2],\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n      };\n    }\n\n  },\n  getValueFields: function () {\n    return [this._options.valueField || \"val\"];\n  },\n  getSizeField: function () {\n    return this._options.sizeField || \"size\";\n  },\n  _animate: function () {\n    var that = this;\n    var lastPointIndex = that._drawnPoints.length - 1;\n    var labelsGroup = that._labelsGroup;\n\n    var labelAnimFunc = function () {\n      labelsGroup && labelsGroup.animate({\n        opacity: 1\n      }, {\n        duration: that._defaultDuration\n      });\n    };\n\n    _each(that._drawnPoints || [], function (i, p) {\n      p.animate(i === lastPointIndex ? labelAnimFunc : void 0, {\n        r: p.bubbleSize,\n        translateX: p.x,\n        translateY: p.y\n      });\n    });\n  },\n  _patchMarginOptions: function (options) {\n    options.processBubbleSize = true;\n    return options;\n  }\n});\nexport { chart };","map":null,"metadata":{},"sourceType":"module"}