{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/dataProvider/appointmentFilter.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport { getRecurrenceProcessor } from \"../../recurrence\";\nimport { wrapToArray } from \"../../../../core/utils/array\";\nimport { map, each } from \"../../../../core/utils/iterator\";\nimport { isFunction, isDefined } from \"../../../../core/utils/type\";\nimport query from \"../../../../data/query\";\nimport { createAppointmentAdapter } from \"../../appointmentAdapter\";\nimport { hasResourceValue } from \"../../../../renovation/ui/scheduler/resources/hasResourceValue\";\nimport { isDateAndTimeView as calculateIsDateAndTimeView, isTimelineView } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { getResourcesDataByGroups } from \"../../resources/utils\";\nimport { compareDateWithStartDayHour, compareDateWithEndDayHour, getAppointmentTakesSeveralDays, _appointmentPartInInterval, getRecurrenceException } from \"./utils\";\nimport getDatesWithoutTime from \"../../../../renovation/ui/scheduler/utils/filtering/getDatesWithoutTime\";\nimport { getAppointmentTakesAllDay } from \"../../../../renovation/ui/scheduler/appointment/utils/getAppointmentTakesAllDay\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar FilterStrategies = {\n  virtual: \"virtual\",\n  standard: \"standard\"\n};\nexport class AppointmentFilterBaseStrategy {\n  constructor(options) {\n    this.options = options;\n    this.dataAccessors = this.options.dataAccessors;\n\n    this._init();\n  }\n\n  get strategyName() {\n    return FilterStrategies.standard;\n  }\n\n  get timeZoneCalculator() {\n    return this.options.timeZoneCalculator;\n  }\n\n  get viewStartDayHour() {\n    return this.options.startDayHour;\n  }\n\n  get viewEndDayHour() {\n    return this.options.endDayHour;\n  }\n\n  get timezone() {\n    return this.options.timezone;\n  }\n\n  get firstDayOfWeek() {\n    return this.options.firstDayOfWeek;\n  }\n\n  get showAllDayPanel() {\n    return this.options.showAllDayPanel;\n  }\n\n  get loadedResources() {\n    return this._resolveOption(\"loadedResources\");\n  }\n\n  get supportAllDayRow() {\n    return this._resolveOption(\"supportAllDayRow\");\n  }\n\n  get viewType() {\n    return this._resolveOption(\"viewType\");\n  }\n\n  get viewDirection() {\n    return this._resolveOption(\"viewDirection\");\n  }\n\n  get dateRange() {\n    return this._resolveOption(\"dateRange\");\n  }\n\n  get groupCount() {\n    return this._resolveOption(\"groupCount\");\n  }\n\n  get viewDataProvider() {\n    return this._resolveOption(\"viewDataProvider\");\n  }\n\n  get allDayPanelMode() {\n    return this._resolveOption(\"allDayPanelMode\");\n  }\n\n  _resolveOption(name) {\n    var result = this.options[name];\n    return \"function\" === typeof result ? result() : result;\n  }\n\n  _init() {\n    this.setDataAccessors(this.dataAccessors);\n  }\n\n  filter(preparedItems) {\n    var dateRange = this.dateRange;\n    var allDay;\n\n    if (!this.showAllDayPanel && this.supportAllDayRow) {\n      allDay = false;\n    }\n\n    return this.filterLoadedAppointments({\n      startDayHour: this.viewStartDayHour,\n      endDayHour: this.viewEndDayHour,\n      viewStartDayHour: this.viewStartDayHour,\n      viewEndDayHour: this.viewEndDayHour,\n      min: dateRange[0],\n      max: dateRange[1],\n      resources: this.loadedResources,\n      allDay: allDay,\n      supportMultiDayAppointments: isTimelineView(this.viewType),\n      firstDayOfWeek: this.firstDayOfWeek\n    }, preparedItems);\n  }\n\n  hasAllDayAppointments(filteredItems, preparedItems) {\n    var adapters = filteredItems.map(item => createAppointmentAdapter(item, this.dataAccessors, this.timeZoneCalculator));\n    var result = false;\n    each(adapters, (_, item) => {\n      if (getAppointmentTakesAllDay(item, this.viewStartDayHour, this.viewEndDayHour, this.allDayPanelMode)) {\n        result = true;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  setDataAccessors(dataAccessors) {\n    this.dataAccessors = dataAccessors;\n  }\n\n  _createAllDayAppointmentFilter(filterOptions) {\n    var {\n      viewStartDayHour: viewStartDayHour,\n      viewEndDayHour: viewEndDayHour\n    } = filterOptions;\n    return [[appointment => getAppointmentTakesAllDay(appointment, viewStartDayHour, viewEndDayHour, this.allDayPanelMode)]];\n  }\n\n  _createCombinedFilter(filterOptions) {\n    var min = new Date(filterOptions.min);\n    var max = new Date(filterOptions.max);\n    var {\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      viewStartDayHour: viewStartDayHour,\n      viewEndDayHour: viewEndDayHour,\n      resources: resources,\n      firstDayOfWeek: firstDayOfWeek,\n      checkIntersectViewport: checkIntersectViewport,\n      supportMultiDayAppointments: supportMultiDayAppointments\n    } = filterOptions;\n    var [trimMin, trimMax] = getDatesWithoutTime(min, max);\n    var useRecurrence = isDefined(this.dataAccessors.getter.recurrenceRule);\n    return [[appointment => {\n      var _appointment$visible;\n\n      var appointmentVisible = null !== (_appointment$visible = appointment.visible) && void 0 !== _appointment$visible ? _appointment$visible : true;\n\n      if (!appointmentVisible) {\n        return false;\n      }\n\n      var {\n        startDate: startDate,\n        endDate: endDate,\n        hasRecurrenceRule: hasRecurrenceRule\n      } = appointment;\n\n      if (!hasRecurrenceRule) {\n        if (!(endDate >= trimMin && startDate < trimMax || dateUtils.sameDate(endDate, trimMin) && dateUtils.sameDate(startDate, trimMin))) {\n          return false;\n        }\n      }\n\n      var appointmentTakesAllDay = getAppointmentTakesAllDay(appointment, viewStartDayHour, viewEndDayHour, this.allDayPanelMode);\n      var appointmentTakesSeveralDays = getAppointmentTakesSeveralDays(appointment);\n      var isAllDay = appointment.allDay;\n      var isLongAppointment = appointmentTakesSeveralDays || appointmentTakesAllDay;\n\n      if (null !== resources && void 0 !== resources && resources.length && !this._filterAppointmentByResources(appointment.rawAppointment, resources)) {\n        return false;\n      }\n\n      if (appointmentTakesAllDay && false === filterOptions.allDay) {\n        return false;\n      }\n\n      if (hasRecurrenceRule) {\n        var recurrenceException = getRecurrenceException(appointment, this.timeZoneCalculator, this.timezone);\n\n        if (!this._filterAppointmentByRRule(_extends({}, appointment, {\n          recurrenceException: recurrenceException,\n          allDay: appointmentTakesAllDay\n        }), min, max, startDayHour, endDayHour, firstDayOfWeek)) {\n          return false;\n        }\n      }\n\n      if (!isAllDay && supportMultiDayAppointments && isLongAppointment) {\n        if (endDate < min && (!useRecurrence || useRecurrence && !hasRecurrenceRule)) {\n          return false;\n        }\n      }\n\n      if (isDefined(startDayHour) && (!useRecurrence || !filterOptions.isVirtualScrolling)) {\n        if (!compareDateWithStartDayHour(startDate, endDate, startDayHour, appointmentTakesAllDay, appointmentTakesSeveralDays)) {\n          return false;\n        }\n      }\n\n      if (isDefined(endDayHour)) {\n        if (!compareDateWithEndDayHour({\n          startDate: startDate,\n          endDate: endDate,\n          startDayHour: startDayHour,\n          endDayHour: endDayHour,\n          viewStartDayHour: viewStartDayHour,\n          viewEndDayHour: viewEndDayHour,\n          allDay: appointmentTakesAllDay,\n          severalDays: appointmentTakesSeveralDays,\n          min: min,\n          max: max,\n          checkIntersectViewport: checkIntersectViewport\n        })) {\n          return false;\n        }\n      }\n\n      if (!isAllDay && (!isLongAppointment || supportMultiDayAppointments)) {\n        if (endDate < min && useRecurrence && !hasRecurrenceRule) {\n          return false;\n        }\n      }\n\n      return true;\n    }]];\n  }\n\n  _createAppointmentFilter(filterOptions) {\n    return this._createCombinedFilter(filterOptions);\n  }\n\n  _filterAppointmentByResources(appointment, resources) {\n    var checkAppointmentResourceValues = (resourceName, resourceIndex) => {\n      var resourceGetter = this.dataAccessors.resources.getter[resourceName];\n      var resource;\n\n      if (isFunction(resourceGetter)) {\n        resource = resourceGetter(appointment);\n      }\n\n      var appointmentResourceValues = wrapToArray(resource);\n      var resourceData = map(resources[resourceIndex].items, _ref => {\n        var {\n          id: id\n        } = _ref;\n        return id;\n      });\n\n      for (var i = 0; i < appointmentResourceValues.length; i++) {\n        if (hasResourceValue(resourceData, appointmentResourceValues[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    var result = false;\n\n    for (var i = 0; i < resources.length; i++) {\n      var resourceName = resources[i].name;\n      result = checkAppointmentResourceValues(resourceName, i);\n\n      if (!result) {\n        return false;\n      }\n    }\n\n    return result;\n  }\n\n  _filterAppointmentByRRule(appointment, min, max, startDayHour, endDayHour, firstDayOfWeek) {\n    var recurrenceRule = appointment.recurrenceRule;\n    var recurrenceException = appointment.recurrenceException;\n    var allDay = appointment.allDay;\n    var result = true;\n    var appointmentStartDate = appointment.startDate;\n    var appointmentEndDate = appointment.endDate;\n    var recurrenceProcessor = getRecurrenceProcessor();\n\n    if (allDay || _appointmentPartInInterval(appointmentStartDate, appointmentEndDate, startDayHour, endDayHour)) {\n      var [trimMin, trimMax] = getDatesWithoutTime(min, max);\n      min = trimMin;\n      max = new Date(trimMax.getTime() - toMs(\"minute\"));\n    }\n\n    if (recurrenceRule && !recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {\n      result = appointmentEndDate > min && appointmentStartDate <= max;\n    }\n\n    if (result && recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {\n      result = recurrenceProcessor.hasRecurrence({\n        rule: recurrenceRule,\n        exception: recurrenceException,\n        start: appointmentStartDate,\n        end: appointmentEndDate,\n        min: min,\n        max: max,\n        firstDayOfWeek: firstDayOfWeek,\n        appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(appointmentStartDate, appointment.startDateTimeZone, false)\n      });\n    }\n\n    return result;\n  }\n\n  filterLoadedAppointments(filterOptions, preparedItems) {\n    var filteredItems = this.filterPreparedItems(filterOptions, preparedItems);\n    return filteredItems.map(_ref2 => {\n      var {\n        rawAppointment: rawAppointment\n      } = _ref2;\n      return rawAppointment;\n    });\n  }\n\n  filterPreparedItems(filterOptions, preparedItems) {\n    var combinedFilter = this._createAppointmentFilter(filterOptions);\n\n    return query(preparedItems).filter(combinedFilter).toArray();\n  }\n\n  filterAllDayAppointments(filterOptions, preparedItems) {\n    var combinedFilter = this._createAllDayAppointmentFilter(filterOptions);\n\n    return query(preparedItems).filter(combinedFilter).toArray().map(_ref3 => {\n      var {\n        rawAppointment: rawAppointment\n      } = _ref3;\n      return rawAppointment;\n    });\n  }\n\n}\nexport class AppointmentFilterVirtualStrategy extends AppointmentFilterBaseStrategy {\n  get strategyName() {\n    return FilterStrategies.virtual;\n  }\n\n  get resources() {\n    return this.options.resources;\n  }\n\n  filter(preparedItems) {\n    var hourMs = toMs(\"hour\");\n    var isCalculateStartAndEndDayHour = calculateIsDateAndTimeView(this.viewType);\n    var checkIntersectViewport = isCalculateStartAndEndDayHour && \"horizontal\" === this.viewDirection;\n    var isAllDayWorkspace = !this.supportAllDayRow;\n    var showAllDayAppointments = this.showAllDayPanel || isAllDayWorkspace;\n    var endViewDate = this.viewDataProvider.getLastViewDateByEndDayHour(this.viewEndDayHour);\n    var filterOptions = [];\n    var groupsInfo = this.viewDataProvider.getCompletedGroupsInfo();\n    groupsInfo.forEach(item => {\n      var groupIndex = item.groupIndex;\n      var groupStartDate = item.startDate;\n      var groupEndDate = new Date(Math.min(item.endDate, endViewDate));\n      var startDayHour = isCalculateStartAndEndDayHour ? groupStartDate.getHours() : this.viewStartDayHour;\n      var endDayHour = isCalculateStartAndEndDayHour ? startDayHour + groupStartDate.getMinutes() / 60 + (groupEndDate - groupStartDate) / hourMs : this.viewEndDayHour;\n\n      var resources = this._getPrerenderFilterResources(groupIndex);\n\n      var hasAllDayPanel = this.viewDataProvider.hasGroupAllDayPanel(groupIndex);\n      var supportAllDayAppointment = isAllDayWorkspace || !!showAllDayAppointments && hasAllDayPanel;\n      filterOptions.push({\n        isVirtualScrolling: true,\n        startDayHour: startDayHour,\n        endDayHour: endDayHour,\n        viewStartDayHour: this.viewStartDayHour,\n        viewEndDayHour: this.viewEndDayHour,\n        min: groupStartDate,\n        max: groupEndDate,\n        supportMultiDayAppointments: isTimelineView(this.viewType),\n        allDay: supportAllDayAppointment,\n        resources: resources,\n        firstDayOfWeek: this.firstDayOfWeek,\n        checkIntersectViewport: checkIntersectViewport\n      });\n    });\n    return this.filterLoadedAppointments({\n      filterOptions: filterOptions,\n      groupCount: this.groupCount\n    }, preparedItems);\n  }\n\n  filterPreparedItems(_ref4, preparedItems) {\n    var {\n      filterOptions: filterOptions,\n      groupCount: groupCount\n    } = _ref4;\n    var combinedFilters = [];\n    var itemsToFilter = preparedItems;\n    var needPreFilter = groupCount > 0;\n\n    if (needPreFilter) {\n      itemsToFilter = itemsToFilter.filter(_ref5 => {\n        var {\n          rawAppointment: rawAppointment\n        } = _ref5;\n\n        for (var i = 0; i < filterOptions.length; ++i) {\n          var {\n            resources: resources\n          } = filterOptions[i];\n\n          if (this._filterAppointmentByResources(rawAppointment, resources)) {\n            return true;\n          }\n        }\n      });\n    }\n\n    filterOptions.forEach(option => {\n      combinedFilters.length && combinedFilters.push(\"or\");\n\n      var filter = this._createAppointmentFilter(option);\n\n      combinedFilters.push(filter);\n    });\n    return query(itemsToFilter).filter(combinedFilters).toArray();\n  }\n\n  hasAllDayAppointments(adapters, preparedItems) {\n    return this.filterAllDayAppointments({\n      viewStartDayHour: this.viewStartDayHour,\n      viewEndDayHour: this.viewEndDayHour\n    }, preparedItems).length > 0;\n  }\n\n  _getPrerenderFilterResources(groupIndex) {\n    var cellGroup = this.viewDataProvider.getCellsGroup(groupIndex);\n    return getResourcesDataByGroups(this.loadedResources, this.resources, [cellGroup]);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}