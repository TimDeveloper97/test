{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/box.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../core/renderer\";\nimport eventsEngine from \"../events/core/events_engine\";\nimport registerComponent from \"../core/component_registrator\";\nimport { extend } from \"../core/utils/extend\";\nimport { noop } from \"../core/utils/common\";\nimport { hasWindow } from \"../core/utils/window\";\nimport { dasherize } from \"../core/utils/inflector\";\nimport { isDefined } from \"../core/utils/type\";\nimport { normalizeStyleProp, styleProp, stylePropPrefix } from \"../core/utils/style\";\nimport { each } from \"../core/utils/iterator\";\nimport { getWidth, setWidth, getHeight, setHeight } from \"../core/utils/size\";\nimport CollectionWidgetItem from \"./collection/item\";\nimport CollectionWidget from \"./collection/ui.collection_widget.edit\";\nvar BOX_CLASS = \"dx-box\";\nvar BOX_SELECTOR = \".dx-box\";\nvar BOX_ITEM_CLASS = \"dx-box-item\";\nvar BOX_ITEM_DATA_KEY = \"dxBoxItemData\";\nvar MINSIZE_MAP = {\n  row: \"minWidth\",\n  col: \"minHeight\"\n};\nvar MAXSIZE_MAP = {\n  row: \"maxWidth\",\n  col: \"maxHeight\"\n};\nvar SHRINK = 1;\nvar FLEX_JUSTIFY_CONTENT_MAP = {\n  start: \"flex-start\",\n  end: \"flex-end\",\n  center: \"center\",\n  \"space-between\": \"space-between\",\n  \"space-around\": \"space-around\"\n};\nvar FLEX_ALIGN_ITEMS_MAP = {\n  start: \"flex-start\",\n  end: \"flex-end\",\n  center: \"center\",\n  stretch: \"stretch\"\n};\nvar FLEX_DIRECTION_MAP = {\n  row: \"row\",\n  col: \"column\"\n};\n\nvar setFlexProp = (element, prop, value) => {\n  value = normalizeStyleProp(prop, value);\n  element.style[styleProp(prop)] = value;\n\n  if (!hasWindow()) {\n    if (\"\" === value || !isDefined(value)) {\n      return;\n    }\n\n    var cssName = dasherize(prop);\n    var styleExpr = cssName + \": \" + value + \";\";\n\n    if (!element.attributes.style) {\n      element.setAttribute(\"style\", styleExpr);\n    } else if (element.attributes.style.value.indexOf(styleExpr) < 0) {\n      element.attributes.style.value += \" \" + styleExpr;\n    }\n  }\n};\n\nvar BOX_EVENTNAMESPACE = \"dxBox\";\nvar UPDATE_EVENT = \"dxupdate.\" + BOX_EVENTNAMESPACE;\nvar FALLBACK_BOX_ITEM = \"dx-box-fallback-item\";\nvar FALLBACK_WRAP_MAP = {\n  row: \"nowrap\",\n  col: \"normal\"\n};\nvar FALLBACK_MAIN_SIZE_MAP = {\n  row: {\n    name: \"width\",\n    getter: getWidth,\n    setter: setWidth\n  },\n  col: {\n    name: \"height\",\n    getter: getHeight,\n    setter: setHeight\n  }\n};\nvar FALLBACK_CROSS_SIZE_MAP = {\n  row: FALLBACK_MAIN_SIZE_MAP.col,\n  col: FALLBACK_MAIN_SIZE_MAP.row\n};\nvar FALLBACK_PRE_MARGIN_MAP = {\n  row: \"marginLeft\",\n  col: \"marginTop\"\n};\nvar FALLBACK_POST_MARGIN_MAP = {\n  row: \"marginRight\",\n  col: \"marginBottom\"\n};\nvar FALLBACK_CROSS_PRE_MARGIN_MAP = {\n  row: \"marginTop\",\n  col: \"marginLeft\"\n};\nvar FALLBACK_CROSS_POST_MARGIN_MAP = {\n  row: \"marginBottom\",\n  col: \"marginRight\"\n};\nvar MARGINS_RTL_FLIP_MAP = {\n  marginLeft: \"marginRight\",\n  marginRight: \"marginLeft\"\n};\n\nclass BoxItem extends CollectionWidgetItem {\n  _renderVisible(value, oldValue) {\n    super._renderVisible(value);\n\n    if (isDefined(oldValue)) {\n      this._options.fireItemStateChangedAction({\n        name: \"visible\",\n        state: value,\n        oldState: oldValue\n      });\n    }\n  }\n\n}\n\nclass FlexLayoutStrategy {\n  constructor($element, option) {\n    this._$element = $element;\n    this._option = option;\n    this.initSize = noop;\n    this.update = noop;\n  }\n\n  renderBox() {\n    this._$element.css({\n      display: stylePropPrefix(\"flexDirection\") + \"flex\"\n    });\n\n    setFlexProp(this._$element.get(0), \"flexDirection\", FLEX_DIRECTION_MAP[this._option(\"direction\")]);\n  }\n\n  renderAlign() {\n    this._$element.css({\n      justifyContent: this._normalizedAlign()\n    });\n  }\n\n  _normalizedAlign() {\n    var align = this._option(\"align\");\n\n    return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align;\n  }\n\n  renderCrossAlign() {\n    this._$element.css({\n      alignItems: this._normalizedCrossAlign()\n    });\n  }\n\n  _normalizedCrossAlign() {\n    var crossAlign = this._option(\"crossAlign\");\n\n    return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign;\n  }\n\n  renderItems($items) {\n    var flexPropPrefix = stylePropPrefix(\"flexDirection\");\n\n    var direction = this._option(\"direction\");\n\n    each($items, function () {\n      var $item = $(this);\n      var item = $item.data(BOX_ITEM_DATA_KEY);\n      $item.css({\n        display: flexPropPrefix + \"flex\"\n      }).css(MAXSIZE_MAP[direction], item.maxSize || \"none\").css(MINSIZE_MAP[direction], item.minSize || \"0\");\n      setFlexProp($item.get(0), \"flexBasis\", item.baseSize || 0);\n      setFlexProp($item.get(0), \"flexGrow\", item.ratio);\n      setFlexProp($item.get(0), \"flexShrink\", isDefined(item.shrink) ? item.shrink : SHRINK);\n      $item.children().each((_, itemContent) => {\n        $(itemContent).css({\n          width: \"auto\",\n          height: \"auto\",\n          display: stylePropPrefix(\"flexDirection\") + \"flex\",\n          flexBasis: 0\n        });\n        setFlexProp(itemContent, \"flexGrow\", 1);\n        setFlexProp(itemContent, \"flexDirection\", $(itemContent)[0].style.flexDirection || \"column\");\n      });\n    });\n  }\n\n}\n\nclass FallbackLayoutStrategy {\n  constructor($element, option) {\n    this._$element = $element;\n    this._option = option;\n  }\n\n  renderBox() {\n    this._$element.css({\n      fontSize: 0,\n      whiteSpace: FALLBACK_WRAP_MAP[this._option(\"direction\")],\n      verticalAlign: \"top\"\n    });\n\n    eventsEngine.off(this._$element, UPDATE_EVENT);\n    eventsEngine.on(this._$element, UPDATE_EVENT, this.update.bind(this));\n  }\n\n  renderAlign() {\n    var $items = this._$items;\n\n    if (!$items) {\n      return;\n    }\n\n    var align = this._option(\"align\");\n\n    var totalItemSize = this.totalItemSize;\n\n    var direction = this._option(\"direction\");\n\n    var boxSize = FALLBACK_MAIN_SIZE_MAP[direction].getter(this._$element);\n    var freeSpace = boxSize - totalItemSize;\n    var shift = 0;\n\n    this._setItemsMargins($items, direction, 0);\n\n    switch (align) {\n      case \"start\":\n        break;\n\n      case \"end\":\n        shift = freeSpace;\n        $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);\n        break;\n\n      case \"center\":\n        shift = .5 * freeSpace;\n        $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);\n        $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift);\n        break;\n\n      case \"space-between\":\n        shift = .5 * freeSpace / ($items.length - 1);\n\n        this._setItemsMargins($items, direction, shift);\n\n        $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), 0);\n        $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), 0);\n        break;\n\n      case \"space-around\":\n        shift = .5 * freeSpace / $items.length;\n\n        this._setItemsMargins($items, direction, shift);\n\n    }\n  }\n\n  _setItemsMargins($items, direction, shift) {\n    $items.css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift).css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift);\n  }\n\n  renderCrossAlign() {\n    var $items = this._$items;\n\n    if (!$items) {\n      return;\n    }\n\n    var crossAlign = this._option(\"crossAlign\");\n\n    var direction = this._option(\"direction\");\n\n    var size = FALLBACK_CROSS_SIZE_MAP[direction].getter(this._$element);\n    var that = this;\n\n    switch (crossAlign) {\n      case \"start\":\n        break;\n\n      case \"end\":\n        each($items, function () {\n          var $item = $(this);\n          var itemSize = FALLBACK_CROSS_SIZE_MAP[direction].getter($item);\n          var shift = size - itemSize;\n          $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift);\n        });\n        break;\n\n      case \"center\":\n        each($items, function () {\n          var $item = $(this);\n          var itemSize = FALLBACK_CROSS_SIZE_MAP[direction].getter($item);\n          var shift = .5 * (size - itemSize);\n          $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), shift);\n        });\n        break;\n\n      case \"stretch\":\n        $items.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), 0).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), 0).css(FALLBACK_CROSS_SIZE_MAP[direction].name, \"100%\");\n    }\n  }\n\n  _chooseMarginSide(value) {\n    if (!this._option(\"rtlEnabled\")) {\n      return value;\n    }\n\n    return MARGINS_RTL_FLIP_MAP[value] || value;\n  }\n\n  renderItems($items) {\n    this._$items = $items;\n\n    var direction = this._option(\"direction\");\n\n    var totalRatio = 0;\n    var totalWeightedShrink = 0;\n    var totalBaseSize = 0;\n    each($items, (_, item) => {\n      var $item = $(item);\n      $item.css({\n        display: \"inline-block\",\n        verticalAlign: \"top\"\n      });\n      FALLBACK_MAIN_SIZE_MAP[direction].setter($item, \"auto\");\n      $item.removeClass(FALLBACK_BOX_ITEM);\n      var itemData = $item.data(BOX_ITEM_DATA_KEY);\n      var ratio = itemData.ratio || 0;\n\n      var size = this._baseSize($item);\n\n      var shrink = isDefined(itemData.shrink) ? itemData.shrink : SHRINK;\n      totalRatio += ratio;\n      totalWeightedShrink += shrink * size;\n      totalBaseSize += size;\n    });\n    var freeSpaceSize = this._boxSize() - totalBaseSize;\n\n    var itemSize = $item => {\n      var itemData = $item.data(BOX_ITEM_DATA_KEY);\n\n      var size = this._baseSize($item);\n\n      var factor = freeSpaceSize >= 0 ? itemData.ratio || 0 : (isDefined(itemData.shrink) ? itemData.shrink : SHRINK) * size;\n      var totalFactor = freeSpaceSize >= 0 ? totalRatio : totalWeightedShrink;\n      var shift = totalFactor ? Math.round(freeSpaceSize * factor / totalFactor) : 0;\n      return size + shift;\n    };\n\n    var totalItemSize = 0;\n    each($items, (_, item) => {\n      var $item = $(item);\n      var itemData = $(item).data(BOX_ITEM_DATA_KEY);\n      var size = itemSize($item);\n      totalItemSize += size;\n      $item.css(MAXSIZE_MAP[direction], itemData.maxSize || \"none\").css(MINSIZE_MAP[direction], itemData.minSize || \"0\").css(FALLBACK_MAIN_SIZE_MAP[direction].name, size);\n      $item.addClass(FALLBACK_BOX_ITEM);\n    });\n    this.totalItemSize = totalItemSize;\n  }\n\n  _baseSize(item) {\n    var itemData = $(item).data(BOX_ITEM_DATA_KEY);\n    return null == itemData.baseSize ? 0 : \"auto\" === itemData.baseSize ? this._contentSize(item) : this._parseSize(itemData.baseSize);\n  }\n\n  _contentSize(item) {\n    return FALLBACK_MAIN_SIZE_MAP[this._option(\"direction\")].getter($(item));\n  }\n\n  _parseSize(size) {\n    return String(size).match(/.+%$/) ? .01 * parseFloat(size) * this._boxSizeValue : size;\n  }\n\n  _boxSize(value) {\n    if (!arguments.length) {\n      this._boxSizeValue = this._boxSizeValue || this._totalBaseSize();\n      return this._boxSizeValue;\n    }\n\n    this._boxSizeValue = value;\n  }\n\n  _totalBaseSize() {\n    var result = 0;\n    each(this._$items, (_, item) => {\n      result += this._baseSize(item);\n    });\n    return result;\n  }\n\n  initSize() {\n    this._boxSize(FALLBACK_MAIN_SIZE_MAP[this._option(\"direction\")].getter(this._$element));\n  }\n\n  update() {\n    if (!this._$items || this._$element.is(\":hidden\")) {\n      return;\n    }\n\n    this._$items.detach();\n\n    this.initSize();\n\n    this._$element.append(this._$items);\n\n    this.renderItems(this._$items);\n    this.renderAlign();\n    this.renderCrossAlign();\n\n    var element = this._$element.get(0);\n\n    this._$items.find(BOX_SELECTOR).each(function () {\n      if (element === $(this).parent().closest(BOX_SELECTOR).get(0)) {\n        eventsEngine.triggerHandler(this, UPDATE_EVENT);\n      }\n    });\n  }\n\n}\n\nlet Box = /*#__PURE__*/(() => {\n  class Box extends CollectionWidget {\n    _getDefaultOptions() {\n      return extend(super._getDefaultOptions(), {\n        direction: \"row\",\n        align: \"start\",\n        crossAlign: \"stretch\",\n        activeStateEnabled: false,\n        focusStateEnabled: false,\n        onItemStateChanged: void 0,\n        _layoutStrategy: \"flex\",\n        _queue: void 0\n      });\n    }\n\n    _itemClass() {\n      return BOX_ITEM_CLASS;\n    }\n\n    _itemDataKey() {\n      return BOX_ITEM_DATA_KEY;\n    }\n\n    _itemElements() {\n      return this._itemContainer().children(this._itemSelector());\n    }\n\n    _init() {\n      super._init();\n\n      this.$element().addClass(\"\".concat(BOX_CLASS, \"-\").concat(this.option(\"_layoutStrategy\")));\n\n      this._initLayout();\n\n      this._initBoxQueue();\n    }\n\n    _initLayout() {\n      this._layout = \"fallback\" === this.option(\"_layoutStrategy\") ? new FallbackLayoutStrategy(this.$element(), this.option.bind(this)) : new FlexLayoutStrategy(this.$element(), this.option.bind(this));\n    }\n\n    _initBoxQueue() {\n      this._queue = this.option(\"_queue\") || [];\n    }\n\n    _queueIsNotEmpty() {\n      return this.option(\"_queue\") ? false : !!this._queue.length;\n    }\n\n    _pushItemToQueue($item, config) {\n      this._queue.push({\n        $item: $item,\n        config: config\n      });\n    }\n\n    _shiftItemFromQueue() {\n      return this._queue.shift();\n    }\n\n    _initMarkup() {\n      this.$element().addClass(BOX_CLASS);\n\n      this._layout.renderBox();\n\n      super._initMarkup();\n\n      this._renderAlign();\n\n      this._renderActions();\n    }\n\n    _renderActions() {\n      this._onItemStateChanged = this._createActionByOption(\"onItemStateChanged\");\n    }\n\n    _renderAlign() {\n      this._layout.renderAlign();\n\n      this._layout.renderCrossAlign();\n    }\n\n    _renderItems(items) {\n      this._layout.initSize();\n\n      super._renderItems(items);\n\n      while (this._queueIsNotEmpty()) {\n        var item = this._shiftItemFromQueue();\n\n        this._createComponent(item.$item, Box, extend({\n          _layoutStrategy: this.option(\"_layoutStrategy\"),\n          itemTemplate: this.option(\"itemTemplate\"),\n          itemHoldTimeout: this.option(\"itemHoldTimeout\"),\n          onItemHold: this.option(\"onItemHold\"),\n          onItemClick: this.option(\"onItemClick\"),\n          onItemContextMenu: this.option(\"onItemContextMenu\"),\n          onItemRendered: this.option(\"onItemRendered\"),\n          _queue: this._queue\n        }, item.config));\n      }\n\n      this._layout.renderItems(this._itemElements());\n\n      clearTimeout(this._updateTimer);\n      this._updateTimer = setTimeout(() => {\n        if (!this._isUpdated) {\n          this._layout.update();\n        }\n\n        this._isUpdated = false;\n        this._updateTimer = null;\n      });\n    }\n\n    _renderItemContent(args) {\n      var $itemNode = args.itemData && args.itemData.node;\n\n      if ($itemNode) {\n        return this._renderItemContentByNode(args, $itemNode);\n      }\n\n      return super._renderItemContent(args);\n    }\n\n    _postprocessRenderItem(args) {\n      var boxConfig = args.itemData.box;\n\n      if (!boxConfig) {\n        return;\n      }\n\n      this._pushItemToQueue(args.itemContent, boxConfig);\n    }\n\n    _createItemByTemplate(itemTemplate, args) {\n      if (args.itemData.box) {\n        return itemTemplate.source ? itemTemplate.source() : $();\n      }\n\n      return super._createItemByTemplate(itemTemplate, args);\n    }\n\n    _visibilityChanged(visible) {\n      if (visible) {\n        this._dimensionChanged();\n      }\n    }\n\n    _dimensionChanged() {\n      if (this._updateTimer) {\n        return;\n      }\n\n      this._isUpdated = true;\n\n      this._layout.update();\n    }\n\n    _dispose() {\n      clearTimeout(this._updateTimer);\n\n      super._dispose.apply(this, arguments);\n    }\n\n    _itemOptionChanged(item, property, value, oldValue) {\n      if (\"visible\" === property) {\n        this._onItemStateChanged({\n          name: property,\n          state: value,\n          oldState: false !== oldValue\n        });\n      }\n\n      super._itemOptionChanged(item, property, value);\n    }\n\n    _optionChanged(args) {\n      switch (args.name) {\n        case \"_layoutStrategy\":\n        case \"_queue\":\n        case \"direction\":\n          this._invalidate();\n\n          break;\n\n        case \"align\":\n          this._layout.renderAlign();\n\n          break;\n\n        case \"crossAlign\":\n          this._layout.renderCrossAlign();\n\n          break;\n\n        default:\n          super._optionChanged(args);\n\n      }\n    }\n\n    _itemOptions() {\n      var options = super._itemOptions();\n\n      options.fireItemStateChangedAction = e => {\n        this._onItemStateChanged(e);\n      };\n\n      return options;\n    }\n\n    repaint() {\n      this._dimensionChanged();\n    }\n\n  }\n\n  Box.ItemClass = BoxItem;\n  return Box;\n})();\nregisterComponent(\"dxBox\", Box);\nexport default Box;","map":null,"metadata":{},"sourceType":"module"}