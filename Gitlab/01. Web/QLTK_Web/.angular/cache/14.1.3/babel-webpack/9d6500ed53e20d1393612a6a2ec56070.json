{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/chart.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getHeight } from \"../core/utils/size\";\nimport { noop } from \"../core/utils/common\";\nimport { extend as _extend } from \"../core/utils/extend\";\nimport { hasWindow } from \"../core/utils/window\";\nimport { each as _each } from \"../core/utils/iterator\";\nimport registerComponent from \"../core/component_registrator\";\nimport { prepareSegmentRectPoints } from \"./utils\";\nimport { map as _map, getLog, getCategoriesInfo, updatePanesCanvases, convertVisualRangeObject, PANE_PADDING, normalizePanesHeight, rangesAreEqual, isRelativeHeightPane } from \"./core/utils\";\nimport { type, isDefined as _isDefined } from \"../core/utils/type\";\nimport { getPrecision } from \"../core/utils/math\";\nimport { overlapping } from \"./chart_components/base_chart\";\nimport multiAxesSynchronizer from \"./chart_components/multi_axes_synchronizer\";\nimport { AdvancedChart } from \"./chart_components/advanced_chart\";\nimport { ScrollBar } from \"./chart_components/scroll_bar\";\nimport { Crosshair, getMargins } from \"./chart_components/crosshair\";\nimport rangeDataCalculator from \"./series/helpers/range_data_calculator\";\nimport { LayoutManager } from \"./chart_components/layout_manager\";\nimport { Range } from \"./translators/range\";\nvar DEFAULT_PANE_NAME = \"default\";\nvar VISUAL_RANGE = \"VISUAL_RANGE\";\nvar DEFAULT_PANES = [{\n  name: DEFAULT_PANE_NAME,\n  border: {}\n}];\nvar DISCRETE = \"discrete\";\nvar _isArray = Array.isArray;\n\nfunction getFirstAxisNameForPane(axes, paneName, defaultPane) {\n  var result;\n\n  for (var i = 0; i < axes.length; i++) {\n    if (axes[i].pane === paneName || void 0 === axes[i].pane && paneName === defaultPane) {\n      result = axes[i].name;\n      break;\n    }\n  }\n\n  if (!result) {\n    result = axes[0].name;\n  }\n\n  return result;\n}\n\nfunction changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility) {\n  var gridOpt = axis.getOptions().grid;\n  var minorGridOpt = axis.getOptions().minorGrid;\n  gridOpt.visible = gridVisibility;\n  minorGridOpt && (minorGridOpt.visible = minorGridVisibility);\n}\n\nfunction hideGridsOnNonFirstValueAxisForPane(axesForPane) {\n  var axisShown = false;\n  var hiddenStubAxis = [];\n  var minorGridVisibility = axesForPane.some(function (axis) {\n    var minorGridOptions = axis.getOptions().minorGrid;\n    return minorGridOptions && minorGridOptions.visible;\n  });\n  var gridVisibility = axesForPane.some(function (axis) {\n    var gridOptions = axis.getOptions().grid;\n    return gridOptions && gridOptions.visible;\n  });\n\n  if (axesForPane.length > 1) {\n    axesForPane.forEach(function (axis) {\n      var gridOpt = axis.getOptions().grid;\n\n      if (axisShown) {\n        changeVisibilityAxisGrids(axis, false, false);\n      } else if (gridOpt && gridOpt.visible) {\n        if (axis.getTranslator().getBusinessRange().isEmpty()) {\n          changeVisibilityAxisGrids(axis, false, false);\n          hiddenStubAxis.push(axis);\n        } else {\n          axisShown = true;\n          changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility);\n        }\n      }\n    });\n    !axisShown && hiddenStubAxis.length && changeVisibilityAxisGrids(hiddenStubAxis[0], gridVisibility, minorGridVisibility);\n  }\n}\n\nfunction findAxisOptions(valueAxes, valueAxesOptions, axisName) {\n  var result;\n  var axInd;\n\n  for (axInd = 0; axInd < valueAxesOptions.length; axInd++) {\n    if (valueAxesOptions[axInd].name === axisName) {\n      result = valueAxesOptions[axInd];\n      result.priority = axInd;\n      break;\n    }\n  }\n\n  if (!result) {\n    for (axInd = 0; axInd < valueAxes.length; axInd++) {\n      if (valueAxes[axInd].name === axisName) {\n        result = valueAxes[axInd].getOptions();\n        result.priority = valueAxes[axInd].priority;\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction findAxis(paneName, axisName, axes) {\n  var axis;\n  var i;\n\n  for (i = 0; i < axes.length; i++) {\n    axis = axes[i];\n\n    if (axis.name === axisName && axis.pane === paneName) {\n      return axis;\n    }\n  }\n\n  if (paneName) {\n    return findAxis(void 0, axisName, axes);\n  }\n}\n\nfunction compareAxes(a, b) {\n  return a.priority - b.priority;\n}\n\nfunction doesPaneExist(panes, paneName) {\n  var found = false;\n\n  _each(panes, function (_, pane) {\n    if (pane.name === paneName) {\n      found = true;\n      return false;\n    }\n  });\n\n  return found;\n}\n\nfunction accumulate(field, src1, src2, auxSpacing) {\n  var val1 = src1[field] || 0;\n  var val2 = src2[field] || 0;\n  return val1 + val2 + (val1 && val2 ? auxSpacing : 0);\n}\n\nfunction pickMax(field, src1, src2) {\n  return pickMaxValue(src1[field], src2[field]);\n}\n\nfunction pickMaxValue(val1, val2) {\n  return Math.max(val1 || 0, val2 || 0);\n}\n\nfunction getAxisMargins(axis) {\n  return axis.getMargins();\n}\n\nfunction getHorizontalAxesMargins(axes, getMarginsFunc) {\n  return axes.reduce(function (margins, axis) {\n    var _axis$getOrthogonalAx;\n\n    var axisMargins = getMarginsFunc(axis);\n    var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};\n    var spacing = axis.getMultipleAxesSpacing();\n    paneMargins.top = accumulate(\"top\", paneMargins, axisMargins, spacing);\n    paneMargins.bottom = accumulate(\"bottom\", paneMargins, axisMargins, spacing);\n    paneMargins.left = pickMax(\"left\", paneMargins, axisMargins);\n    paneMargins.right = pickMax(\"right\", paneMargins, axisMargins);\n    margins.top = pickMax(\"top\", paneMargins, margins);\n    margins.bottom = pickMax(\"bottom\", paneMargins, margins);\n    margins.left = pickMax(\"left\", paneMargins, margins);\n    margins.right = pickMax(\"right\", paneMargins, margins);\n    var orthogonalAxis = null === (_axis$getOrthogonalAx = axis.getOrthogonalAxis) || void 0 === _axis$getOrthogonalAx ? void 0 : _axis$getOrthogonalAx.call(axis);\n\n    if (orthogonalAxis && orthogonalAxis.customPositionIsAvailable() && (!axis.customPositionIsBoundaryOrthogonalAxis() || !orthogonalAxis.customPositionEqualsToPredefined())) {\n      margins[orthogonalAxis.getResolvedBoundaryPosition()] = 0;\n    }\n\n    return margins;\n  }, {\n    panes: {}\n  });\n}\n\nfunction getVerticalAxesMargins(axes) {\n  return axes.reduce(function (margins, axis) {\n    var axisMargins = axis.getMargins();\n    var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};\n    var spacing = axis.getMultipleAxesSpacing();\n    paneMargins.top = pickMax(\"top\", paneMargins, axisMargins);\n    paneMargins.bottom = pickMax(\"bottom\", paneMargins, axisMargins);\n    paneMargins.left = accumulate(\"left\", paneMargins, axisMargins, spacing);\n    paneMargins.right = accumulate(\"right\", paneMargins, axisMargins, spacing);\n    margins.top = pickMax(\"top\", paneMargins, margins);\n    margins.bottom = pickMax(\"bottom\", paneMargins, margins);\n    margins.left = pickMax(\"left\", paneMargins, margins);\n    margins.right = pickMax(\"right\", paneMargins, margins);\n    return margins;\n  }, {\n    panes: {}\n  });\n}\n\nfunction performActionOnAxes(axes, action, actionArgument1, actionArgument2, actionArgument3) {\n  axes.forEach(function (axis) {\n    axis[action](actionArgument1 && actionArgument1[axis.pane], actionArgument2 && actionArgument2[axis.pane] || actionArgument2, actionArgument3);\n  });\n}\n\nfunction shrinkCanvases(isRotated, canvases, sizes, verticalMargins, horizontalMargins) {\n  function getMargin(side, margins, pane) {\n    var m = -1 === (isRotated ? [\"left\", \"right\"] : [\"top\", \"bottom\"]).indexOf(side) ? margins : margins.panes[pane] || {};\n    return m[side];\n  }\n\n  function getMaxMargin(side, margins1, margins2, pane) {\n    return pickMaxValue(getMargin(side, margins1, pane), getMargin(side, margins2, pane));\n  }\n\n  var getOriginalField = field => \"original\".concat(field[0].toUpperCase()).concat(field.slice(1));\n\n  function shrink(canvases, paneNames, sizeField, startMargin, endMargin, oppositeMargins) {\n    paneNames = paneNames.sort((p1, p2) => canvases[p2][startMargin] - canvases[p1][startMargin]);\n    paneNames.forEach(pane => {\n      var canvas = canvases[pane];\n      oppositeMargins.forEach(margin => {\n        canvas[margin] = canvas[getOriginalField(margin)] + getMaxMargin(margin, verticalMargins, horizontalMargins, pane);\n      });\n    });\n    var firstPane = canvases[paneNames[0]];\n    var emptySpace = paneNames.reduce((space, paneName) => {\n      space -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, paneName) + getMaxMargin(endMargin, verticalMargins, horizontalMargins, paneName);\n      return space;\n    }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - canvases[paneNames[paneNames.length - 1]][getOriginalField(startMargin)]) - PANE_PADDING * (paneNames.length - 1);\n    emptySpace -= Object.keys(sizes).reduce((prev, key) => prev + (!isRelativeHeightPane(sizes[key]) ? sizes[key].height : 0), 0);\n    paneNames.reduce((offset, pane) => {\n      var canvas = canvases[pane];\n      var paneSize = sizes[pane];\n      offset -= getMaxMargin(endMargin, verticalMargins, horizontalMargins, pane);\n      canvas[endMargin] = firstPane[sizeField] - offset;\n      offset -= !isRelativeHeightPane(paneSize) ? paneSize.height : Math.floor(emptySpace * paneSize.height);\n      canvas[startMargin] = offset;\n      offset -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, pane) + PANE_PADDING;\n      return offset;\n    }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - (emptySpace < 0 ? emptySpace : 0));\n  }\n\n  var paneNames = Object.keys(canvases);\n\n  if (!isRotated) {\n    shrink(canvases, paneNames, \"height\", \"top\", \"bottom\", [\"left\", \"right\"]);\n  } else {\n    shrink(canvases, paneNames, \"width\", \"left\", \"right\", [\"top\", \"bottom\"]);\n  }\n\n  return canvases;\n}\n\nfunction drawAxesWithTicks(axes, condition, canvases, panesBorderOptions) {\n  if (condition) {\n    performActionOnAxes(axes, \"createTicks\", canvases);\n    multiAxesSynchronizer.synchronize(axes);\n  }\n\n  performActionOnAxes(axes, \"draw\", !condition && canvases, panesBorderOptions);\n}\n\nfunction shiftAxis(side1, side2) {\n  var shifts = {};\n  return function (axis) {\n    if (!axis.customPositionIsAvailable() || axis.customPositionEqualsToPredefined()) {\n      var shift = shifts[axis.pane] = shifts[axis.pane] || {\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0\n      };\n      var spacing = axis.getMultipleAxesSpacing();\n      var margins = axis.getMargins();\n      axis.shift(shift);\n      shift[side1] = accumulate(side1, shift, margins, spacing);\n      shift[side2] = accumulate(side2, shift, margins, spacing);\n    } else {\n      axis.shift({\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0\n      });\n    }\n  };\n}\n\nfunction getCommonSize(side, margins) {\n  var size = 0;\n  var pane;\n  var paneMargins;\n\n  for (pane in margins.panes) {\n    paneMargins = margins.panes[pane];\n    size += \"height\" === side ? paneMargins.top + paneMargins.bottom : paneMargins.left + paneMargins.right;\n  }\n\n  return size;\n}\n\nfunction checkUsedSpace(sizeShortage, side, axes, getMarginFunc) {\n  var size = 0;\n\n  if (sizeShortage[side] > 0) {\n    size = getCommonSize(side, getMarginFunc(axes, getAxisMargins));\n    performActionOnAxes(axes, \"hideTitle\");\n    sizeShortage[side] -= size - getCommonSize(side, getMarginFunc(axes, getAxisMargins));\n  }\n\n  if (sizeShortage[side] > 0) {\n    performActionOnAxes(axes, \"hideOuterElements\");\n  }\n}\n\nfunction axisAnimationEnabled(drawOptions, pointsToAnimation) {\n  var pointsCount = pointsToAnimation.reduce((sum, count) => sum + count, 0) / pointsToAnimation.length;\n  return drawOptions.animate && pointsCount <= drawOptions.animationPointsLimit;\n}\n\nfunction collectMarkersInfoBySeries(allSeries, filteredSeries, argAxis) {\n  var series = [];\n  var overloadedSeries = {};\n  var argVisualRange = argAxis.visualRange();\n  var argTranslator = argAxis.getTranslator();\n  var argViewPortFilter = rangeDataCalculator.getViewPortFilter(argVisualRange || {});\n  filteredSeries.forEach(s => {\n    var valAxis = s.getValueAxis();\n    var valVisualRange = valAxis.getCanvasRange();\n    var valTranslator = valAxis.getTranslator();\n    var seriesIndex = allSeries.indexOf(s);\n    var valViewPortFilter = rangeDataCalculator.getViewPortFilter(valVisualRange || {});\n    overloadedSeries[seriesIndex] = {};\n    filteredSeries.forEach(sr => overloadedSeries[seriesIndex][allSeries.indexOf(sr)] = 0);\n    var seriesPoints = [];\n    s.getPoints().filter(p => p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)))).forEach(p => {\n      var tp = {\n        seriesIndex: seriesIndex,\n        argument: p.argument,\n        value: p.getMaxValue(true),\n        size: p.bubbleSize || p.getOptions().size\n      };\n\n      if (p.getMinValue(true) !== p.getMaxValue(true)) {\n        var mp = _extend({}, tp);\n\n        mp.value = p.getMinValue(true);\n        mp.x = argTranslator.to(mp.argument, 1);\n        mp.y = valTranslator.to(mp.value, 1);\n        seriesPoints.push(mp);\n      }\n\n      tp.x = argTranslator.to(tp.argument, 1);\n      tp.y = valTranslator.to(tp.value, 1);\n      seriesPoints.push(tp);\n    });\n    overloadedSeries[seriesIndex].pointsCount = seriesPoints.length;\n    overloadedSeries[seriesIndex].total = 0;\n    overloadedSeries[seriesIndex].continuousSeries = 0;\n    series.push({\n      name: s.name,\n      index: seriesIndex,\n      points: seriesPoints\n    });\n  });\n  return {\n    series: series,\n    overloadedSeries: overloadedSeries\n  };\n}\n\nfunction applyAutoHidePointMarkers(allSeries, filteredSeries, overloadedSeries, argAxis) {\n  var argAxisType = argAxis.getOptions().type;\n  filteredSeries.forEach(s => {\n    var seriesIndex = allSeries.indexOf(s);\n    s.autoHidePointMarkers = false;\n    var tickCount = argAxis.getTicksValues().majorTicksValues.length;\n\n    if (s.autoHidePointMarkersEnabled() && (argAxisType === DISCRETE || overloadedSeries[seriesIndex].pointsCount > tickCount)) {\n      for (var index in overloadedSeries[seriesIndex]) {\n        var i = parseInt(index);\n\n        if (isNaN(i) || overloadedSeries[seriesIndex].total / overloadedSeries[seriesIndex].continuousSeries < 3) {\n          continue;\n        }\n\n        if (i === seriesIndex) {\n          if (2 * overloadedSeries[i][i] >= overloadedSeries[i].pointsCount) {\n            s.autoHidePointMarkers = true;\n            break;\n          }\n        } else if (overloadedSeries[seriesIndex].total >= overloadedSeries[seriesIndex].pointsCount) {\n          s.autoHidePointMarkers = true;\n          break;\n        }\n      }\n    }\n  });\n}\n\nfunction fastHidingPointMarkersByArea(canvas, markersInfo, series) {\n  var area = canvas.width * canvas.height;\n  var seriesPoints = markersInfo.series;\n\n  var _loop = function (i) {\n    var currentSeries = series.filter(s => s.name === seriesPoints[i].name)[0];\n    var points = seriesPoints[i].points;\n    var pointSize = points.length ? points[0].size : 0;\n    var pointsArea = pointSize * pointSize * points.length;\n\n    if (currentSeries.autoHidePointMarkersEnabled() && pointsArea >= area / seriesPoints.length) {\n      var index = seriesPoints[i].index;\n      currentSeries.autoHidePointMarkers = true;\n      seriesPoints.splice(i, 1);\n      series.splice(series.indexOf(currentSeries), 1);\n      delete markersInfo.overloadedSeries[index];\n    }\n  };\n\n  for (var i = seriesPoints.length - 1; i >= 0; i--) {\n    _loop(i);\n  }\n}\n\nfunction updateMarkersInfo(points, overloadedSeries) {\n  var isContinuousSeries = false;\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var curPoint = points[i];\n    var size = curPoint.size;\n\n    if (_isDefined(curPoint.x) && _isDefined(curPoint.y)) {\n      for (var j = i + 1; j < points.length; j++) {\n        var nextPoint = points[j];\n        var next_x = null === nextPoint || void 0 === nextPoint ? void 0 : nextPoint.x;\n        var next_y = null === nextPoint || void 0 === nextPoint ? void 0 : nextPoint.y;\n\n        if (!_isDefined(next_x) || Math.abs(curPoint.x - next_x) >= size) {\n          isContinuousSeries &= j !== i + 1;\n          break;\n        } else {\n          var distance = _isDefined(next_x) && _isDefined(next_y) && Math.sqrt(Math.pow(curPoint.x - next_x, 2) + Math.pow(curPoint.y - next_y, 2));\n\n          if (distance && distance < size) {\n            overloadedSeries[curPoint.seriesIndex][nextPoint.seriesIndex]++;\n            overloadedSeries[curPoint.seriesIndex].total++;\n\n            if (!isContinuousSeries) {\n              overloadedSeries[curPoint.seriesIndex].continuousSeries++;\n              isContinuousSeries = true;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nvar dxChart = AdvancedChart.inherit({\n  _themeSection: \"chart\",\n  _fontFields: [\"crosshair.label.font\"],\n  _initCore: function () {\n    this.paneAxis = {};\n    this.callBase();\n  },\n\n  _init() {\n    this._containerInitialHeight = hasWindow() ? getHeight(this._$element) : 0;\n    this.callBase();\n  },\n\n  _correctAxes: function () {\n    this._correctValueAxes(true);\n  },\n  _getExtraOptions: noop,\n  _createPanes: function () {\n    var panes = this.option(\"panes\");\n    var panesNameCounter = 0;\n    var defaultPane;\n\n    if (!panes || _isArray(panes) && !panes.length) {\n      panes = DEFAULT_PANES;\n    }\n\n    this.callBase();\n    defaultPane = this.option(\"defaultPane\");\n    panes = _extend(true, [], _isArray(panes) ? panes : [panes]);\n\n    _each(panes, function (_, pane) {\n      pane.name = !_isDefined(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name;\n    });\n\n    if (_isDefined(defaultPane)) {\n      if (!doesPaneExist(panes, defaultPane)) {\n        this._incidentOccurred(\"W2101\", [defaultPane]);\n\n        defaultPane = panes[panes.length - 1].name;\n      }\n    } else {\n      defaultPane = panes[panes.length - 1].name;\n    }\n\n    this.defaultPane = defaultPane;\n    panes = this._isRotated() ? panes.reverse() : panes;\n    return panes;\n  },\n  _getAxisRenderingOptions: function () {\n    return {\n      axisType: \"xyAxes\",\n      drawingType: \"linear\"\n    };\n  },\n  _prepareAxisOptions: function (typeSelector, userOptions, rotated) {\n    return {\n      isHorizontal: \"argumentAxis\" === typeSelector !== rotated,\n      containerColor: this._themeManager.getOptions(\"containerBackgroundColor\")\n    };\n  },\n  _checkPaneName: function (seriesTheme) {\n    var paneList = _map(this.panes, function (pane) {\n      return pane.name;\n    });\n\n    seriesTheme.pane = seriesTheme.pane || this.defaultPane;\n    return paneList.includes(seriesTheme.pane);\n  },\n\n  _initCustomPositioningAxes() {\n    var that = this;\n    var argumentAxis = that.getArgumentAxis();\n    var valueAxisName = argumentAxis.getOptions().customPositionAxis;\n\n    var valueAxis = that._valueAxes.filter(v => v.pane === argumentAxis.pane && (!valueAxisName || valueAxisName === v.name))[0];\n\n    that._valueAxes.forEach(v => {\n      if (argumentAxis !== v.getOrthogonalAxis()) {\n        v.getOrthogonalAxis = () => argumentAxis;\n\n        v.customPositionIsBoundaryOrthogonalAxis = () => argumentAxis.customPositionIsBoundary();\n      }\n    });\n\n    if (_isDefined(valueAxis) && valueAxis !== argumentAxis.getOrthogonalAxis()) {\n      argumentAxis.getOrthogonalAxis = () => valueAxis;\n\n      argumentAxis.customPositionIsBoundaryOrthogonalAxis = () => that._valueAxes.some(v => v.customPositionIsBoundary());\n    } else if (_isDefined(argumentAxis.getOrthogonalAxis()) && !_isDefined(valueAxis)) {\n      argumentAxis.getOrthogonalAxis = noop;\n    }\n  },\n\n  _getAllAxes() {\n    return this._argumentAxes.concat(this._valueAxes);\n  },\n\n  _resetAxesAnimation(isFirstDrawing, isHorizontal) {\n    var axes = _isDefined(isHorizontal) ? isHorizontal ^ this._isRotated() ? this._argumentAxes : this._valueAxes : this._getAllAxes();\n    axes.forEach(a => {\n      a.resetApplyingAnimation(isFirstDrawing);\n    });\n  },\n\n  _axesBoundaryPositioning() {\n    var allAxes = this._getAllAxes();\n\n    var boundaryStateChanged = false;\n    allAxes.forEach(a => {\n      if (!a.customPositionIsAvailable()) {\n        return false;\n      }\n\n      var prevBoundaryState = a.customPositionIsBoundary();\n      a._customBoundaryPosition = a.getCustomBoundaryPosition();\n      boundaryStateChanged |= prevBoundaryState !== a.customPositionIsBoundary();\n    });\n    return boundaryStateChanged;\n  },\n\n  _getCrosshairMargins: function () {\n    var crosshairOptions = this._getCrosshairOptions() || {};\n    var crosshairEnabled = crosshairOptions.enabled;\n    var margins = getMargins();\n\n    var horizontalLabel = _extend(true, {}, crosshairOptions.label, crosshairOptions.horizontalLine.label);\n\n    var verticalLabel = _extend(true, {}, crosshairOptions.label, crosshairOptions.verticalLine.label);\n\n    return {\n      x: crosshairEnabled && crosshairOptions.horizontalLine.visible && horizontalLabel.visible ? margins.x : 0,\n      y: crosshairEnabled && crosshairOptions.verticalLine.visible && verticalLabel.visible ? margins.y : 0\n    };\n  },\n  _getValueAxis: function (paneName, axisName) {\n    var valueAxes = this._valueAxes;\n    var valueAxisOptions = this.option(\"valueAxis\") || {};\n    var valueAxesOptions = _isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions];\n\n    var rotated = this._isRotated();\n\n    var crosshairMargins = this._getCrosshairMargins();\n\n    var axisOptions;\n    var axis;\n    axisName = axisName || getFirstAxisNameForPane(valueAxes, paneName, this.defaultPane);\n    axis = findAxis(paneName, axisName, valueAxes);\n\n    if (!axis) {\n      axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);\n\n      if (!axisOptions) {\n        this._incidentOccurred(\"W2102\", [axisName]);\n\n        axisOptions = {\n          name: axisName,\n          priority: valueAxes.length\n        };\n      }\n\n      axis = this._createAxis(false, this._populateAxesOptions(\"valueAxis\", axisOptions, {\n        pane: paneName,\n        name: axisName,\n        optionPath: _isArray(valueAxisOptions) ? \"valueAxis[\".concat(axisOptions.priority, \"]\") : \"valueAxis\",\n        crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x\n      }, rotated));\n      axis.applyVisualRangeSetter(this._getVisualRangeSetter());\n      valueAxes.push(axis);\n    }\n\n    axis.setPane(paneName);\n    return axis;\n  },\n  _correctValueAxes: function (needHideGrids) {\n    var that = this;\n\n    var synchronizeMultiAxes = that._themeManager.getOptions(\"synchronizeMultiAxes\");\n\n    var valueAxes = that._valueAxes;\n    var paneWithAxis = {};\n    that.series.forEach(function (series) {\n      var axis = series.getValueAxis();\n      paneWithAxis[axis.pane] = true;\n    });\n    that.panes.forEach(function (pane) {\n      var paneName = pane.name;\n\n      if (!paneWithAxis[paneName]) {\n        that._getValueAxis(paneName);\n      }\n\n      if (needHideGrids && synchronizeMultiAxes) {\n        hideGridsOnNonFirstValueAxisForPane(valueAxes.filter(function (axis) {\n          return axis.pane === paneName;\n        }));\n      }\n    });\n    that._valueAxes = valueAxes.filter(function (axis) {\n      if (!axis.pane) {\n        axis.setPane(that.defaultPane);\n      }\n\n      var paneExists = doesPaneExist(that.panes, axis.pane);\n\n      if (!paneExists) {\n        axis.dispose();\n        axis = null;\n      }\n\n      return paneExists;\n    }).sort(compareAxes);\n    var defaultAxis = this.getValueAxis();\n\n    that._valueAxes.forEach(axis => {\n      var optionPath = axis.getOptions().optionPath;\n\n      if (optionPath) {\n        var axesWithSamePath = that._valueAxes.filter(a => a.getOptions().optionPath === optionPath);\n\n        if (axesWithSamePath.length > 1) {\n          if (axesWithSamePath.some(a => a === defaultAxis)) {\n            axesWithSamePath.forEach(a => {\n              if (a !== defaultAxis) {\n                a.getOptions().optionPath = null;\n              }\n            });\n          } else {\n            axesWithSamePath.forEach((a, i) => {\n              if (0 !== i) {\n                a.getOptions().optionPath = null;\n              }\n            });\n          }\n        }\n      }\n    });\n  },\n  _getSeriesForPane: function (paneName) {\n    var paneSeries = [];\n\n    _each(this.series, function (_, oneSeries) {\n      if (oneSeries.pane === paneName) {\n        paneSeries.push(oneSeries);\n      }\n    });\n\n    return paneSeries;\n  },\n  _createPanesBorderOptions: function () {\n    var commonBorderOptions = this._themeManager.getOptions(\"commonPaneSettings\").border;\n\n    var panesBorderOptions = {};\n    this.panes.forEach(pane => panesBorderOptions[pane.name] = _extend(true, {}, commonBorderOptions, pane.border));\n    return panesBorderOptions;\n  },\n  _createScrollBar: function () {\n    var scrollBarOptions = this._themeManager.getOptions(\"scrollBar\") || {};\n    var scrollBarGroup = this._scrollBarGroup;\n\n    if (scrollBarOptions.visible) {\n      scrollBarOptions.rotated = this._isRotated();\n      this._scrollBar = (this._scrollBar || new ScrollBar(this._renderer, scrollBarGroup)).update(scrollBarOptions);\n    } else {\n      scrollBarGroup.linkRemove();\n      this._scrollBar && this._scrollBar.dispose();\n      this._scrollBar = null;\n    }\n  },\n\n  _executeAppendAfterSeries(append) {\n    append();\n  },\n\n  _prepareToRender(drawOptions) {\n    var panesBorderOptions = this._createPanesBorderOptions();\n\n    this._createPanesBackground();\n\n    this._appendAxesGroups();\n\n    this._adjustViewport();\n\n    return panesBorderOptions;\n  },\n\n  _adjustViewport() {\n    var adjustOnZoom = this._themeManager.getOptions(\"adjustOnZoom\");\n\n    if (!adjustOnZoom) {\n      return;\n    }\n\n    this._valueAxes.forEach(axis => axis.adjust());\n  },\n\n  _recreateSizeDependentObjects(isCanvasChanged) {\n    var that = this;\n\n    var series = that._getVisibleSeries();\n\n    var useAggregation = series.some(s => s.useAggregation());\n\n    var zoomChanged = that._isZooming();\n\n    if (!useAggregation) {\n      return;\n    }\n\n    that._argumentAxes.forEach(function (axis) {\n      axis.updateCanvas(that._canvas, true);\n    });\n\n    series.forEach(function (series) {\n      if (series.useAggregation() && (isCanvasChanged || zoomChanged || !series._useAllAggregatedPoints)) {\n        series.createPoints();\n      }\n    });\n\n    that._processSeriesFamilies();\n  },\n\n  _isZooming() {\n    var argumentAxis = this.getArgumentAxis();\n\n    if (!argumentAxis || !argumentAxis.getTranslator()) {\n      return false;\n    }\n\n    var businessRange = argumentAxis.getTranslator().getBusinessRange();\n    var zoomRange = argumentAxis.getViewport();\n    var min = zoomRange ? zoomRange.min : 0;\n    var max = zoomRange ? zoomRange.max : 0;\n\n    if (\"logarithmic\" === businessRange.axisType) {\n      min = getLog(min, businessRange.base);\n      max = getLog(max, businessRange.base);\n    }\n\n    var viewportDistance = businessRange.axisType === DISCRETE ? getCategoriesInfo(businessRange.categories, min, max).categories.length : Math.abs(max - min);\n    var precision = getPrecision(viewportDistance);\n    precision = precision > 1 ? Math.pow(10, precision - 2) : 1;\n    var zoomChanged = Math.round((this._zoomLength - viewportDistance) * precision) / precision !== 0;\n    this._zoomLength = viewportDistance;\n    return zoomChanged;\n  },\n\n  _handleSeriesDataUpdated: function () {\n    var that = this;\n    var viewport = new Range();\n    that.series.forEach(function (s) {\n      viewport.addRange(s.getArgumentRange());\n    });\n\n    that._argumentAxes.forEach(function (axis) {\n      axis.updateCanvas(that._canvas, true);\n      axis.setBusinessRange(viewport, that._axesReinitialized);\n    });\n\n    that.callBase();\n  },\n  _isLegendInside: function () {\n    return this._legend && \"inside\" === this._legend.getPosition();\n  },\n  _isRotated: function () {\n    return this._themeManager.getOptions(\"rotated\");\n  },\n  _getLayoutTargets: function () {\n    return this.panes;\n  },\n  _applyClipRects: function (panesBorderOptions) {\n    this._drawPanesBorders(panesBorderOptions);\n\n    this._createClipRectsForPanes();\n\n    this._applyClipRectsForAxes();\n\n    this._fillPanesBackground();\n  },\n  _updateLegendPosition: function (drawOptions, legendHasInsidePosition) {\n    if (drawOptions.drawLegend && this._legend && legendHasInsidePosition) {\n      var panes = this.panes;\n\n      var newCanvas = _extend({}, panes[0].canvas);\n\n      var layoutManager = new LayoutManager();\n      newCanvas.right = panes[panes.length - 1].canvas.right;\n      newCanvas.bottom = panes[panes.length - 1].canvas.bottom;\n      layoutManager.layoutInsideLegend(this._legend, newCanvas);\n    }\n  },\n  _allowLegendInsidePosition: () => true,\n  _applyExtraSettings: function (series) {\n    var paneIndex = this._getPaneIndex(series.pane);\n\n    var panesClipRects = this._panesClipRects;\n    var wideClipRect = panesClipRects.wide[paneIndex];\n    series.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect && wideClipRect.id, this._getPaneBorderVisibility(paneIndex));\n  },\n  _updatePanesCanvases: function (drawOptions) {\n    if (!drawOptions.recreateCanvas) {\n      return;\n    }\n\n    updatePanesCanvases(this.panes, this._canvas, this._isRotated());\n  },\n  _normalizePanesHeight: function () {\n    normalizePanesHeight(this.panes);\n  },\n  _renderScaleBreaks: function () {\n    this._valueAxes.concat(this._argumentAxes).forEach(function (axis) {\n      axis.drawScaleBreaks();\n    });\n  },\n\n  _getArgFilter() {\n    return rangeDataCalculator.getViewPortFilter(this.getArgumentAxis().visualRange() || {});\n  },\n\n  _applyPointMarkersAutoHiding() {\n    var that = this;\n    var allSeries = that.series;\n\n    if (!that._themeManager.getOptions(\"autoHidePointMarkers\")) {\n      allSeries.forEach(s => s.autoHidePointMarkers = false);\n      return;\n    }\n\n    that.panes.forEach(_ref => {\n      var {\n        borderCoords: borderCoords,\n        name: name\n      } = _ref;\n      var series = allSeries.filter(s => s.pane === name && s.usePointsToDefineAutoHiding());\n      var argAxis = that.getArgumentAxis();\n      var markersInfo = collectMarkersInfoBySeries(allSeries, series, argAxis);\n      fastHidingPointMarkersByArea(borderCoords, markersInfo, series);\n\n      if (markersInfo.series.length) {\n        var argVisualRange = argAxis.visualRange();\n        var argAxisIsDiscrete = argAxis.getOptions().type === DISCRETE;\n        var sortingCallback = argAxisIsDiscrete ? (p1, p2) => argVisualRange.categories.indexOf(p1.argument) - argVisualRange.categories.indexOf(p2.argument) : (p1, p2) => p1.argument - p2.argument;\n        var points = [];\n        markersInfo.series.forEach(s => points = points.concat(s.points));\n        points.sort(sortingCallback);\n        updateMarkersInfo(points, markersInfo.overloadedSeries);\n        applyAutoHidePointMarkers(allSeries, series, markersInfo.overloadedSeries, argAxis);\n      }\n    });\n  },\n\n  _renderAxes: function (drawOptions, panesBorderOptions) {\n    function calculateTitlesWidth(axes) {\n      return axes.map(axis => {\n        if (!axis.getTitle) {\n          return 0;\n        }\n\n        var title = axis.getTitle();\n        return title ? title.bBox.width : 0;\n      });\n    }\n\n    var that = this;\n\n    var rotated = that._isRotated();\n\n    var synchronizeMultiAxes = that._themeManager.getOptions(\"synchronizeMultiAxes\");\n\n    var scrollBar = that._scrollBar ? [that._scrollBar] : [];\n    var extendedArgAxes = that._isArgumentAxisBeforeScrollBar() ? that._argumentAxes.concat(scrollBar) : scrollBar.concat(that._argumentAxes);\n    var verticalAxes = rotated ? that._argumentAxes : that._valueAxes;\n    var verticalElements = rotated ? extendedArgAxes : that._valueAxes;\n    var horizontalAxes = rotated ? that._valueAxes : that._argumentAxes;\n    var horizontalElements = rotated ? that._valueAxes : extendedArgAxes;\n    var allAxes = verticalAxes.concat(horizontalAxes);\n    var allElements = allAxes.concat(scrollBar);\n    var verticalAxesFirstDrawing = verticalAxes.some(v => v.isFirstDrawing());\n\n    that._normalizePanesHeight();\n\n    that._updatePanesCanvases(drawOptions);\n\n    var panesCanvases = that.panes.reduce(function (canvases, pane) {\n      canvases[pane.name] = _extend({}, pane.canvas);\n      return canvases;\n    }, {});\n    var paneSizes = that.panes.reduce((sizes, pane) => {\n      sizes[pane.name] = {\n        height: pane.height,\n        unit: pane.unit\n      };\n      return sizes;\n    }, {});\n\n    var cleanPanesCanvases = _extend(true, {}, panesCanvases);\n\n    that._initCustomPositioningAxes();\n\n    var needCustomAdjustAxes = that._axesBoundaryPositioning();\n\n    if (!drawOptions.adjustAxes && !needCustomAdjustAxes) {\n      drawAxesWithTicks(verticalAxes, !rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);\n      drawAxesWithTicks(horizontalAxes, rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);\n      performActionOnAxes(allAxes, \"prepareAnimation\");\n\n      that._renderScaleBreaks();\n\n      horizontalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(verticalAxes));\n      verticalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(horizontalAxes));\n      return false;\n    }\n\n    if (needCustomAdjustAxes) {\n      allAxes.forEach(a => a.customPositionIsAvailable() && a.shift({\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0\n      }));\n    }\n\n    if (that._scrollBar) {\n      that._scrollBar.setPane(that.panes);\n    }\n\n    var vAxesMargins = {\n      panes: {}\n    };\n    var hAxesMargins = getHorizontalAxesMargins(horizontalElements, axis => axis.estimateMargins(panesCanvases[axis.pane]));\n    panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);\n\n    var drawAxesAndSetCanvases = isHorizontal => {\n      var axes = isHorizontal ? horizontalAxes : verticalAxes;\n      var condition = (isHorizontal ? rotated : !rotated) && synchronizeMultiAxes;\n      drawAxesWithTicks(axes, condition, panesCanvases, panesBorderOptions);\n\n      if (isHorizontal) {\n        hAxesMargins = getHorizontalAxesMargins(horizontalElements, getAxisMargins);\n      } else {\n        vAxesMargins = getVerticalAxesMargins(verticalElements);\n      }\n\n      panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);\n    };\n\n    drawAxesAndSetCanvases(false);\n    drawAxesAndSetCanvases(true);\n\n    if (!that._changesApplying && that._estimateTickIntervals(verticalAxes, panesCanvases)) {\n      drawAxesAndSetCanvases(false);\n    }\n\n    var oldTitlesWidth = calculateTitlesWidth(verticalAxes);\n\n    var visibleSeries = that._getVisibleSeries();\n\n    var pointsToAnimation = that._getPointsToAnimation(visibleSeries);\n\n    var axesIsAnimated = axisAnimationEnabled(drawOptions, pointsToAnimation);\n    performActionOnAxes(allElements, \"updateSize\", panesCanvases, axesIsAnimated);\n    horizontalElements.forEach(shiftAxis(\"top\", \"bottom\"));\n    verticalElements.forEach(shiftAxis(\"left\", \"right\"));\n\n    that._renderScaleBreaks();\n\n    that.panes.forEach(function (pane) {\n      _extend(pane.canvas, panesCanvases[pane.name]);\n    });\n\n    that._valueAxes.forEach(axis => {\n      axis.setInitRange();\n    });\n\n    verticalAxes.forEach((axis, i) => {\n      var _axis$hasWrap;\n\n      if (null !== (_axis$hasWrap = axis.hasWrap) && void 0 !== _axis$hasWrap && _axis$hasWrap.call(axis)) {\n        var title = axis.getTitle();\n        var newTitleWidth = title ? title.bBox.width : 0;\n        var offset = newTitleWidth - oldTitlesWidth[i];\n\n        if (\"right\" === axis.getOptions().position) {\n          vAxesMargins.right += offset;\n        } else {\n          vAxesMargins.left += offset;\n          that.panes.forEach(_ref2 => {\n            var {\n              name: name\n            } = _ref2;\n            return vAxesMargins.panes[name].left += offset;\n          });\n        }\n\n        panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);\n        performActionOnAxes(allElements, \"updateSize\", panesCanvases, false, false);\n        oldTitlesWidth = calculateTitlesWidth(verticalAxes);\n      }\n    });\n\n    if (verticalAxes.some(v => v.customPositionIsAvailable() && v.getCustomPosition() !== v._axisPosition)) {\n      axesIsAnimated && that._resetAxesAnimation(verticalAxesFirstDrawing, false);\n      performActionOnAxes(verticalAxes, \"updateSize\", panesCanvases, axesIsAnimated);\n    }\n\n    horizontalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(verticalAxes));\n    verticalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(horizontalAxes));\n    return cleanPanesCanvases;\n  },\n\n  _getExtraTemplatesItems() {\n    var allAxes = (this._argumentAxes || []).concat(this._valueAxes || []);\n\n    var elements = this._collectTemplatesFromItems(allAxes);\n\n    return {\n      items: elements.items,\n      groups: elements.groups,\n\n      launchRequest() {\n        allAxes.forEach(function (a) {\n          a.setRenderedState(true);\n        });\n      },\n\n      doneRequest() {\n        allAxes.forEach(function (a) {\n          a.setRenderedState(false);\n        });\n      }\n\n    };\n  },\n\n  _estimateTickIntervals: (axes, canvases) => axes.some(axis => axis.estimateTickInterval(canvases[axis.pane])),\n\n  checkForMoreSpaceForPanesCanvas() {\n    var rotated = this._isRotated();\n\n    var panesAreCustomSized = this.panes.filter(p => p.unit).length === this.panes.length;\n    var needSpace = false;\n\n    if (panesAreCustomSized) {\n      var needHorizontalSpace = 0;\n      var needVerticalSpace = 0;\n\n      if (rotated) {\n        var argAxisRightMargin = this.getArgumentAxis().getMargins().right;\n        var rightPanesIndent = Math.min.apply(Math, this.panes.map(p => p.canvas.right));\n        needHorizontalSpace = this._canvas.right + argAxisRightMargin - rightPanesIndent;\n      } else {\n        var argAxisBottomMargin = this.getArgumentAxis().getMargins().bottom;\n        var bottomPanesIndent = Math.min.apply(Math, this.panes.map(p => p.canvas.bottom));\n        needVerticalSpace = this._canvas.bottom + argAxisBottomMargin - bottomPanesIndent;\n      }\n\n      needSpace = needHorizontalSpace > 0 || needVerticalSpace > 0 ? {\n        width: needHorizontalSpace,\n        height: needVerticalSpace\n      } : false;\n\n      if (0 !== needVerticalSpace) {\n        var realSize = this.getSize();\n        var customSize = this.option(\"size\");\n        var container = this._$element[0];\n        var containerHasStyledHeight = !!parseInt(container.style.height) || 0 !== this._containerInitialHeight;\n\n        if (!rotated && !(customSize && customSize.height) && !containerHasStyledHeight) {\n          this._forceResize(realSize.width, realSize.height + needVerticalSpace);\n\n          needSpace = false;\n        }\n      }\n    } else {\n      needSpace = this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), rotated, pane => ({\n        width: rotated && !!pane.unit,\n        height: !rotated && !!pane.unit\n      }));\n    }\n\n    return needSpace;\n  },\n\n  _forceResize(width, height) {\n    this._renderer.resize(width, height);\n\n    this._updateSize();\n\n    this._setContentSize();\n\n    this._preserveOriginalCanvas();\n\n    this._updateCanvasClipRect(this._canvas);\n  },\n\n  _shrinkAxes(sizeShortage, panesCanvases) {\n    if (!sizeShortage || !panesCanvases) {\n      return;\n    }\n\n    this._renderer.stopAllAnimations(true);\n\n    var rotated = this._isRotated();\n\n    var scrollBar = this._scrollBar ? [this._scrollBar] : [];\n    var extendedArgAxes = this._isArgumentAxisBeforeScrollBar() ? this._argumentAxes.concat(scrollBar) : scrollBar.concat(this._argumentAxes);\n    var verticalAxes = rotated ? extendedArgAxes : this._valueAxes;\n    var horizontalAxes = rotated ? this._valueAxes : extendedArgAxes;\n    var allAxes = verticalAxes.concat(horizontalAxes);\n\n    if (sizeShortage.width || sizeShortage.height) {\n      checkUsedSpace(sizeShortage, \"height\", horizontalAxes, getHorizontalAxesMargins);\n      checkUsedSpace(sizeShortage, \"width\", verticalAxes, getVerticalAxesMargins);\n      performActionOnAxes(allAxes, \"updateSize\", panesCanvases);\n      var paneSizes = this.panes.reduce((sizes, pane) => {\n        sizes[pane.name] = {\n          height: pane.height,\n          unit: pane.unit\n        };\n        return sizes;\n      }, {});\n      panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, getVerticalAxesMargins(verticalAxes), getHorizontalAxesMargins(horizontalAxes, getAxisMargins));\n      performActionOnAxes(allAxes, \"updateSize\", panesCanvases);\n      horizontalAxes.forEach(shiftAxis(\"top\", \"bottom\"));\n      verticalAxes.forEach(shiftAxis(\"left\", \"right\"));\n      this.panes.forEach(pane => _extend(pane.canvas, panesCanvases[pane.name]));\n    }\n  },\n\n  _isArgumentAxisBeforeScrollBar() {\n    var argumentAxis = this.getArgumentAxis();\n\n    if (this._scrollBar) {\n      var _argumentAxis$getOpti;\n\n      var argAxisPosition = argumentAxis.getResolvedBoundaryPosition();\n      var argAxisLabelPosition = null === (_argumentAxis$getOpti = argumentAxis.getOptions().label) || void 0 === _argumentAxis$getOpti ? void 0 : _argumentAxis$getOpti.position;\n\n      var scrollBarPosition = this._scrollBar.getOptions().position;\n\n      return argumentAxis.hasNonBoundaryPosition() || scrollBarPosition === argAxisPosition && argAxisLabelPosition !== scrollBarPosition;\n    }\n\n    return false;\n  },\n\n  _getPanesParameters: function () {\n    var panes = this.panes;\n    var i;\n    var params = [];\n\n    for (i = 0; i < panes.length; i++) {\n      if (this._getPaneBorderVisibility(i)) {\n        params.push({\n          coords: panes[i].borderCoords,\n          clipRect: this._panesClipRects.fixed[i]\n        });\n      }\n    }\n\n    return params;\n  },\n  _createCrosshairCursor: function () {\n    var options = this._themeManager.getOptions(\"crosshair\") || {};\n    var argumentAxis = this.getArgumentAxis();\n    var axes = !this._isRotated() ? [[argumentAxis], this._valueAxes] : [this._valueAxes, [argumentAxis]];\n    var parameters = {\n      canvas: this._getCommonCanvas(),\n      panes: this._getPanesParameters(),\n      axes: axes\n    };\n\n    if (!options || !options.enabled) {\n      return;\n    }\n\n    if (!this._crosshair) {\n      this._crosshair = new Crosshair(this._renderer, options, parameters, this._crosshairCursorGroup);\n    } else {\n      this._crosshair.update(options, parameters);\n    }\n\n    this._crosshair.render();\n  },\n  _getCommonCanvas: function () {\n    var i;\n    var canvas;\n    var commonCanvas;\n    var panes = this.panes;\n\n    for (i = 0; i < panes.length; i++) {\n      canvas = panes[i].canvas;\n\n      if (!commonCanvas) {\n        commonCanvas = _extend({}, canvas);\n      } else {\n        commonCanvas.right = canvas.right;\n        commonCanvas.bottom = canvas.bottom;\n      }\n    }\n\n    return commonCanvas;\n  },\n  _createPanesBackground: function () {\n    var defaultBackgroundColor = this._themeManager.getOptions(\"commonPaneSettings\").backgroundColor;\n\n    var backgroundColor;\n    var renderer = this._renderer;\n    var rect;\n    var i;\n    var rects = [];\n\n    this._panesBackgroundGroup.clear();\n\n    for (i = 0; i < this.panes.length; i++) {\n      backgroundColor = this.panes[i].backgroundColor || defaultBackgroundColor;\n\n      if (!backgroundColor || \"none\" === backgroundColor) {\n        rects.push(null);\n        continue;\n      }\n\n      rect = renderer.rect(0, 0, 0, 0).attr({\n        fill: backgroundColor,\n        \"stroke-width\": 0\n      }).append(this._panesBackgroundGroup);\n      rects.push(rect);\n    }\n\n    this.panesBackground = rects;\n  },\n  _fillPanesBackground: function () {\n    var that = this;\n    var bc;\n\n    _each(that.panes, function (i, pane) {\n      bc = pane.borderCoords;\n\n      if (null !== that.panesBackground[i]) {\n        that.panesBackground[i].attr({\n          x: bc.left,\n          y: bc.top,\n          width: bc.width,\n          height: bc.height\n        });\n      }\n    });\n  },\n  _calcPaneBorderCoords: function (pane) {\n    var canvas = pane.canvas;\n    var bc = pane.borderCoords = pane.borderCoords || {};\n    bc.left = canvas.left;\n    bc.top = canvas.top;\n    bc.right = canvas.width - canvas.right;\n    bc.bottom = canvas.height - canvas.bottom;\n    bc.width = Math.max(bc.right - bc.left, 0);\n    bc.height = Math.max(bc.bottom - bc.top, 0);\n  },\n  _drawPanesBorders: function (panesBorderOptions) {\n    var that = this;\n\n    var rotated = that._isRotated();\n\n    that._panesBorderGroup.linkRemove().clear();\n\n    _each(that.panes, function (i, pane) {\n      var borderOptions = panesBorderOptions[pane.name];\n      var attr = {\n        fill: \"none\",\n        stroke: borderOptions.color,\n        \"stroke-opacity\": borderOptions.opacity,\n        \"stroke-width\": borderOptions.width,\n        dashStyle: borderOptions.dashStyle,\n        \"stroke-linecap\": \"square\"\n      };\n\n      that._calcPaneBorderCoords(pane, rotated);\n\n      if (!borderOptions.visible) {\n        return;\n      }\n\n      var bc = pane.borderCoords;\n      var segmentRectParams = prepareSegmentRectPoints(bc.left, bc.top, bc.width, bc.height, borderOptions);\n\n      that._renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(that._panesBorderGroup);\n    });\n\n    that._panesBorderGroup.linkAppend();\n  },\n  _createClipRect: function (clipArray, index, left, top, width, height) {\n    var clipRect = clipArray[index];\n\n    if (!clipRect) {\n      clipRect = this._renderer.clipRect(left, top, width, height);\n      clipArray[index] = clipRect;\n    } else {\n      clipRect.attr({\n        x: left,\n        y: top,\n        width: width,\n        height: height\n      });\n    }\n  },\n  _createClipRectsForPanes: function () {\n    var that = this;\n    var canvas = that._canvas;\n\n    _each(that.panes, function (i, pane) {\n      var needWideClipRect = false;\n      var bc = pane.borderCoords;\n      var left = bc.left;\n      var top = bc.top;\n      var width = bc.width;\n      var height = bc.height;\n      var panesClipRects = that._panesClipRects;\n\n      that._createClipRect(panesClipRects.fixed, i, left, top, width, height);\n\n      that._createClipRect(panesClipRects.base, i, left, top, width, height);\n\n      _each(that.series, function (_, series) {\n        if (series.pane === pane.name && (series.isFinancialSeries() || series.areErrorBarsVisible())) {\n          needWideClipRect = true;\n        }\n      });\n\n      if (needWideClipRect) {\n        if (that._isRotated()) {\n          top = 0;\n          height = canvas.height;\n        } else {\n          left = 0;\n          width = canvas.width;\n        }\n\n        that._createClipRect(panesClipRects.wide, i, left, top, width, height);\n      } else {\n        panesClipRects.wide[i] = null;\n      }\n    });\n  },\n\n  _applyClipRectsForAxes() {\n    var axes = this._getAllAxes();\n\n    var chartCanvasClipRectID = this._getCanvasClipRectID();\n\n    for (var i = 0; i < axes.length; i++) {\n      var elementsClipRectID = this._getElementsClipRectID(axes[i].pane);\n\n      axes[i].applyClipRects(elementsClipRectID, chartCanvasClipRectID);\n    }\n  },\n\n  _getPaneBorderVisibility: function (paneIndex) {\n    var commonPaneBorderVisible = this._themeManager.getOptions(\"commonPaneSettings\").border.visible;\n\n    var pane = this.panes[paneIndex] || {};\n    var paneBorder = pane.border || {};\n    return \"visible\" in paneBorder ? paneBorder.visible : commonPaneBorderVisible;\n  },\n  _getCanvasForPane: function (paneName) {\n    var panes = this.panes;\n    var panesNumber = panes.length;\n    var i;\n\n    for (i = 0; i < panesNumber; i++) {\n      if (panes[i].name === paneName) {\n        return panes[i].canvas;\n      }\n    }\n  },\n  _getTrackerSettings: function () {\n    var themeManager = this._themeManager;\n    return _extend(this.callBase(), {\n      chart: this,\n      rotated: this._isRotated(),\n      crosshair: this._getCrosshairOptions().enabled ? this._crosshair : null,\n      stickyHovering: themeManager.getOptions(\"stickyHovering\")\n    });\n  },\n  _resolveLabelOverlappingStack: function () {\n    var that = this;\n\n    var isRotated = that._isRotated();\n\n    var shiftDirection = isRotated ? function (box, length) {\n      return {\n        x: box.x - length,\n        y: box.y\n      };\n    } : function (box, length) {\n      return {\n        x: box.x,\n        y: box.y - length\n      };\n    };\n\n    _each(that._getStackPoints(), function (_, stacks) {\n      _each(stacks, function (_, points) {\n        var isInverted = points[0].series.getValueAxis().getOptions().inverted;\n        overlapping.resolveLabelOverlappingInOneDirection(points, that._getCommonCanvas(), isRotated, isInverted, shiftDirection, (a, b) => {\n          var coordPosition = isRotated ? 1 : 0;\n          var figureCenter1 = a.labels[0].getFigureCenter()[coordPosition];\n          var figureCenter12 = b.labels[0].getFigureCenter()[coordPosition];\n\n          if (figureCenter1 - figureCenter12 === 0) {\n            return (a.value() - b.value()) * (a.labels[0].getPoint().series.getValueAxis().getTranslator().isInverted() ? -1 : 1);\n          }\n\n          return 0;\n        });\n      });\n    });\n  },\n  _getStackPoints: function () {\n    var stackPoints = {};\n\n    var visibleSeries = this._getVisibleSeries();\n\n    _each(visibleSeries, function (_, singleSeries) {\n      var points = singleSeries.getPoints();\n      var stackName = singleSeries.getStackName() || null;\n\n      _each(points, function (_, point) {\n        var argument = point.argument;\n\n        if (!stackPoints[argument]) {\n          stackPoints[argument] = {};\n        }\n\n        if (!stackPoints[argument][stackName]) {\n          stackPoints[argument][stackName] = [];\n        }\n\n        stackPoints[argument][stackName].push(point);\n      });\n    });\n\n    return stackPoints;\n  },\n  _getCrosshairOptions: function () {\n    return this._getOption(\"crosshair\");\n  },\n\n  zoomArgument(min, max) {\n    if (!this._initialized || !_isDefined(min) && !_isDefined(max)) {\n      return;\n    }\n\n    this.getArgumentAxis().visualRange([min, max]);\n  },\n\n  resetVisualRange() {\n    var that = this;\n    var axes = that._argumentAxes;\n    var nonVirtualArgumentAxis = that.getArgumentAxis();\n    axes.forEach(axis => {\n      axis.resetVisualRange(nonVirtualArgumentAxis !== axis);\n\n      that._applyCustomVisualRangeOption(axis);\n    });\n    that.callBase();\n  },\n\n  getVisibleArgumentBounds: function () {\n    var translator = this._argumentAxes[0].getTranslator();\n\n    var range = translator.getBusinessRange();\n    var isDiscrete = range.axisType === DISCRETE;\n    var categories = range.categories;\n    return {\n      minVisible: isDiscrete ? range.minVisible || categories[0] : range.minVisible,\n      maxVisible: isDiscrete ? range.maxVisible || categories[categories.length - 1] : range.maxVisible\n    };\n  },\n\n  _change_FULL_RENDER() {\n    this.callBase();\n\n    if (this._changes.has(VISUAL_RANGE)) {\n      this._raiseZoomEndHandlers();\n    }\n  },\n\n  _getAxesForScaling() {\n    return [this.getArgumentAxis()].concat(this._valueAxes);\n  },\n\n  _applyVisualRangeByVirtualAxes(axis, range) {\n    if (axis.isArgumentAxis) {\n      if (axis !== this.getArgumentAxis()) {\n        return true;\n      }\n\n      this._argumentAxes.filter(a => a !== axis).forEach(a => a.visualRange(range, {\n        start: true,\n        end: true\n      }));\n    }\n\n    return false;\n  },\n\n  _raiseZoomEndHandlers() {\n    this._argumentAxes.forEach(axis => axis.handleZoomEnd());\n\n    this.callBase();\n  },\n\n  _setOptionsByReference() {\n    this.callBase();\n\n    _extend(this._optionsByReference, {\n      \"argumentAxis.visualRange\": true\n    });\n  },\n\n  option() {\n    var option = this.callBase.apply(this, arguments);\n\n    var valueAxis = this._options.silent(\"valueAxis\");\n\n    if (\"array\" === type(valueAxis)) {\n      for (var i = 0; i < valueAxis.length; i++) {\n        var optionPath = \"valueAxis[\".concat(i, \"].visualRange\");\n        this._optionsByReference[optionPath] = true;\n      }\n    }\n\n    return option;\n  },\n\n  _notifyVisualRange() {\n    var argAxis = this._argumentAxes[0];\n    var argumentVisualRange = convertVisualRangeObject(argAxis.visualRange(), !_isArray(this.option(\"argumentAxis.visualRange\")));\n\n    if (!argAxis.skipEventRising || !rangesAreEqual(argumentVisualRange, this.option(\"argumentAxis.visualRange\"))) {\n      this.option(\"argumentAxis.visualRange\", argumentVisualRange);\n    } else {\n      argAxis.skipEventRising = null;\n    }\n\n    this.callBase();\n  }\n\n});\nimport shutterZoom from \"./chart_components/shutter_zoom\";\nimport zoomAndPan from \"./chart_components/zoom_and_pan\";\nimport { plugins } from \"./core/annotations\";\ndxChart.addPlugin(shutterZoom);\ndxChart.addPlugin(zoomAndPan);\ndxChart.addPlugin(plugins.core);\ndxChart.addPlugin(plugins.chart);\nregisterComponent(\"dxChart\", dxChart);\nexport default dxChart;","map":null,"metadata":{},"sourceType":"module"}