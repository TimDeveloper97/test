{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/context_menu/ui.context_menu.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport domAdapter from \"../../core/dom_adapter\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport Guid from \"../../core/guid\";\nimport registerComponent from \"../../core/component_registrator\";\nimport { noop } from \"../../core/utils/common\";\nimport { isObject, isRenderer, isWindow, isFunction, isPlainObject, isDefined } from \"../../core/utils/type\";\nimport { contains } from \"../../core/utils/dom\";\nimport { getPublicElement } from \"../../core/element\";\nimport { each } from \"../../core/utils/iterator\";\nimport { extend } from \"../../core/utils/extend\";\nimport { hasWindow, getWindow } from \"../../core/utils/window\";\nimport fx from \"../../animation/fx\";\nimport animationPosition from \"../../animation/position\";\nimport devices from \"../../core/devices\";\nimport { addNamespace } from \"../../events/utils/index\";\nimport Overlay from \"../overlay/ui.overlay\";\nimport MenuBase from \"./ui.menu_base\";\nimport { Deferred } from \"../../core/utils/deferred\";\nimport { name as contextMenuEventName } from \"../../events/contextmenu\";\nimport holdEvent from \"../../events/hold\";\nvar DX_MENU_CLASS = \"dx-menu\";\nvar DX_MENU_ITEM_CLASS = DX_MENU_CLASS + \"-item\";\nvar DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + \"-expanded\";\nvar DX_MENU_PHONE_CLASS = \"dx-menu-phone-overlay\";\nvar DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + \"-items-container\";\nvar DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + \"-wrapper\";\nvar DX_SUBMENU_CLASS = \"dx-submenu\";\nvar DX_CONTEXT_MENU_CLASS = \"dx-context-menu\";\nvar DX_HAS_CONTEXT_MENU_CLASS = \"dx-has-context-menu\";\nvar DX_STATE_DISABLED_CLASS = \"dx-state-disabled\";\nvar DX_STATE_FOCUSED_CLASS = \"dx-state-focused\";\nvar DX_STATE_HOVER_CLASS = \"dx-state-hover\";\nvar OVERLAY_CONTENT_CLASS = \"dx-overlay-content\";\nvar FOCUS_UP = \"up\";\nvar FOCUS_DOWN = \"down\";\nvar FOCUS_LEFT = \"left\";\nvar FOCUS_RIGHT = \"right\";\nvar FOCUS_FIRST = \"first\";\nvar FOCUS_LAST = \"last\";\nvar ACTIONS = [\"onShowing\", \"onShown\", \"onSubmenuCreated\", \"onHiding\", \"onHidden\", \"onPositioning\", \"onLeftFirstItem\", \"onLeftLastItem\", \"onCloseRootSubmenu\", \"onExpandLastSubmenu\"];\nvar LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP, FOCUS_DOWN, FOCUS_FIRST, FOCUS_LAST];\nvar DEFAULT_SHOW_EVENT = \"dxcontextmenu\";\nvar window = getWindow();\n\nclass ContextMenu extends MenuBase {\n  getShowEvent(showEventOption) {\n    var result = null;\n\n    if (isObject(showEventOption)) {\n      if (null !== showEventOption.name) {\n        result = showEventOption.name || DEFAULT_SHOW_EVENT;\n      }\n    } else {\n      result = showEventOption;\n    }\n\n    return result;\n  }\n\n  getShowDelay(showEventOption) {\n    return isObject(showEventOption) && showEventOption.delay;\n  }\n\n  _getDefaultOptions() {\n    return extend(super._getDefaultOptions(), {\n      showEvent: DEFAULT_SHOW_EVENT,\n      hideOnOutsideClick: true,\n      position: {\n        at: \"top left\",\n        my: \"top left\"\n      },\n      onShowing: null,\n      onShown: null,\n      onSubmenuCreated: null,\n      onHiding: null,\n      onHidden: null,\n      onPositioning: null,\n      submenuDirection: \"auto\",\n      visible: false,\n      target: void 0,\n      onLeftFirstItem: null,\n      onLeftLastItem: null,\n      onCloseRootSubmenu: null,\n      onExpandLastSubmenu: null\n    });\n  }\n\n  _defaultOptionsRules() {\n    return super._defaultOptionsRules().concat([{\n      device: () => !hasWindow(),\n      options: {\n        animation: null\n      }\n    }]);\n  }\n\n  _setDeprecatedOptions() {\n    super._setDeprecatedOptions();\n\n    extend(this._deprecatedOptions, {\n      closeOnOutsideClick: {\n        since: \"22.2\",\n        alias: \"hideOnOutsideClick\"\n      }\n    });\n  }\n\n  _initActions() {\n    this._actions = {};\n    each(ACTIONS, (index, action) => {\n      this._actions[action] = this._createActionByOption(action) || noop;\n    });\n  }\n\n  _setOptionsByReference() {\n    super._setOptionsByReference();\n\n    extend(this._optionsByReference, {\n      animation: true,\n      selectedItem: true\n    });\n  }\n\n  _focusInHandler() {}\n\n  _itemContainer() {\n    return this._overlay ? this._overlay.$content() : $();\n  }\n\n  _eventBindingTarget() {\n    return this._itemContainer();\n  }\n\n  itemsContainer() {\n    return this._overlay ? this._overlay.$content() : void 0;\n  }\n\n  _supportedKeys() {\n    return extend(super._supportedKeys(), {\n      space: () => {\n        var $item = $(this.option(\"focusedElement\"));\n        this.hide();\n\n        if (!$item.length || !this._isSelectionEnabled()) {\n          return;\n        }\n\n        this.selectItem($item[0]);\n      },\n      escape: this.hide\n    });\n  }\n\n  _getActiveItem() {\n    var $availableItems = this._getAvailableItems();\n\n    var $focusedItem = $availableItems.filter(\".\".concat(DX_STATE_FOCUSED_CLASS));\n    var $hoveredItem = $availableItems.filter(\".\".concat(DX_STATE_HOVER_CLASS));\n    var $hoveredItemContainer = $hoveredItem.closest(\".\".concat(DX_MENU_ITEMS_CONTAINER_CLASS));\n\n    if ($hoveredItemContainer.find(\".\".concat(DX_MENU_ITEM_CLASS)).index($focusedItem) >= 0) {\n      return $focusedItem;\n    }\n\n    if ($hoveredItem.length) {\n      return $hoveredItem;\n    }\n\n    return super._getActiveItem();\n  }\n\n  _moveFocus(location) {\n    var $items = this._getItemsByLocation(location);\n\n    var $oldTarget = this._getActiveItem(true);\n\n    var $hoveredItem = this.itemsContainer().find(\".\".concat(DX_STATE_HOVER_CLASS));\n    var $focusedItem = $(this.option(\"focusedElement\"));\n    var $activeItemHighlighted = !!($focusedItem.length || $hoveredItem.length);\n    var $newTarget;\n\n    switch (location) {\n      case FOCUS_UP:\n        $newTarget = $activeItemHighlighted ? this._prevItem($items) : $oldTarget;\n\n        this._setFocusedElement($newTarget);\n\n        if ($oldTarget.is($items.first())) {\n          this._actions.onLeftFirstItem($oldTarget);\n        }\n\n        break;\n\n      case FOCUS_DOWN:\n        $newTarget = $activeItemHighlighted ? this._nextItem($items) : $oldTarget;\n\n        this._setFocusedElement($newTarget);\n\n        if ($oldTarget.is($items.last())) {\n          this._actions.onLeftLastItem($oldTarget);\n        }\n\n        break;\n\n      case FOCUS_RIGHT:\n        $newTarget = this.option(\"rtlEnabled\") ? this._hideSubmenuHandler() : this._expandSubmenuHandler($items, location);\n\n        this._setFocusedElement($newTarget);\n\n        break;\n\n      case FOCUS_LEFT:\n        $newTarget = this.option(\"rtlEnabled\") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler();\n\n        this._setFocusedElement($newTarget);\n\n        break;\n\n      case FOCUS_FIRST:\n        $newTarget = $items.first();\n\n        this._setFocusedElement($newTarget);\n\n        break;\n\n      case FOCUS_LAST:\n        $newTarget = $items.last();\n\n        this._setFocusedElement($newTarget);\n\n        break;\n\n      default:\n        return super._moveFocus(location);\n    }\n  }\n\n  _setFocusedElement($element) {\n    if ($element && 0 !== $element.length) {\n      this.option(\"focusedElement\", getPublicElement($element));\n    }\n  }\n\n  _getItemsByLocation(location) {\n    var $activeItem = this._getActiveItem(true);\n\n    var $items;\n\n    if (LOCAL_SUBMENU_DIRECTIONS.includes(location)) {\n      $items = $activeItem.closest(\".\".concat(DX_MENU_ITEMS_CONTAINER_CLASS)).children().children();\n    }\n\n    $items = this._getAvailableItems($items);\n    return $items;\n  }\n\n  _getAriaTarget() {\n    return this.$element();\n  }\n\n  _refreshActiveDescendant() {\n    if (isDefined(this._overlay)) {\n      var $target = this._overlay.$content();\n\n      super._refreshActiveDescendant($target);\n    }\n  }\n\n  _hideSubmenuHandler() {\n    var $curItem = this._getActiveItem(true);\n\n    var $parentItem = $curItem.parents(\".\".concat(DX_MENU_ITEM_EXPANDED_CLASS)).first();\n\n    if ($parentItem.length) {\n      this._hideSubmenusOnSameLevel($parentItem);\n\n      this._hideSubmenu($curItem.closest(\".\".concat(DX_SUBMENU_CLASS)));\n\n      return $parentItem;\n    }\n\n    this._actions.onCloseRootSubmenu($curItem);\n\n    return $curItem;\n  }\n\n  _expandSubmenuHandler($items, location) {\n    var $curItem = this._getActiveItem(true);\n\n    var itemData = this._getItemData($curItem);\n\n    var node = this._dataAdapter.getNodeByItem(itemData);\n\n    var isItemHasSubmenu = this._hasSubmenu(node);\n\n    var $submenu = $curItem.children(\".\".concat(DX_SUBMENU_CLASS));\n\n    if (isItemHasSubmenu && !$curItem.hasClass(DX_STATE_DISABLED_CLASS)) {\n      if (!$submenu.length || \"hidden\" === $submenu.css(\"visibility\")) {\n        this._showSubmenu($curItem);\n      }\n\n      return this._nextItem(this._getItemsByLocation(location));\n    }\n\n    this._actions.onExpandLastSubmenu($curItem);\n\n    return;\n  }\n\n  _clean() {\n    if (this._overlay) {\n      this._overlay.$element().remove();\n\n      this._overlay = null;\n    }\n\n    this._detachShowContextMenuEvents(this._getTarget());\n\n    super._clean();\n  }\n\n  _initMarkup() {\n    this.$element().addClass(DX_HAS_CONTEXT_MENU_CLASS);\n\n    super._initMarkup();\n  }\n\n  _render() {\n    super._render();\n\n    this._renderVisibility(this.option(\"visible\"));\n\n    this._addWidgetClass();\n  }\n\n  _renderContentImpl() {\n    this._detachShowContextMenuEvents(this._getTarget());\n\n    this._attachShowContextMenuEvents();\n  }\n\n  _attachKeyboardEvents() {\n    !this._keyboardListenerId && this._focusTarget().length && super._attachKeyboardEvents();\n  }\n\n  _renderContextMenuOverlay() {\n    if (this._overlay) {\n      return;\n    }\n\n    var overlayOptions = this._getOverlayOptions();\n\n    this._overlay = this._createComponent($(\"<div>\").appendTo(this._$element), Overlay, overlayOptions);\n\n    var $overlayContent = this._overlay.$content();\n\n    $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);\n\n    this._addCustomCssClass($overlayContent);\n\n    this._addPlatformDependentClass($overlayContent);\n\n    this._attachContextMenuEvent();\n  }\n\n  preventShowingDefaultContextMenuAboveOverlay() {\n    var $itemContainer = this._itemContainer();\n\n    var eventName = addNamespace(contextMenuEventName, this.NAME);\n    eventsEngine.off($itemContainer, eventName, \".\".concat(DX_SUBMENU_CLASS));\n    eventsEngine.on($itemContainer, eventName, \".\".concat(DX_SUBMENU_CLASS), (e => {\n      e.stopPropagation();\n      e.preventDefault();\n      eventsEngine.off($itemContainer, eventName, \".\".concat(DX_SUBMENU_CLASS));\n    }).bind(this));\n  }\n\n  _itemContextMenuHandler(e) {\n    super._itemContextMenuHandler(e);\n\n    e.stopPropagation();\n  }\n\n  _addPlatformDependentClass($element) {\n    if (devices.current().phone) {\n      $element.addClass(DX_MENU_PHONE_CLASS);\n    }\n  }\n\n  _detachShowContextMenuEvents(target) {\n    var showEvent = this.getShowEvent(this.option(\"showEvent\"));\n\n    if (!showEvent) {\n      return;\n    }\n\n    var eventName = addNamespace(showEvent, this.NAME);\n\n    if (this._showContextMenuEventHandler) {\n      eventsEngine.off(domAdapter.getDocument(), eventName, target, this._showContextMenuEventHandler);\n    } else {\n      eventsEngine.off($(target), eventName);\n    }\n  }\n\n  _attachShowContextMenuEvents() {\n    var target = this._getTarget();\n\n    var showEvent = this.getShowEvent(this.option(\"showEvent\"));\n\n    if (!showEvent) {\n      return;\n    }\n\n    var eventName = addNamespace(showEvent, this.NAME);\n\n    var contextMenuAction = this._createAction(e => {\n      var delay = this.getShowDelay(this.option(\"showEvent\"));\n\n      if (delay) {\n        setTimeout(() => this._show(e.event), delay);\n      } else {\n        this._show(e.event);\n      }\n    }, {\n      validatingTargetName: \"target\"\n    });\n\n    var handler = e => contextMenuAction({\n      event: e,\n      target: $(e.currentTarget)\n    });\n\n    contextMenuAction = this._createAction(contextMenuAction);\n\n    if (isRenderer(target) || target.nodeType || isWindow(target)) {\n      this._showContextMenuEventHandler = void 0;\n      eventsEngine.on(target, eventName, handler);\n    } else {\n      this._showContextMenuEventHandler = handler;\n      eventsEngine.on(domAdapter.getDocument(), eventName, target, this._showContextMenuEventHandler);\n    }\n  }\n\n  _hoverEndHandler(e) {\n    super._hoverEndHandler(e);\n\n    e.stopPropagation();\n  }\n\n  _renderDimensions() {}\n\n  _renderContainer($wrapper, submenuContainer) {\n    var $holder = submenuContainer || this._itemContainer();\n\n    $wrapper = $(\"<div>\");\n    $wrapper.appendTo($holder).addClass(DX_SUBMENU_CLASS).css(\"visibility\", submenuContainer ? \"hidden\" : \"visible\");\n\n    if (!$wrapper.parent().hasClass(OVERLAY_CONTENT_CLASS)) {\n      this._addCustomCssClass($wrapper);\n    }\n\n    var $itemsContainer = super._renderContainer($wrapper);\n\n    if (submenuContainer) {\n      return $itemsContainer;\n    }\n\n    if (this.option(\"width\")) {\n      return $itemsContainer.css(\"minWidth\", this.option(\"width\"));\n    }\n\n    if (this.option(\"height\")) {\n      return $itemsContainer.css(\"minHeight\", this.option(\"height\"));\n    }\n\n    return $itemsContainer;\n  }\n\n  _renderSubmenuItems(node, $itemFrame) {\n    this._renderItems(this._getChildNodes(node), $itemFrame);\n\n    this._actions.onSubmenuCreated({\n      itemElement: getPublicElement($itemFrame),\n      itemData: node.internalFields.item,\n      submenuElement: getPublicElement($itemFrame.children(\".\".concat(DX_SUBMENU_CLASS)))\n    });\n  }\n\n  _getOverlayOptions() {\n    var position = this.option(\"position\");\n    var overlayOptions = {\n      focusStateEnabled: this.option(\"focusStateEnabled\"),\n      animation: this.option(\"animation\"),\n      innerOverlay: true,\n      hideOnOutsideClick: e => this._hideOnOutsideClickHandler(e),\n      propagateOutsideClick: true,\n      hideOnParentScroll: true,\n      deferRendering: false,\n      position: {\n        at: position.at,\n        my: position.my,\n        of: this._getTarget(),\n        collision: \"flipfit\"\n      },\n      shading: false,\n      showTitle: false,\n      height: \"auto\",\n      width: \"auto\",\n      onShown: this._overlayShownActionHandler.bind(this),\n      onHiding: this._overlayHidingActionHandler.bind(this),\n      onHidden: this._overlayHiddenActionHandler.bind(this),\n      visualContainer: window\n    };\n    return overlayOptions;\n  }\n\n  _overlayShownActionHandler(arg) {\n    this._actions.onShown(arg);\n  }\n\n  _overlayHidingActionHandler(arg) {\n    this._actions.onHiding(arg);\n\n    if (!arg.cancel) {\n      this._hideAllShownSubmenus();\n\n      this._setOptionWithoutOptionChange(\"visible\", false);\n    }\n  }\n\n  _overlayHiddenActionHandler(arg) {\n    this._actions.onHidden(arg);\n  }\n\n  _shouldHideOnOutsideClick(e) {\n    var {\n      closeOnOutsideClick: closeOnOutsideClick,\n      hideOnOutsideClick: hideOnOutsideClick\n    } = this.option();\n\n    if (isFunction(hideOnOutsideClick)) {\n      return hideOnOutsideClick(e);\n    } else if (isFunction(closeOnOutsideClick)) {\n      return closeOnOutsideClick(e);\n    } else {\n      return hideOnOutsideClick || closeOnOutsideClick;\n    }\n  }\n\n  _hideOnOutsideClickHandler(e) {\n    if (!this._shouldHideOnOutsideClick(e)) {\n      return false;\n    }\n\n    if (domAdapter.isDocument(e.target)) {\n      return true;\n    }\n\n    var $activeItemContainer = this._getActiveItemsContainer(e.target);\n\n    var $itemContainers = this._getItemsContainers();\n\n    var $clickedItem = this._searchActiveItem(e.target);\n\n    var $rootItem = this.$element().parents(\".\".concat(DX_MENU_ITEM_CLASS));\n    var isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;\n    var isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;\n\n    if (isInnerOverlayClicked || isRootItemClicked) {\n      if (\"onClick\" === this._getShowSubmenuMode()) {\n        this._hideAllShownChildSubmenus($clickedItem);\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  _getActiveItemsContainer(target) {\n    return $(target).closest(\".\".concat(DX_MENU_ITEMS_CONTAINER_CLASS));\n  }\n\n  _getItemsContainers() {\n    return this._overlay.$content().find(\".\".concat(DX_MENU_ITEMS_CONTAINER_CLASS));\n  }\n\n  _searchActiveItem(target) {\n    return $(target).closest(\".\".concat(DX_MENU_ITEM_CLASS)).eq(0);\n  }\n\n  _isIncludeOverlay($activeOverlay, $allOverlays) {\n    var isSame = false;\n    each($allOverlays, (index, $overlay) => {\n      if ($activeOverlay.is($overlay) && !isSame) {\n        isSame = true;\n      }\n    });\n    return isSame;\n  }\n\n  _hideAllShownChildSubmenus($clickedItem) {\n    var $submenuElements = $clickedItem.find(\".\".concat(DX_SUBMENU_CLASS));\n    var shownSubmenus = extend([], this._shownSubmenus);\n\n    if ($submenuElements.length > 0) {\n      each(shownSubmenus, (index, $submenu) => {\n        var $context = this._searchActiveItem($submenu.context).parent();\n\n        if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent())) {\n          this._hideSubmenu($submenu);\n        }\n      });\n    }\n  }\n\n  _showSubmenu($item) {\n    var node = this._dataAdapter.getNodeByItem(this._getItemData($item));\n\n    this._hideSubmenusOnSameLevel($item);\n\n    if (!this._hasSubmenu(node)) {\n      return;\n    }\n\n    var $submenu = $item.children(\".\".concat(DX_SUBMENU_CLASS));\n    var isSubmenuRendered = $submenu.length;\n\n    super._showSubmenu($item);\n\n    if (!isSubmenuRendered) {\n      this._renderSubmenuItems(node, $item);\n    }\n\n    if (!this._isSubmenuVisible($submenu)) {\n      this._drawSubmenu($item);\n    }\n  }\n\n  _hideSubmenusOnSameLevel($item) {\n    var $expandedItems = $item.parent(\".\".concat(DX_MENU_ITEM_WRAPPER_CLASS)).siblings().find(\".\".concat(DX_MENU_ITEM_EXPANDED_CLASS));\n\n    if ($expandedItems.length) {\n      $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);\n\n      this._hideSubmenu($expandedItems.find(\".\".concat(DX_SUBMENU_CLASS)));\n    }\n  }\n\n  _hideSubmenuGroup($submenu) {\n    if (this._isSubmenuVisible($submenu)) {\n      this._hideSubmenuCore($submenu);\n    }\n  }\n\n  _isSubmenuVisible($submenu) {\n    return \"visible\" === $submenu.css(\"visibility\");\n  }\n\n  _drawSubmenu($itemElement) {\n    var animation = this.option(\"animation\") ? this.option(\"animation\").show : {};\n    var $submenu = $itemElement.children(\".\".concat(DX_SUBMENU_CLASS));\n\n    var submenuPosition = this._getSubmenuPosition($itemElement);\n\n    if (this._overlay && this._overlay.option(\"visible\")) {\n      if (!isDefined(this._shownSubmenus)) {\n        this._shownSubmenus = [];\n      }\n\n      if (!this._shownSubmenus.includes($submenu)) {\n        this._shownSubmenus.push($submenu);\n      }\n\n      if (animation) {\n        fx.stop($submenu);\n      }\n\n      animationPosition.setup($submenu, submenuPosition);\n\n      if (animation) {\n        if (isPlainObject(animation.to)) {\n          animation.to.position = submenuPosition;\n        }\n\n        this._animate($submenu, animation);\n      }\n\n      $submenu.css(\"visibility\", \"visible\");\n    }\n  }\n\n  _animate($container, options) {\n    fx.animate($container, options);\n  }\n\n  _getSubmenuPosition($rootItem) {\n    var submenuDirection = this.option(\"submenuDirection\").toLowerCase();\n    var $rootItemWrapper = $rootItem.parent(\".\".concat(DX_MENU_ITEM_WRAPPER_CLASS));\n    var position = {\n      collision: \"flip\",\n      of: $rootItemWrapper,\n      offset: {\n        h: 0,\n        v: -1\n      }\n    };\n\n    switch (submenuDirection) {\n      case \"left\":\n        position.at = \"left top\";\n        position.my = \"right top\";\n        break;\n\n      case \"right\":\n        position.at = \"right top\";\n        position.my = \"left top\";\n        break;\n\n      default:\n        if (this.option(\"rtlEnabled\")) {\n          position.at = \"left top\";\n          position.my = \"right top\";\n        } else {\n          position.at = \"right top\";\n          position.my = \"left top\";\n        }\n\n    }\n\n    return position;\n  }\n\n  _updateSubmenuVisibilityOnClick(actionArgs) {\n    if (!actionArgs.args.length) {\n      return;\n    }\n\n    var itemData = actionArgs.args[0].itemData;\n\n    var node = this._dataAdapter.getNodeByItem(itemData);\n\n    if (!node) {\n      return;\n    }\n\n    var $itemElement = $(actionArgs.args[0].itemElement);\n    var $submenu = $itemElement.find(\".\".concat(DX_SUBMENU_CLASS));\n    var shouldRenderSubmenu = this._hasSubmenu(node) && !$submenu.length;\n\n    if (shouldRenderSubmenu) {\n      this._renderSubmenuItems(node, $itemElement);\n\n      $submenu = $itemElement.find(\".\".concat(DX_SUBMENU_CLASS));\n    }\n\n    if ($itemElement.context === $submenu.context && \"visible\" === $submenu.css(\"visibility\")) {\n      return;\n    }\n\n    this._updateSelectedItemOnClick(actionArgs);\n\n    var notCloseMenuOnItemClick = itemData && false === itemData.closeMenuOnClick;\n\n    if (!itemData || itemData.disabled || notCloseMenuOnItemClick) {\n      return;\n    }\n\n    if (0 === $submenu.length) {\n      var $prevSubmenu = $($itemElement.parents(\".\".concat(DX_SUBMENU_CLASS))[0]);\n\n      this._hideSubmenu($prevSubmenu);\n\n      if (!actionArgs.canceled && this._overlay && this._overlay.option(\"visible\")) {\n        this.option(\"visible\", false);\n      }\n    } else {\n      if (this._shownSubmenus && this._shownSubmenus.length > 0) {\n        if (this._shownSubmenus[0].is($submenu)) {\n          this._hideSubmenu($submenu);\n        }\n      }\n\n      this._showSubmenu($itemElement);\n    }\n  }\n\n  _hideSubmenu($curSubmenu) {\n    var shownSubmenus = extend([], this._shownSubmenus);\n    each(shownSubmenus, (index, $submenu) => {\n      if ($curSubmenu.is($submenu) || contains($curSubmenu[0], $submenu[0])) {\n        $submenu.parent().removeClass(DX_MENU_ITEM_EXPANDED_CLASS);\n\n        this._hideSubmenuCore($submenu);\n      }\n    });\n  }\n\n  _hideSubmenuCore($submenu) {\n    var index = this._shownSubmenus.indexOf($submenu);\n\n    var animation = this.option(\"animation\") ? this.option(\"animation\").hide : null;\n\n    if (index >= 0) {\n      this._shownSubmenus.splice(index, 1);\n    }\n\n    this._stopAnimate($submenu);\n\n    animation && this._animate($submenu, animation);\n    $submenu.css(\"visibility\", \"hidden\");\n  }\n\n  _stopAnimate($container) {\n    fx.stop($container, true);\n  }\n\n  _hideAllShownSubmenus() {\n    var shownSubmenus = extend([], this._shownSubmenus);\n\n    var $expandedItems = this._overlay.$content().find(\".\".concat(DX_MENU_ITEM_EXPANDED_CLASS));\n\n    $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);\n    each(shownSubmenus, (_, $submenu) => {\n      this._hideSubmenu($submenu);\n    });\n  }\n\n  _visibilityChanged(visible) {\n    if (visible) {\n      this._renderContentImpl();\n    }\n  }\n\n  _optionChanged(args) {\n    if (ACTIONS.includes(args.name)) {\n      this._initActions();\n\n      return;\n    }\n\n    switch (args.name) {\n      case \"visible\":\n        this._renderVisibility(args.value);\n\n        break;\n\n      case \"showEvent\":\n      case \"position\":\n      case \"submenuDirection\":\n        this._invalidate();\n\n        break;\n\n      case \"target\":\n        args.previousValue && this._detachShowContextMenuEvents(args.previousValue);\n\n        this._invalidate();\n\n        break;\n\n      case \"closeOnOutsideClick\":\n      case \"hideOnOutsideClick\":\n        break;\n\n      default:\n        super._optionChanged(args);\n\n    }\n  }\n\n  _renderVisibility(showing) {\n    return showing ? this._show() : this._hide();\n  }\n\n  _toggleVisibility() {}\n\n  _show(event) {\n    var args = {\n      jQEvent: event\n    };\n    var promise = new Deferred().reject().promise();\n\n    this._actions.onShowing(args);\n\n    if (args.cancel) {\n      return promise;\n    }\n\n    var position = this._positionContextMenu(event);\n\n    if (position) {\n      var _event$originalEvent;\n\n      if (!this._overlay) {\n        this._renderContextMenuOverlay();\n\n        this._overlay.$content().addClass(this._widgetClass());\n\n        this._renderFocusState();\n\n        this._attachHoverEvents();\n\n        this._attachClickEvent();\n\n        this._renderItems(this._dataAdapter.getRootNodes());\n      }\n\n      this._setOptionWithoutOptionChange(\"visible\", true);\n\n      this._overlay.option(\"position\", position);\n\n      promise = this._overlay.show();\n      event && event.stopPropagation();\n\n      this._setAriaAttributes();\n\n      if ((null === event || void 0 === event ? void 0 : null === (_event$originalEvent = event.originalEvent) || void 0 === _event$originalEvent ? void 0 : _event$originalEvent.type) === holdEvent.name) {\n        this.preventShowingDefaultContextMenuAboveOverlay();\n      }\n    }\n\n    return promise;\n  }\n\n  _setAriaAttributes() {\n    this._overlayContentId = \"dx-\".concat(new Guid());\n    this.setAria(\"owns\", this._overlayContentId);\n    this.setAria({\n      id: this._overlayContentId,\n      role: \"menu\"\n    }, this._overlay.$content());\n  }\n\n  _cleanAriaAttributes() {\n    this._overlay && this.setAria(\"id\", null, this._overlay.$content());\n    this.setAria(\"owns\", void 0);\n  }\n\n  _getTarget() {\n    return this.option(\"target\") || this.option(\"position\").of || $(domAdapter.getDocument());\n  }\n\n  _getContextMenuPosition() {\n    return extend({}, this.option(\"position\"), {\n      of: this._getTarget()\n    });\n  }\n\n  _positionContextMenu(jQEvent) {\n    var position = this._getContextMenuPosition();\n\n    var isInitialPosition = this._isInitialOptionValue(\"position\");\n\n    var positioningAction = this._createActionByOption(\"onPositioning\", actionArgs);\n\n    if (jQEvent && jQEvent.preventDefault && isInitialPosition) {\n      position.of = jQEvent;\n    }\n\n    var actionArgs = {\n      position: position,\n      event: jQEvent\n    };\n    positioningAction(actionArgs);\n\n    if (actionArgs.cancel) {\n      position = null;\n    } else if (actionArgs.event) {\n      actionArgs.event.cancel = true;\n      jQEvent.preventDefault();\n    }\n\n    return position;\n  }\n\n  _refresh() {\n    if (!hasWindow()) {\n      super._refresh();\n    } else if (this._overlay) {\n      var lastPosition = this._overlay.option(\"position\");\n\n      super._refresh();\n\n      this._overlay && this._overlay.option(\"position\", lastPosition);\n    } else {\n      super._refresh();\n    }\n  }\n\n  _hide() {\n    var promise;\n\n    if (this._overlay) {\n      promise = this._overlay.hide();\n\n      this._setOptionWithoutOptionChange(\"visible\", false);\n    }\n\n    this._cleanAriaAttributes();\n\n    this.option(\"focusedElement\", null);\n    return promise || new Deferred().reject().promise();\n  }\n\n  toggle(showing) {\n    var visible = this.option(\"visible\");\n    showing = void 0 === showing ? !visible : showing;\n    return this._renderVisibility(showing);\n  }\n\n  show() {\n    return this.toggle(true);\n  }\n\n  hide() {\n    return this.toggle(false);\n  }\n\n}\n\nregisterComponent(\"dxContextMenu\", ContextMenu);\nexport default ContextMenu;","map":null,"metadata":{},"sourceType":"module"}