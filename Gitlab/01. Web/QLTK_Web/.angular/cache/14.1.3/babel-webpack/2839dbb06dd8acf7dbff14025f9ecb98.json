{"ast":null,"code":"/**\r\n * DevExtreme (esm/renovation/ui/scheduler/utils/filtering/remote.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { equalByValue } from \"../../../../../core/utils/common\";\nimport { extend } from \"../../../../../core/utils/extend\";\nimport dateSerialization from \"../../../../../core/utils/date_serialization\";\nimport { isDefined, isString } from \"../../../../../core/utils/type\";\nimport getDatesWithoutTime from \"./getDatesWithoutTime\";\nvar FilterPosition = {\n  dateFilter: 0,\n  userFilter: 1\n};\n\nclass RemoteFilterCombiner {\n  constructor(options) {\n    this.options = options;\n  }\n\n  get dataAccessors() {\n    return this.options.dataAccessors;\n  }\n\n  get dataSourceFilter() {\n    return this.options.dataSourceFilter;\n  }\n\n  get dateSerializationFormat() {\n    return this.options.dateSerializationFormat;\n  }\n\n  get forceIsoDateParsing() {\n    return isDefined(this.options.forceIsoDateParsing) ? this.options.forceIsoDateParsing : true;\n  }\n\n  makeDateFilter(min, max) {\n    var {\n      endDateExpr: endDateExpr,\n      recurrenceRuleExpr: recurrenceRuleExpr,\n      startDateExpr: startDateExpr\n    } = this.dataAccessors.expr;\n    var dateFilter = [[[endDateExpr, \">=\", min], [startDateExpr, \"<\", max]], \"or\", [recurrenceRuleExpr, \"startswith\", \"freq\"], \"or\", [[endDateExpr, min], [startDateExpr, min]]];\n\n    if (!recurrenceRuleExpr) {\n      dateFilter.splice(1, 2);\n    }\n\n    return dateFilter;\n  }\n\n  combineFilters(dateFilter, userFilter) {\n    var combinedFilter = [];\n    dateFilter && combinedFilter.push(dateFilter);\n    userFilter && combinedFilter.push(userFilter);\n    return this.serializeRemoteFilter(combinedFilter);\n  }\n\n  serializeRemoteFilter(combinedFilter) {\n    if (!Array.isArray(combinedFilter)) {\n      return combinedFilter;\n    }\n\n    var {\n      endDateExpr: endDateExpr,\n      startDateExpr: startDateExpr\n    } = this.dataAccessors.expr;\n    var filter = extend([], combinedFilter);\n\n    if (isString(filter[0])) {\n      if (this.forceIsoDateParsing && filter.length > 1) {\n        if (filter[0] === startDateExpr || filter[0] === endDateExpr) {\n          var lastFilterValue = filter[filter.length - 1];\n          filter[filter.length - 1] = dateSerialization.serializeDate(new Date(lastFilterValue), this.dateSerializationFormat);\n        }\n      }\n    }\n\n    for (var i = 0; i < filter.length; i += 1) {\n      filter[i] = this.serializeRemoteFilter(filter[i]);\n    }\n\n    return filter;\n  }\n\n  getUserFilter(dateFilter) {\n    if (!this.dataSourceFilter || equalByValue(this.dataSourceFilter, dateFilter)) {\n      return;\n    }\n\n    var containsDateFilter = this.dataSourceFilter.length > 0 && equalByValue(this.dataSourceFilter[FilterPosition.dateFilter], dateFilter);\n    var userFilter = containsDateFilter ? this.dataSourceFilter[FilterPosition.userFilter] : this.dataSourceFilter;\n    return userFilter;\n  }\n\n  combine(min, max) {\n    var [trimMin, trimMax] = getDatesWithoutTime(min, max);\n    var dateFilter = this.makeDateFilter(trimMin, trimMax);\n    var userFilter = this.getUserFilter(dateFilter);\n    var combinedFilter = this.combineFilters(dateFilter, userFilter);\n    return combinedFilter;\n  }\n\n}\n\nvar combineRemoteFilter = options => new RemoteFilterCombiner(options).combine(options.min, options.max);\n\nexport default combineRemoteFilter;","map":null,"metadata":{},"sourceType":"module"}