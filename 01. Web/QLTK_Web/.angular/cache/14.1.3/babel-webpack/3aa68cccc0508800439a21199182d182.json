{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/grid_core/ui.grid_core.virtual_columns.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getWidth, getOuterWidth } from \"../../core/utils/size\";\nimport { hasWindow } from \"../../core/utils/window\";\nimport { createColumnsInfo } from \"./ui.grid_core.virtual_columns_core\";\nimport { isDefined } from \"../../core/utils/type\";\nvar DEFAULT_COLUMN_WIDTH = 50;\nvar VirtualScrollingRowsViewExtender = {\n  _resizeCore: function () {\n    this.callBase.apply(this, arguments);\n\n    this._columnsController.resize();\n  },\n  _handleScroll: function (e) {\n    var that = this;\n    var scrollable = this.getScrollable();\n    var left = e.scrollOffset.left;\n    that.callBase.apply(that, arguments);\n\n    if (that.option(\"rtlEnabled\") && scrollable) {\n      left = getWidth(scrollable.$content()) - getWidth(scrollable.$element()) - left;\n    }\n\n    that._columnsController.setScrollPosition(left);\n  }\n};\nvar HeaderViewExtender = {\n  _renderCore: function () {\n    this.callBase.apply(this, arguments);\n\n    if (this._columnsController.isVirtualMode()) {\n      this._updateScrollLeftPosition();\n    }\n  }\n};\n\nvar ColumnsControllerExtender = function () {\n  var getWidths = function (columns) {\n    return columns.map(column => column.visibleWidth || parseFloat(column.width) || DEFAULT_COLUMN_WIDTH);\n  };\n\n  var members = {\n    init: function () {\n      var that = this;\n      that.callBase.apply(this, arguments);\n      that._beginPageIndex = null;\n      that._endPageIndex = null;\n      that._position = 0;\n      that._virtualVisibleColumns = {};\n    },\n    resetColumnsCache: function () {\n      this.callBase();\n      this._virtualVisibleColumns = {};\n    },\n    getBeginPageIndex: function (position) {\n      var visibleColumns = this.getVisibleColumns(void 0, true);\n      var widths = getWidths(visibleColumns);\n      var currentPosition = 0;\n\n      for (var index = 0; index < widths.length; index++) {\n        if (currentPosition >= position) {\n          return Math.floor(index / this.getColumnPageSize());\n        }\n\n        currentPosition += widths[index];\n      }\n\n      return 0;\n    },\n    getTotalWidth: function () {\n      var width = this.option(\"width\");\n\n      if (\"number\" === typeof width) {\n        return width;\n      }\n\n      return this.getController(\"resizing\")._lastWidth || getOuterWidth(this.component.$element());\n    },\n    getEndPageIndex: function (position) {\n      var visibleColumns = this.getVisibleColumns(void 0, true);\n      var widths = getWidths(visibleColumns);\n      var currentPosition = 0;\n      position += this.getTotalWidth();\n\n      for (var index = 0; index < widths.length; index++) {\n        if (currentPosition >= position) {\n          return Math.ceil(index / this.getColumnPageSize());\n        }\n\n        currentPosition += widths[index];\n      }\n\n      return Math.ceil(widths.length / this.getColumnPageSize());\n    },\n    getColumnPageSize: function () {\n      return this.option(\"scrolling.columnPageSize\");\n    },\n    _fireColumnsChanged: function () {\n      var date = new Date();\n      this.columnsChanged.fire({\n        optionNames: {\n          all: true,\n          length: 1\n        },\n        changeTypes: {\n          columns: true,\n          virtualColumnsScrolling: true,\n          length: 2\n        }\n      });\n      this._renderTime = new Date() - date;\n    },\n    getScrollingTimeout: function () {\n      var renderingThreshold = this.option(\"scrolling.columnRenderingThreshold\");\n      var renderAsync = this.option(\"scrolling.renderAsync\");\n      var scrollingTimeout = 0;\n\n      if (!isDefined(renderAsync) && this._renderTime > renderingThreshold || renderAsync) {\n        scrollingTimeout = this.option(\"scrolling.timeout\");\n      }\n\n      return scrollingTimeout;\n    },\n    setScrollPosition: function (position) {\n      var scrollingTimeout = this.getScrollingTimeout();\n\n      if (scrollingTimeout > 0) {\n        clearTimeout(this._changedTimeout);\n        this._changedTimeout = setTimeout(() => {\n          this._setScrollPositionCore(position);\n        }, scrollingTimeout);\n      } else {\n        this._setScrollPositionCore(position);\n      }\n    },\n    isVirtualMode: function () {\n      return hasWindow() && \"virtual\" === this.option(\"scrolling.columnRenderingMode\");\n    },\n    resize: function () {\n      this._setScrollPositionCore(this._position);\n    },\n    _setScrollPositionCore: function (position) {\n      if (this.isVirtualMode()) {\n        var beginPageIndex = this.getBeginPageIndex(position);\n        var endPageIndex = this.getEndPageIndex(position);\n        var needColumnsChanged = position < this._position ? this._beginPageIndex > beginPageIndex : this._endPageIndex < endPageIndex;\n        this._position = position;\n\n        if (needColumnsChanged) {\n          this._beginPageIndex = beginPageIndex;\n          this._endPageIndex = endPageIndex;\n\n          this._fireColumnsChanged();\n        }\n      }\n    },\n    getFixedColumns: function (rowIndex, isBase) {\n      var fixedColumns = this.callBase(rowIndex);\n\n      if (this.isVirtualMode() && !isBase && fixedColumns.length) {\n        var transparentColumnIndex = fixedColumns.map(c => c.command).indexOf(\"transparent\");\n        fixedColumns[transparentColumnIndex].colspan = this.getVisibleColumns().length - this.callBase().length + 1;\n        return fixedColumns;\n      }\n\n      return fixedColumns;\n    },\n    getVisibleColumns: function (rowIndex, isBase) {\n      var _this$_columns;\n\n      if (isBase || !this.isVirtualMode()) {\n        return this.callBase(rowIndex);\n      }\n\n      if (null !== (_this$_columns = this._columns) && void 0 !== _this$_columns && _this$_columns.length && !isDefined(this._beginPageIndex) && !isDefined(this._endPageIndex)) {\n        this._beginPageIndex = this.getBeginPageIndex(this._position);\n        this._endPageIndex = this.getEndPageIndex(this._position);\n      }\n\n      var beginPageIndex = this._beginPageIndex;\n      var endPageIndex = this._endPageIndex;\n      var visibleColumnsHash = rowIndex + \"-\" + beginPageIndex + \"-\" + endPageIndex;\n\n      if (this._virtualVisibleColumns[visibleColumnsHash]) {\n        return this._virtualVisibleColumns[visibleColumnsHash];\n      }\n\n      var visibleColumns = this.callBase();\n      var rowCount = this.getRowCount();\n      var pageSize = this.getColumnPageSize();\n      var startIndex = beginPageIndex * pageSize;\n      var endIndex = endPageIndex * pageSize;\n      var fixedColumns = this.getFixedColumns(void 0, true);\n      var transparentColumnIndex = fixedColumns.map(c => c.command).indexOf(\"transparent\");\n      var beginFixedColumnCount = fixedColumns.length ? transparentColumnIndex : 0;\n      var beginFixedColumns = visibleColumns.slice(0, beginFixedColumnCount);\n      var beginColumns = visibleColumns.slice(beginFixedColumnCount, startIndex);\n      var beginWidth = getWidths(beginColumns).reduce((a, b) => a + b, 0);\n\n      if (!beginWidth) {\n        startIndex = 0;\n      }\n\n      var endFixedColumnCount = fixedColumns.length ? fixedColumns.length - transparentColumnIndex - 1 : 0;\n      var endFixedColumns = visibleColumns.slice(visibleColumns.length - endFixedColumnCount);\n      var endColumns = visibleColumns.slice(endIndex, visibleColumns.length - endFixedColumnCount);\n      var endWidth = getWidths(endColumns).reduce((a, b) => a + b, 0);\n\n      if (!endWidth) {\n        endIndex = visibleColumns.length;\n      }\n\n      if (rowCount > 1 && \"number\" === typeof rowIndex) {\n        var columnsInfo = [];\n\n        for (var i = 0; i < rowCount; i++) {\n          columnsInfo.push(this.callBase(i));\n        }\n\n        beginFixedColumns = createColumnsInfo(columnsInfo, 0, beginFixedColumns.length)[rowIndex] || [];\n        endFixedColumns = createColumnsInfo(columnsInfo, visibleColumns.length - endFixedColumns.length, visibleColumns.length)[rowIndex] || [];\n        visibleColumns = createColumnsInfo(columnsInfo, startIndex, endIndex)[rowIndex] || [];\n      } else {\n        visibleColumns = visibleColumns.slice(startIndex, endIndex);\n      }\n\n      if (beginWidth) {\n        visibleColumns.unshift({\n          command: \"virtual\",\n          width: beginWidth\n        });\n        visibleColumns = beginFixedColumns.concat(visibleColumns);\n      }\n\n      if (endWidth) {\n        visibleColumns.push({\n          command: \"virtual\",\n          width: endWidth\n        });\n        visibleColumns = visibleColumns.concat(endFixedColumns);\n      }\n\n      this._virtualVisibleColumns[visibleColumnsHash] = visibleColumns;\n      return visibleColumns;\n    },\n    getColumnIndexOffset: function () {\n      var offset = 0;\n\n      if (this._beginPageIndex > 0) {\n        var fixedColumns = this.getFixedColumns();\n        var transparentColumnIndex = fixedColumns.map(c => c.command).indexOf(\"transparent\");\n        var leftFixedColumnCount = transparentColumnIndex >= 0 ? transparentColumnIndex : 0;\n        offset = this._beginPageIndex * this.getColumnPageSize() - leftFixedColumnCount - 1;\n      }\n\n      return offset > 0 ? offset : 0;\n    },\n    dispose: function () {\n      clearTimeout(this._changedTimeout);\n      this.callBase.apply(this, arguments);\n    }\n  };\n  return members;\n}();\n\nexport var virtualColumnsModule = {\n  defaultOptions: function () {\n    return {\n      scrolling: {\n        columnRenderingMode: \"standard\",\n        columnPageSize: 5,\n        columnRenderingThreshold: 300\n      }\n    };\n  },\n  extenders: {\n    controllers: {\n      columns: ColumnsControllerExtender\n    },\n    views: {\n      columnHeadersView: HeaderViewExtender,\n      rowsView: VirtualScrollingRowsViewExtender\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}