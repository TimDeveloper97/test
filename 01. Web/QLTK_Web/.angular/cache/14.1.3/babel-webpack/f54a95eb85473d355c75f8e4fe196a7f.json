{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/menu/ui.menu.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getOuterWidth } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport registerComponent from \"../../core/component_registrator\";\nimport { noop } from \"../../core/utils/common\";\nimport { getPublicElement } from \"../../core/element\";\nimport { each } from \"../../core/utils/iterator\";\nimport { isPlainObject, isObject, isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { getElementMaxHeightByWindow } from \"../overlay/utils\";\nimport { addNamespace } from \"../../events/utils/index\";\nimport pointerEvents from \"../../events/pointer\";\nimport { end as hoverEventEnd } from \"../../events/hover\";\nimport MenuBase from \"../context_menu/ui.menu_base\";\nimport Overlay from \"../overlay/ui.overlay\";\nimport Submenu from \"./ui.submenu\";\nimport Button from \"../button\";\nimport TreeView from \"../tree_view\";\nvar DX_MENU_CLASS = \"dx-menu\";\nvar DX_MENU_VERTICAL_CLASS = DX_MENU_CLASS + \"-vertical\";\nvar DX_MENU_HORIZONTAL_CLASS = DX_MENU_CLASS + \"-horizontal\";\nvar DX_MENU_ITEM_CLASS = DX_MENU_CLASS + \"-item\";\nvar DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + \"-items-container\";\nvar DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + \"-expanded\";\nvar DX_CONTEXT_MENU_CLASS = \"dx-context-menu\";\nvar DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS = DX_CONTEXT_MENU_CLASS + \"-container-border\";\nvar DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = \"dx-context-menu-content-delimiter\";\nvar DX_SUBMENU_CLASS = \"dx-submenu\";\nvar DX_STATE_DISABLED_CLASS = \"dx-state-disabled\";\nvar DX_STATE_HOVER_CLASS = \"dx-state-hover\";\nvar DX_STATE_ACTIVE_CLASS = \"dx-state-active\";\nvar DX_ADAPTIVE_MODE_CLASS = DX_MENU_CLASS + \"-adaptive-mode\";\nvar DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS = DX_MENU_CLASS + \"-hamburger-button\";\nvar DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS = DX_ADAPTIVE_MODE_CLASS + \"-overlay-wrapper\";\nvar FOCUS_UP = \"up\";\nvar FOCUS_DOWN = \"down\";\nvar FOCUS_LEFT = \"left\";\nvar FOCUS_RIGHT = \"right\";\nvar SHOW_SUBMENU_OPERATION = \"showSubmenu\";\nvar NEXTITEM_OPERATION = \"nextItem\";\nvar PREVITEM_OPERATION = \"prevItem\";\nvar DEFAULT_DELAY = {\n  show: 50,\n  hide: 300\n};\nvar ACTIONS = [\"onSubmenuShowing\", \"onSubmenuShown\", \"onSubmenuHiding\", \"onSubmenuHidden\", \"onItemContextMenu\", \"onItemClick\", \"onSelectionChanged\", \"onItemRendered\"];\n\nclass Menu extends MenuBase {\n  _getDefaultOptions() {\n    return extend(super._getDefaultOptions(), {\n      orientation: \"horizontal\",\n      submenuDirection: \"auto\",\n      showFirstSubmenuMode: {\n        name: \"onClick\",\n        delay: {\n          show: 50,\n          hide: 300\n        }\n      },\n      hideSubmenuOnMouseLeave: false,\n      onSubmenuShowing: null,\n      onSubmenuShown: null,\n      onSubmenuHiding: null,\n      onSubmenuHidden: null,\n      adaptivityEnabled: false\n    });\n  }\n\n  _setOptionsByReference() {\n    super._setOptionsByReference();\n\n    extend(this._optionsByReference, {\n      animation: true,\n      selectedItem: true\n    });\n  }\n\n  _itemElements() {\n    var rootMenuElements = super._itemElements();\n\n    var submenuElements = this._submenuItemElements();\n\n    return rootMenuElements.add(submenuElements);\n  }\n\n  _submenuItemElements() {\n    var elements = [];\n    var itemSelector = \".\".concat(DX_MENU_ITEM_CLASS);\n    var currentSubmenu = this._submenus.length && this._submenus[0];\n\n    if (currentSubmenu && currentSubmenu.itemsContainer()) {\n      elements = currentSubmenu.itemsContainer().find(itemSelector);\n    }\n\n    return elements;\n  }\n\n  _focusTarget() {\n    return this.$element();\n  }\n\n  _isMenuHorizontal() {\n    return \"horizontal\" === this.option(\"orientation\");\n  }\n\n  _moveFocus(location) {\n    var $items = this._getAvailableItems();\n\n    var isMenuHorizontal = this._isMenuHorizontal();\n\n    var $activeItem = this._getActiveItem(true);\n\n    var argument;\n    var operation;\n    var navigationAction;\n    var $newTarget;\n\n    switch (location) {\n      case FOCUS_UP:\n        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(PREVITEM_OPERATION);\n        argument = isMenuHorizontal ? $activeItem : $items;\n        navigationAction = this._getKeyboardNavigationAction(operation, argument);\n        $newTarget = navigationAction();\n        break;\n\n      case FOCUS_DOWN:\n        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(NEXTITEM_OPERATION);\n        argument = isMenuHorizontal ? $activeItem : $items;\n        navigationAction = this._getKeyboardNavigationAction(operation, argument);\n        $newTarget = navigationAction();\n        break;\n\n      case FOCUS_RIGHT:\n        operation = isMenuHorizontal ? this._getItemsNavigationOperation(NEXTITEM_OPERATION) : SHOW_SUBMENU_OPERATION;\n        argument = isMenuHorizontal ? $items : $activeItem;\n        navigationAction = this._getKeyboardNavigationAction(operation, argument);\n        $newTarget = navigationAction();\n        break;\n\n      case FOCUS_LEFT:\n        operation = isMenuHorizontal ? this._getItemsNavigationOperation(PREVITEM_OPERATION) : SHOW_SUBMENU_OPERATION;\n        argument = isMenuHorizontal ? $items : $activeItem;\n        navigationAction = this._getKeyboardNavigationAction(operation, argument);\n        $newTarget = navigationAction();\n        break;\n\n      default:\n        return super._moveFocus(location);\n    }\n\n    if ($newTarget && 0 !== $newTarget.length) {\n      this.option(\"focusedElement\", getPublicElement($newTarget));\n    }\n  }\n\n  _getItemsNavigationOperation(operation) {\n    var navOperation = operation;\n\n    if (this.option(\"rtlEnabled\")) {\n      navOperation = operation === PREVITEM_OPERATION ? NEXTITEM_OPERATION : PREVITEM_OPERATION;\n    }\n\n    return navOperation;\n  }\n\n  _getKeyboardNavigationAction(operation, argument) {\n    var action = noop;\n\n    switch (operation) {\n      case SHOW_SUBMENU_OPERATION:\n        if (!argument.hasClass(DX_STATE_DISABLED_CLASS)) {\n          action = this._showSubmenu.bind(this, argument);\n        }\n\n        break;\n\n      case NEXTITEM_OPERATION:\n        action = this._nextItem.bind(this, argument);\n        break;\n\n      case PREVITEM_OPERATION:\n        action = this._prevItem.bind(this, argument);\n    }\n\n    return action;\n  }\n\n  _clean() {\n    super._clean();\n\n    this.option(\"templatesRenderAsynchronously\") && clearTimeout(this._resizeEventTimer);\n  }\n\n  _visibilityChanged(visible) {\n    if (visible) {\n      if (!this._menuItemsWidth) {\n        this._updateItemsWidthCache();\n      }\n\n      this._dimensionChanged();\n    }\n  }\n\n  _isAdaptivityEnabled() {\n    return this.option(\"adaptivityEnabled\") && \"horizontal\" === this.option(\"orientation\");\n  }\n\n  _updateItemsWidthCache() {\n    var $menuItems = this.$element().find(\"ul\").first().children(\"li\").children(\".\".concat(DX_MENU_ITEM_CLASS));\n    this._menuItemsWidth = this._getSummaryItemsWidth($menuItems, true);\n  }\n\n  _dimensionChanged() {\n    if (!this._isAdaptivityEnabled()) {\n      return;\n    }\n\n    var containerWidth = getOuterWidth(this.$element());\n\n    this._toggleAdaptiveMode(this._menuItemsWidth > containerWidth);\n  }\n\n  _init() {\n    super._init();\n\n    this._submenus = [];\n  }\n\n  _initActions() {\n    this._actions = {};\n    each(ACTIONS, (index, action) => {\n      this._actions[action] = this._createActionByOption(action);\n    });\n  }\n\n  _initMarkup() {\n    this._visibleSubmenu = null;\n    this.$element().addClass(DX_MENU_CLASS);\n\n    super._initMarkup();\n\n    this._addCustomCssClass(this.$element());\n\n    this.setAria(\"role\", \"menubar\");\n  }\n\n  _render() {\n    super._render();\n\n    this._initAdaptivity();\n  }\n\n  _renderHamburgerButton() {\n    this._hamburger = new Button($(\"<div>\").addClass(DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS), {\n      icon: \"menu\",\n      activeStateEnabled: false,\n      onClick: this._toggleTreeView.bind(this)\n    });\n    return this._hamburger.$element();\n  }\n\n  _toggleTreeView(state) {\n    if (isPlainObject(state)) {\n      state = !this._overlay.option(\"visible\");\n    }\n\n    this._overlay.option(\"visible\", state);\n\n    this._toggleHamburgerActiveState(state);\n  }\n\n  _toggleHamburgerActiveState(state) {\n    this._hamburger && this._hamburger.$element().toggleClass(DX_STATE_ACTIVE_CLASS, state);\n  }\n\n  _toggleAdaptiveMode(state) {\n    var $menuItemsContainer = this.$element().find(\".\".concat(DX_MENU_HORIZONTAL_CLASS));\n    var $adaptiveElements = this.$element().find(\".\".concat(DX_ADAPTIVE_MODE_CLASS));\n\n    if (state) {\n      this._hideVisibleSubmenu();\n    } else {\n      this._treeView && this._treeView.collapseAll();\n      this._overlay && this._toggleTreeView(state);\n    }\n\n    $menuItemsContainer.toggle(!state);\n    $adaptiveElements.toggle(state);\n  }\n\n  _removeAdaptivity() {\n    if (!this._$adaptiveContainer) {\n      return;\n    }\n\n    this._toggleAdaptiveMode(false);\n\n    this._$adaptiveContainer.remove();\n\n    this._$adaptiveContainer = null;\n    this._treeView = null;\n    this._hamburger = null;\n    this._overlay = null;\n  }\n\n  _treeviewItemClickHandler(e) {\n    this._actions.onItemClick(e);\n\n    if (!e.node.children.length) {\n      this._toggleTreeView(false);\n    }\n  }\n\n  _getAdaptiveOverlayOptions() {\n    var rtl = this.option(\"rtlEnabled\");\n    var position = rtl ? \"right\" : \"left\";\n    return {\n      _ignoreFunctionValueDeprecation: true,\n      maxHeight: () => getElementMaxHeightByWindow(this.$element()),\n      deferRendering: false,\n      shading: false,\n      animation: false,\n      hideOnParentScroll: true,\n      onHidden: () => {\n        this._toggleHamburgerActiveState(false);\n      },\n      height: \"auto\",\n      hideOnOutsideClick: e => !$(e.target).closest(\".\".concat(DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS)).length,\n      position: {\n        collision: \"flipfit\",\n        at: \"bottom \" + position,\n        my: \"top \" + position,\n        of: this._hamburger.$element()\n      }\n    };\n  }\n\n  _getTreeViewOptions() {\n    var menuOptions = {};\n    each([\"rtlEnabled\", \"width\", \"accessKey\", \"activeStateEnabled\", \"animation\", \"dataSource\", \"disabled\", \"displayExpr\", \"displayExpr\", \"focusStateEnabled\", \"hint\", \"hoverStateEnabled\", \"itemsExpr\", \"items\", \"itemTemplate\", \"selectedExpr\", \"selectionMode\", \"tabIndex\", \"visible\"], (_, option) => {\n      menuOptions[option] = this.option(option);\n    });\n    each([\"onItemContextMenu\", \"onSelectionChanged\", \"onItemRendered\"], (_, actionName) => {\n      menuOptions[actionName] = e => {\n        this._actions[actionName](e);\n      };\n    });\n    return extend(menuOptions, {\n      dataSource: this.getDataSource(),\n      animationEnabled: !!this.option(\"animation\"),\n      onItemClick: this._treeviewItemClickHandler.bind(this),\n      onItemExpanded: e => {\n        this._overlay.repaint();\n\n        this._actions.onSubmenuShown(e);\n      },\n      onItemCollapsed: e => {\n        this._overlay.repaint();\n\n        this._actions.onSubmenuHidden(e);\n      },\n      selectNodesRecursive: false,\n      selectByClick: this.option(\"selectByClick\"),\n      expandEvent: \"click\"\n    });\n  }\n\n  _initAdaptivity() {\n    if (!this._isAdaptivityEnabled()) {\n      return;\n    }\n\n    this._$adaptiveContainer = $(\"<div>\").addClass(DX_ADAPTIVE_MODE_CLASS);\n\n    var $hamburger = this._renderHamburgerButton();\n\n    this._treeView = this._createComponent($(\"<div>\"), TreeView, this._getTreeViewOptions());\n    this._overlay = this._createComponent($(\"<div>\"), Overlay, this._getAdaptiveOverlayOptions());\n\n    this._overlay.$content().append(this._treeView.$element()).addClass(DX_ADAPTIVE_MODE_CLASS).addClass(this.option(\"cssClass\"));\n\n    this._overlay.$wrapper().addClass(DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS);\n\n    this._$adaptiveContainer.append($hamburger);\n\n    this._$adaptiveContainer.append(this._overlay.$element());\n\n    this.$element().append(this._$adaptiveContainer);\n\n    this._updateItemsWidthCache();\n\n    this._dimensionChanged();\n  }\n\n  _getDelay(delayType) {\n    var delay = this.option(\"showFirstSubmenuMode\").delay;\n\n    if (!isDefined(delay)) {\n      return DEFAULT_DELAY[delayType];\n    } else {\n      return isObject(delay) ? delay[delayType] : delay;\n    }\n  }\n\n  _keyboardHandler(e) {\n    return super._keyboardHandler(e, !!this._visibleSubmenu);\n  }\n\n  _renderContainer() {\n    var $wrapper = $(\"<div>\");\n    $wrapper.appendTo(this.$element()).addClass(this._isMenuHorizontal() ? DX_MENU_HORIZONTAL_CLASS : DX_MENU_VERTICAL_CLASS);\n    return super._renderContainer($wrapper);\n  }\n\n  _renderSubmenuItems(node, $itemFrame) {\n    var submenu = this._createSubmenu(node, $itemFrame);\n\n    this._submenus.push(submenu);\n\n    this._renderBorderElement($itemFrame);\n\n    return submenu;\n  }\n\n  _getKeyboardListeners() {\n    return super._getKeyboardListeners().concat(this._visibleSubmenu);\n  }\n\n  _createSubmenu(node, $rootItem) {\n    var $submenuContainer = $(\"<div>\").addClass(DX_CONTEXT_MENU_CLASS).appendTo($rootItem);\n\n    var items = this._getChildNodes(node);\n\n    var subMenu = this._createComponent($submenuContainer, Submenu, extend(this._getSubmenuOptions(), {\n      _dataAdapter: this._dataAdapter,\n      _parentKey: node.internalFields.key,\n      items: items,\n      onHoverStart: this._clearTimeouts.bind(this),\n      position: this.getSubmenuPosition($rootItem)\n    }));\n\n    this._attachSubmenuHandlers($rootItem, subMenu);\n\n    return subMenu;\n  }\n\n  _getSubmenuOptions() {\n    var $submenuTarget = $(\"<div>\");\n\n    var isMenuHorizontal = this._isMenuHorizontal();\n\n    return {\n      itemTemplate: this.option(\"itemTemplate\"),\n      target: $submenuTarget,\n      orientation: this.option(\"orientation\"),\n      selectionMode: this.option(\"selectionMode\"),\n      cssClass: this.option(\"cssClass\"),\n      selectByClick: this.option(\"selectByClick\"),\n      hoverStateEnabled: this.option(\"hoverStateEnabled\"),\n      activeStateEnabled: this.option(\"activeStateEnabled\"),\n      focusStateEnabled: this.option(\"focusStateEnabled\"),\n      animation: this.option(\"animation\"),\n      showSubmenuMode: this.option(\"showSubmenuMode\"),\n      displayExpr: this.option(\"displayExpr\"),\n      disabledExpr: this.option(\"disabledExpr\"),\n      selectedExpr: this.option(\"selectedExpr\"),\n      itemsExpr: this.option(\"itemsExpr\"),\n      onFocusedItemChanged: e => {\n        if (!e.component.option(\"visible\")) {\n          return;\n        }\n\n        this.option(\"focusedElement\", e.component.option(\"focusedElement\"));\n      },\n      onSelectionChanged: this._nestedItemOnSelectionChangedHandler.bind(this),\n      onItemClick: this._nestedItemOnItemClickHandler.bind(this),\n      onItemRendered: this._nestedItemOnItemRenderedHandler.bind(this),\n      onLeftFirstItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, PREVITEM_OPERATION),\n      onLeftLastItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, NEXTITEM_OPERATION),\n      onCloseRootSubmenu: this._moveMainMenuFocus.bind(this, isMenuHorizontal ? PREVITEM_OPERATION : null),\n      onExpandLastSubmenu: isMenuHorizontal ? this._moveMainMenuFocus.bind(this, NEXTITEM_OPERATION) : null\n    };\n  }\n\n  _getShowFirstSubmenuMode() {\n    if (!this._isDesktopDevice()) {\n      return \"onClick\";\n    }\n\n    var optionValue = this.option(\"showFirstSubmenuMode\");\n    return isObject(optionValue) ? optionValue.name : optionValue;\n  }\n\n  _moveMainMenuFocus(direction) {\n    var $items = this._getAvailableItems();\n\n    var itemCount = $items.length;\n    var $currentItem = $items.filter(\".\".concat(DX_MENU_ITEM_EXPANDED_CLASS)).eq(0);\n    var itemIndex = $items.index($currentItem);\n\n    this._hideSubmenu(this._visibleSubmenu);\n\n    itemIndex += direction === PREVITEM_OPERATION ? -1 : 1;\n\n    if (itemIndex >= itemCount) {\n      itemIndex = 0;\n    } else if (itemIndex < 0) {\n      itemIndex = itemCount - 1;\n    }\n\n    var $newItem = $items.eq(itemIndex);\n    this.option(\"focusedElement\", getPublicElement($newItem));\n  }\n\n  _nestedItemOnSelectionChangedHandler(args) {\n    var selectedItem = args.addedItems.length && args.addedItems[0];\n    var submenu = Submenu.getInstance(args.element);\n    var onSelectionChanged = this._actions.onSelectionChanged;\n    onSelectionChanged(args);\n    selectedItem && this._clearSelectionInSubmenus(selectedItem[0], submenu);\n\n    this._clearRootSelection();\n\n    this._setOptionWithoutOptionChange(\"selectedItem\", selectedItem);\n  }\n\n  _clearSelectionInSubmenus(item, targetSubmenu) {\n    var cleanAllSubmenus = !arguments.length;\n    each(this._submenus, (index, submenu) => {\n      var $submenu = submenu._itemContainer();\n\n      var isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer());\n      var $selectedItem = $submenu.find(\".\".concat(this._selectedItemClass()));\n\n      if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {\n        $selectedItem.removeClass(this._selectedItemClass());\n\n        var selectedItemData = this._getItemData($selectedItem);\n\n        if (selectedItemData) {\n          selectedItemData.selected = false;\n        }\n\n        submenu._clearSelectedItems();\n      }\n    });\n  }\n\n  _clearRootSelection() {\n    var $prevSelectedItem = this.$element().find(\".\".concat(DX_MENU_ITEMS_CONTAINER_CLASS)).first().children().children().filter(\".\".concat(this._selectedItemClass()));\n\n    if ($prevSelectedItem.length) {\n      var prevSelectedItemData = this._getItemData($prevSelectedItem);\n\n      prevSelectedItemData.selected = false;\n      $prevSelectedItem.removeClass(this._selectedItemClass());\n    }\n  }\n\n  _nestedItemOnItemClickHandler(e) {\n    this._actions.onItemClick(e);\n  }\n\n  _nestedItemOnItemRenderedHandler(e) {\n    this._actions.onItemRendered(e);\n  }\n\n  _attachSubmenuHandlers($rootItem, submenu) {\n    var $submenuOverlayContent = submenu.getOverlayContent();\n    var submenus = $submenuOverlayContent.find(\".\".concat(DX_SUBMENU_CLASS));\n    var submenuMouseLeaveName = addNamespace(hoverEventEnd, this.NAME + \"_submenu\");\n    submenu.option({\n      onShowing: this._submenuOnShowingHandler.bind(this, $rootItem, submenu),\n      onShown: this._submenuOnShownHandler.bind(this, $rootItem, submenu),\n      onHiding: this._submenuOnHidingHandler.bind(this, $rootItem, submenu),\n      onHidden: this._submenuOnHiddenHandler.bind(this, $rootItem, submenu)\n    });\n    each(submenus, (index, submenu) => {\n      eventsEngine.off(submenu, submenuMouseLeaveName);\n      eventsEngine.on(submenu, submenuMouseLeaveName, null, this._submenuMouseLeaveHandler.bind(this, $rootItem));\n    });\n  }\n\n  _submenuOnShowingHandler($rootItem, submenu) {\n    var $border = $rootItem.children(\".\".concat(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS));\n\n    this._actions.onSubmenuShowing({\n      rootItem: getPublicElement($rootItem),\n      submenu: submenu\n    });\n\n    $border.show();\n    $rootItem.addClass(DX_MENU_ITEM_EXPANDED_CLASS);\n  }\n\n  _submenuOnShownHandler($rootItem, submenu) {\n    this._actions.onSubmenuShown({\n      rootItem: getPublicElement($rootItem),\n      submenu: submenu\n    });\n  }\n\n  _submenuOnHidingHandler($rootItem, submenu, eventArgs) {\n    var $border = $rootItem.children(\".\".concat(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS));\n    var args = eventArgs;\n    args.rootItem = getPublicElement($rootItem);\n    args.submenu = submenu;\n\n    this._actions.onSubmenuHiding(args);\n\n    eventArgs = args;\n\n    if (!eventArgs.cancel) {\n      if (this._visibleSubmenu === submenu) {\n        this._visibleSubmenu = null;\n      }\n\n      $border.hide();\n      $rootItem.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);\n    }\n  }\n\n  _submenuOnHiddenHandler($rootItem, submenu) {\n    this._actions.onSubmenuHidden({\n      rootItem: getPublicElement($rootItem),\n      submenu: submenu\n    });\n  }\n\n  _submenuMouseLeaveHandler($rootItem, eventArgs) {\n    var target = $(eventArgs.relatedTarget).parents(\".\".concat(DX_CONTEXT_MENU_CLASS))[0];\n\n    var contextMenu = this._getSubmenuByRootElement($rootItem).getOverlayContent()[0];\n\n    if (this.option(\"hideSubmenuOnMouseLeave\") && target !== contextMenu) {\n      this._clearTimeouts();\n\n      setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay(\"hide\"));\n    }\n  }\n\n  _hideSubmenuAfterTimeout() {\n    if (!this._visibleSubmenu) {\n      return;\n    }\n\n    var isRootItemHovered = $(this._visibleSubmenu.$element().context).hasClass(DX_STATE_HOVER_CLASS);\n\n    var isSubmenuItemHovered = this._visibleSubmenu.getOverlayContent().find(\".\".concat(DX_STATE_HOVER_CLASS)).length;\n\n    var hoveredElementFromSubMenu = this._visibleSubmenu.getOverlayContent().get(0).querySelector(\":hover\");\n\n    if (!hoveredElementFromSubMenu && !isSubmenuItemHovered && !isRootItemHovered) {\n      this._visibleSubmenu.hide();\n    }\n  }\n\n  _getSubmenuByRootElement($rootItem) {\n    if (!$rootItem) {\n      return false;\n    }\n\n    var $submenu = $rootItem.children(\".\".concat(DX_CONTEXT_MENU_CLASS));\n    return $submenu.length && Submenu.getInstance($submenu);\n  }\n\n  getSubmenuPosition($rootItem) {\n    var isHorizontalMenu = this._isMenuHorizontal();\n\n    var submenuDirection = this.option(\"submenuDirection\").toLowerCase();\n    var rtlEnabled = this.option(\"rtlEnabled\");\n    var submenuPosition = {\n      collision: \"flip\",\n      of: $rootItem\n    };\n\n    switch (submenuDirection) {\n      case \"leftortop\":\n        submenuPosition.at = \"left top\";\n        submenuPosition.my = isHorizontalMenu ? \"left bottom\" : \"right top\";\n        break;\n\n      case \"rightorbottom\":\n        submenuPosition.at = isHorizontalMenu ? \"left bottom\" : \"right top\";\n        submenuPosition.my = \"left top\";\n        break;\n\n      default:\n        if (isHorizontalMenu) {\n          submenuPosition.at = rtlEnabled ? \"right bottom\" : \"left bottom\";\n          submenuPosition.my = rtlEnabled ? \"right top\" : \"left top\";\n        } else {\n          submenuPosition.at = rtlEnabled ? \"left top\" : \"right top\";\n          submenuPosition.my = rtlEnabled ? \"right top\" : \"left top\";\n        }\n\n    }\n\n    return submenuPosition;\n  }\n\n  _renderBorderElement($item) {\n    $(\"<div>\").appendTo($item).addClass(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS).hide();\n  }\n\n  _itemPointerDownHandler(e) {\n    var $target = $(e.target);\n    var $closestItem = $target.closest(this._itemElements());\n\n    if ($closestItem.hasClass(\"dx-menu-item-has-submenu\")) {\n      this.option(\"focusedElement\", null);\n      return;\n    }\n\n    super._itemPointerDownHandler(e);\n  }\n\n  _hoverStartHandler(e) {\n    var mouseMoveEventName = addNamespace(pointerEvents.move, this.NAME);\n\n    var $item = this._getItemElementByEventArgs(e);\n\n    var node = this._dataAdapter.getNodeByItem(this._getItemData($item));\n\n    var isSelectionActive = isDefined(e.buttons) && 1 === e.buttons || !isDefined(e.buttons) && 1 === e.which;\n\n    if (this._isItemDisabled($item)) {\n      return;\n    }\n\n    eventsEngine.off($item, mouseMoveEventName);\n\n    if (!this._hasChildren(node)) {\n      this._showSubmenuTimer = setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay(\"hide\"));\n      return;\n    }\n\n    if (\"onHover\" === this._getShowFirstSubmenuMode() && !isSelectionActive) {\n      var submenu = this._getSubmenuByElement($item);\n\n      this._clearTimeouts();\n\n      if (!submenu.isOverlayVisible()) {\n        eventsEngine.on($item, mouseMoveEventName, this._itemMouseMoveHandler.bind(this));\n        this._showSubmenuTimer = this._getDelay(\"hide\");\n      }\n    }\n  }\n\n  _hoverEndHandler(eventArg) {\n    var $item = this._getItemElementByEventArgs(eventArg);\n\n    var relatedTarget = $(eventArg.relatedTarget);\n\n    super._hoverEndHandler(eventArg);\n\n    this._clearTimeouts();\n\n    if (this._isItemDisabled($item)) {\n      return;\n    }\n\n    if (relatedTarget.hasClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)) {\n      return;\n    }\n\n    if (this.option(\"hideSubmenuOnMouseLeave\") && !relatedTarget.hasClass(DX_MENU_ITEMS_CONTAINER_CLASS)) {\n      this._hideSubmenuTimer = setTimeout(() => {\n        this._hideSubmenuAfterTimeout();\n      }, this._getDelay(\"hide\"));\n    }\n  }\n\n  _hideVisibleSubmenu() {\n    if (!this._visibleSubmenu) {\n      return false;\n    }\n\n    this._hideSubmenu(this._visibleSubmenu);\n\n    return true;\n  }\n\n  _showSubmenu($itemElement) {\n    var submenu = this._getSubmenuByElement($itemElement);\n\n    if (this._visibleSubmenu !== submenu) {\n      this._hideVisibleSubmenu();\n    }\n\n    if (submenu) {\n      this._clearTimeouts();\n\n      submenu.show();\n      this.option(\"focusedElement\", submenu.option(\"focusedElement\"));\n    }\n\n    this._visibleSubmenu = submenu;\n    this._hoveredRootItem = $itemElement;\n  }\n\n  _hideSubmenu(submenu) {\n    submenu && submenu.hide();\n\n    if (this._visibleSubmenu === submenu) {\n      this._visibleSubmenu = null;\n    }\n\n    this._hoveredRootItem = null;\n  }\n\n  _itemMouseMoveHandler(e) {\n    if (e.pointers && e.pointers.length) {\n      return;\n    }\n\n    var $item = $(e.currentTarget);\n\n    if (!isDefined(this._showSubmenuTimer)) {\n      return;\n    }\n\n    this._clearTimeouts();\n\n    this._showSubmenuTimer = setTimeout(() => {\n      var submenu = this._getSubmenuByElement($item);\n\n      if (submenu && !submenu.isOverlayVisible()) {\n        this._showSubmenu($item);\n      }\n    }, this._getDelay(\"show\"));\n  }\n\n  _clearTimeouts() {\n    clearTimeout(this._hideSubmenuTimer);\n    clearTimeout(this._showSubmenuTimer);\n  }\n\n  _getSubmenuByElement($itemElement, itemData) {\n    var submenu = this._getSubmenuByRootElement($itemElement);\n\n    if (submenu) {\n      return submenu;\n    } else {\n      itemData = itemData || this._getItemData($itemElement);\n\n      var node = this._dataAdapter.getNodeByItem(itemData);\n\n      return this._hasChildren(node) && this._renderSubmenuItems(node, $itemElement);\n    }\n  }\n\n  _updateSubmenuVisibilityOnClick(actionArgs) {\n    var args = actionArgs.args.length && actionArgs.args[0];\n\n    if (!args || this._disabledGetter(args.itemData)) {\n      return;\n    }\n\n    var $itemElement = $(args.itemElement);\n\n    var currentSubmenu = this._getSubmenuByElement($itemElement, args.itemData);\n\n    this._updateSelectedItemOnClick(actionArgs);\n\n    if (this._visibleSubmenu) {\n      if (this._visibleSubmenu === currentSubmenu) {\n        if (\"onClick\" === this.option(\"showFirstSubmenuMode\")) {\n          this._hideSubmenu(this._visibleSubmenu);\n        }\n\n        return;\n      } else {\n        this._hideSubmenu(this._visibleSubmenu);\n      }\n    }\n\n    if (!currentSubmenu) {\n      return;\n    }\n\n    if (!currentSubmenu.isOverlayVisible()) {\n      this._showSubmenu($itemElement);\n\n      return;\n    }\n  }\n\n  _optionChanged(args) {\n    if (ACTIONS.indexOf(args.name) >= 0) {\n      this._initActions();\n\n      return;\n    }\n\n    switch (args.name) {\n      case \"orientation\":\n      case \"submenuDirection\":\n        this._invalidate();\n\n        break;\n\n      case \"showFirstSubmenuMode\":\n      case \"hideSubmenuOnMouseLeave\":\n        break;\n\n      case \"showSubmenuMode\":\n        this._changeSubmenusOption(args.name, args.value);\n\n        break;\n\n      case \"adaptivityEnabled\":\n        args.value ? this._initAdaptivity() : this._removeAdaptivity();\n        break;\n\n      case \"width\":\n        if (this._isAdaptivityEnabled()) {\n          this._treeView.option(args.name, args.value);\n\n          this._overlay.option(args.name, args.value);\n        }\n\n        super._optionChanged(args);\n\n        this._dimensionChanged();\n\n        break;\n\n      case \"animation\":\n        if (this._isAdaptivityEnabled()) {\n          this._treeView.option(\"animationEnabled\", !!args.value);\n        }\n\n        super._optionChanged(args);\n\n        break;\n\n      default:\n        if (this._isAdaptivityEnabled() && (args.name === args.fullName || \"items\" === args.name)) {\n          this._treeView.option(args.fullName, args.value);\n        }\n\n        super._optionChanged(args);\n\n    }\n  }\n\n  _changeSubmenusOption(name, value) {\n    each(this._submenus, (index, submenu) => {\n      submenu.option(name, value);\n    });\n  }\n\n  selectItem(itemElement) {\n    this._hideSubmenu(this._visibleSubmenu);\n\n    super.selectItem(itemElement);\n  }\n\n  unselectItem(itemElement) {\n    this._hideSubmenu(this._visibleSubmenu);\n\n    super.selectItem(itemElement);\n  }\n\n}\n\nregisterComponent(\"dxMenu\", Menu);\nexport default Menu;","map":null,"metadata":{},"sourceType":"module"}