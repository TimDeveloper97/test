{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/text_box/texteditor_button_collection/index.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../../core/renderer\";\nimport CustomButton from \"./custom\";\nimport { extend } from \"../../../core/utils/extend\";\nimport errors from \"../../widget/ui.errors\";\nvar TEXTEDITOR_BUTTONS_CONTAINER_CLASS = \"dx-texteditor-buttons-container\";\n\nfunction checkButtonInfo(buttonInfo) {\n  (() => {\n    if (!buttonInfo || \"object\" !== typeof buttonInfo || Array.isArray(buttonInfo)) {\n      throw errors.Error(\"E1053\");\n    }\n  })();\n\n  (() => {\n    if (!(\"name\" in buttonInfo)) {\n      throw errors.Error(\"E1054\");\n    }\n  })();\n\n  (() => {\n    var {\n      name: name\n    } = buttonInfo;\n\n    if (\"string\" !== typeof name) {\n      throw errors.Error(\"E1055\");\n    }\n  })();\n\n  (() => {\n    var {\n      location: location\n    } = buttonInfo;\n\n    if (\"location\" in buttonInfo && \"after\" !== location && \"before\" !== location) {\n      buttonInfo.location = \"after\";\n    }\n  })();\n}\n\nfunction checkNamesUniqueness(existingNames, newName) {\n  if (-1 !== existingNames.indexOf(newName)) {\n    throw errors.Error(\"E1055\", newName);\n  }\n\n  existingNames.push(newName);\n}\n\nfunction isPredefinedButtonName(name, predefinedButtonsInfo) {\n  return !!predefinedButtonsInfo.find(info => info.name === name);\n}\n\nexport default class TextEditorButtonCollection {\n  constructor(editor, defaultButtonsInfo) {\n    this.buttons = [];\n    this.defaultButtonsInfo = defaultButtonsInfo;\n    this.editor = editor;\n  }\n\n  _compileButtonInfo(buttons) {\n    var names = [];\n    return buttons.map(button => {\n      var isStringButton = \"string\" === typeof button;\n\n      if (!isStringButton) {\n        checkButtonInfo(button);\n      }\n\n      var isDefaultButton = isStringButton || isPredefinedButtonName(button.name, this.defaultButtonsInfo);\n\n      if (isDefaultButton) {\n        var defaultButtonInfo = this.defaultButtonsInfo.find(_ref => {\n          var {\n            name: name\n          } = _ref;\n          return name === button || name === button.name;\n        });\n\n        if (!defaultButtonInfo) {\n          throw errors.Error(\"E1056\", this.editor.NAME, button);\n        }\n\n        checkNamesUniqueness(names, button);\n        return defaultButtonInfo;\n      } else {\n        var {\n          name: name\n        } = button;\n        checkNamesUniqueness(names, name);\n        return extend(button, {\n          Ctor: CustomButton\n        });\n      }\n    });\n  }\n\n  _createButton(buttonsInfo) {\n    var {\n      Ctor: Ctor,\n      options: options,\n      name: name\n    } = buttonsInfo;\n    var button = new Ctor(name, this.editor, options);\n    this.buttons.push(button);\n    return button;\n  }\n\n  _renderButtons(buttons, $container, targetLocation) {\n    var $buttonsContainer = null;\n    var buttonsInfo = buttons ? this._compileButtonInfo(buttons) : this.defaultButtonsInfo;\n    buttonsInfo.forEach(buttonsInfo => {\n      var {\n        location = \"after\"\n      } = buttonsInfo;\n\n      if (location === targetLocation) {\n        this._createButton(buttonsInfo).render((() => {\n          $buttonsContainer = $buttonsContainer || $(\"<div>\").addClass(TEXTEDITOR_BUTTONS_CONTAINER_CLASS);\n          \"before\" === targetLocation ? $container.prepend($buttonsContainer) : $container.append($buttonsContainer);\n          return $buttonsContainer;\n        })());\n      }\n    });\n    return $buttonsContainer;\n  }\n\n  clean() {\n    this.buttons.forEach(button => button.dispose());\n    this.buttons = [];\n  }\n\n  getButton(buttonName) {\n    var button = this.buttons.find(_ref2 => {\n      var {\n        name: name\n      } = _ref2;\n      return name === buttonName;\n    });\n    return button && button.instance;\n  }\n\n  renderAfterButtons(buttons, $container) {\n    return this._renderButtons(buttons, $container, \"after\");\n  }\n\n  renderBeforeButtons(buttons, $container) {\n    return this._renderButtons(buttons, $container, \"before\");\n  }\n\n  updateButtons(names) {\n    this.buttons.forEach(button => {\n      if (!names || -1 !== names.indexOf(button.name)) {\n        button.update();\n      }\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}