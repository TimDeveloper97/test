{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.work_space.grouped.strategy.horizontal.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport { FIRST_GROUP_CELL_CLASS, LAST_GROUP_CELL_CLASS } from \"../classes\";\n\nclass HorizontalGroupedStrategy {\n  constructor(workSpace) {\n    this._workSpace = workSpace;\n  }\n\n  prepareCellIndexes(cellCoordinates, groupIndex, inAllDay) {\n    var groupByDay = this._workSpace.isGroupedByDate();\n\n    if (!groupByDay) {\n      return {\n        rowIndex: cellCoordinates.rowIndex,\n        columnIndex: cellCoordinates.columnIndex + groupIndex * this._workSpace._getCellCount()\n      };\n    } else {\n      return {\n        rowIndex: cellCoordinates.rowIndex,\n        columnIndex: cellCoordinates.columnIndex * this._workSpace._getGroupCount() + groupIndex\n      };\n    }\n  }\n\n  getGroupIndex(rowIndex, columnIndex) {\n    var groupByDay = this._workSpace.isGroupedByDate();\n\n    var groupCount = this._workSpace._getGroupCount();\n\n    if (groupByDay) {\n      return columnIndex % groupCount;\n    } else {\n      return Math.floor(columnIndex / this._workSpace._getCellCount());\n    }\n  }\n\n  calculateHeaderCellRepeatCount() {\n    return this._workSpace._getGroupCount() || 1;\n  }\n\n  insertAllDayRowsIntoDateTable() {\n    return false;\n  }\n\n  getTotalCellCount(groupCount) {\n    groupCount = groupCount || 1;\n    return this._workSpace._getCellCount() * groupCount;\n  }\n\n  getTotalRowCount() {\n    return this._workSpace._getRowCount();\n  }\n\n  calculateTimeCellRepeatCount() {\n    return 1;\n  }\n\n  getWorkSpaceMinWidth() {\n    return getBoundingRect(this._workSpace.$element().get(0)).width - this._workSpace.getTimePanelWidth();\n  }\n\n  getAllDayOffset() {\n    return this._workSpace.getAllDayHeight();\n  }\n\n  getGroupCountClass(groups) {\n    return;\n  }\n\n  getLeftOffset() {\n    return this._workSpace.getTimePanelWidth();\n  }\n\n  _createGroupBoundOffset(startCell, endCell, cellWidth) {\n    var extraOffset = cellWidth / 2;\n    var startOffset = startCell ? startCell.offset().left - extraOffset : 0;\n    var endOffset = endCell ? endCell.offset().left + cellWidth + extraOffset : 0;\n    return {\n      left: startOffset,\n      right: endOffset,\n      top: 0,\n      bottom: 0\n    };\n  }\n\n  _getGroupedByDateBoundOffset($cells, cellWidth) {\n    var lastCellIndex = $cells.length - 1;\n    var startCell = $cells.eq(0);\n    var endCell = $cells.eq(lastCellIndex);\n    return this._createGroupBoundOffset(startCell, endCell, cellWidth);\n  }\n\n  getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap) {\n    if (this._workSpace.isGroupedByDate()) {\n      return this._getGroupedByDateBoundOffset($cells, cellWidth);\n    }\n\n    var startCell;\n    var endCell;\n\n    var cellIndex = this._workSpace.getCellIndexByCoordinates(coordinates);\n\n    var groupIndex = coordinates.groupIndex || Math.floor(cellIndex / cellCount);\n    var currentCellGroup = groupedDataMap.dateTableGroupedMap[groupIndex];\n\n    if (currentCellGroup) {\n      var groupRowLength = currentCellGroup[0].length;\n      var groupStartPosition = currentCellGroup[0][0].position;\n      var groupEndPosition = currentCellGroup[0][groupRowLength - 1].position;\n      startCell = $cells.eq(groupStartPosition.columnIndex);\n      endCell = $cells.eq(groupEndPosition.columnIndex);\n    }\n\n    return this._createGroupBoundOffset(startCell, endCell, cellWidth);\n  }\n\n  shiftIndicator($indicator, height, rtlOffset, groupIndex) {\n    var offset = this._getIndicatorOffset(groupIndex);\n\n    var horizontalOffset = rtlOffset ? rtlOffset - offset : offset;\n    $indicator.css(\"left\", horizontalOffset);\n    $indicator.css(\"top\", height);\n  }\n\n  _getIndicatorOffset(groupIndex) {\n    var groupByDay = this._workSpace.isGroupedByDate();\n\n    return groupByDay ? this._calculateGroupByDateOffset(groupIndex) : this._calculateOffset(groupIndex);\n  }\n\n  _calculateOffset(groupIndex) {\n    return this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex + this._workSpace.getIndicatorOffset(groupIndex) + groupIndex;\n  }\n\n  _calculateGroupByDateOffset(groupIndex) {\n    return this._workSpace.getIndicatorOffset(0) * this._workSpace._getGroupCount() + this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex;\n  }\n\n  getShaderOffset(i, width) {\n    var offset = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(i - 1) * i;\n    return this._workSpace.option(\"rtlEnabled\") ? getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).width - offset - this._workSpace.getTimePanelWidth() - width : offset;\n  }\n\n  getShaderTopOffset(i) {\n    return -this.getShaderMaxHeight() * (i > 0 ? 1 : 0);\n  }\n\n  getShaderHeight() {\n    var height = this._workSpace.getIndicationHeight();\n\n    return height;\n  }\n\n  getShaderMaxHeight() {\n    return getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).height;\n  }\n\n  getShaderWidth(i) {\n    return this._workSpace.getIndicationWidth(i);\n  }\n\n  getScrollableScrollTop(allDay) {\n    return !allDay ? this._workSpace.getScrollable().scrollTop() : 0;\n  }\n\n  addAdditionalGroupCellClasses(cellClass, index, i, j) {\n    var applyUnconditionally = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\n    cellClass = this._addLastGroupCellClass(cellClass, index, applyUnconditionally);\n    return this._addFirstGroupCellClass(cellClass, index, applyUnconditionally);\n  }\n\n  _addLastGroupCellClass(cellClass, index, applyUnconditionally) {\n    if (applyUnconditionally) {\n      return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS);\n    }\n\n    var groupByDate = this._workSpace.isGroupedByDate();\n\n    if (groupByDate) {\n      if (index % this._workSpace._getGroupCount() === 0) {\n        return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS);\n      }\n    } else if (index % this._workSpace._getCellCount() === 0) {\n      return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS);\n    }\n\n    return cellClass;\n  }\n\n  _addFirstGroupCellClass(cellClass, index, applyUnconditionally) {\n    if (applyUnconditionally) {\n      return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS);\n    }\n\n    var groupByDate = this._workSpace.isGroupedByDate();\n\n    if (groupByDate) {\n      if ((index - 1) % this._workSpace._getGroupCount() === 0) {\n        return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS);\n      }\n    } else if ((index - 1) % this._workSpace._getCellCount() === 0) {\n      return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS);\n    }\n\n    return cellClass;\n  }\n\n}\n\nexport default HorizontalGroupedStrategy;","map":null,"metadata":{},"sourceType":"module"}