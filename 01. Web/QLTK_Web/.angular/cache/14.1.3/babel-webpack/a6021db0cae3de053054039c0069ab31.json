{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/file_manager/ui.file_manager.items_list.thumbnails.list_box.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getOuterWidth, getOuterHeight, getInnerWidth, getInnerHeight } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport { extend } from \"../../core/utils/extend\";\nimport { isDefined } from \"../../core/utils/type\";\nimport { Deferred, when } from \"../../core/utils/deferred\";\nimport holdEvent from \"../../events/hold\";\nimport { addNamespace, isCommandKeyPressed } from \"../../events/utils/index\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { BindableTemplate } from \"../../core/templates/bindable_template\";\nimport ScrollView from \"../scroll_view\";\nimport CollectionWidget from \"../collection/ui.collection_widget.edit\";\nimport Selection from \"../selection/selection\";\nvar FILE_MANAGER_THUMBNAILS_VIEW_PORT_CLASS = \"dx-filemanager-thumbnails-view-port\";\nvar FILE_MANAGER_THUMBNAILS_ITEM_LIST_CONTAINER_CLASS = \"dx-filemanager-thumbnails-container\";\nvar FILE_MANAGER_THUMBNAILS_ITEM_CLASS = \"dx-filemanager-thumbnails-item\";\nvar FILE_MANAGER_THUMBNAILS_ITEM_NAME_CLASS = \"dx-filemanager-thumbnails-item-name\";\nvar FILE_MANAGER_THUMBNAILS_ITEM_SPACER_CLASS = \"dx-filemanager-thumbnails-item-spacer\";\nvar FILE_MANAGER_THUMBNAILS_ITEM_DATA_KEY = \"dxFileManagerItemData\";\nvar FILE_MANAGER_THUMBNAILS_LIST_BOX_NAMESPACE = \"dxFileManagerThumbnailsListBox\";\nvar FILE_MANAGER_THUMBNAILS_LIST_BOX_HOLD_EVENT_NAME = addNamespace(holdEvent.name, FILE_MANAGER_THUMBNAILS_LIST_BOX_NAMESPACE);\n\nclass FileManagerThumbnailListBox extends CollectionWidget {\n  _initMarkup() {\n    this._initActions();\n\n    this._lockFocusedItemProcessing = false;\n    this.$element().addClass(FILE_MANAGER_THUMBNAILS_VIEW_PORT_CLASS);\n\n    this._renderScrollView();\n\n    this._renderItemsContainer();\n\n    this._createScrollViewControl();\n\n    super._initMarkup();\n\n    this.onFocusedItemChanged = this._onFocusedItemChanged.bind(this);\n    this._layoutUtils = new ListBoxLayoutUtils(this._scrollView, this.$element(), this._$itemContainer, this.itemElements().first());\n\n    this._syncFocusedItemKey();\n  }\n\n  _initActions() {\n    this._actions = {\n      onItemEnterKeyPressed: this._createActionByOption(\"onItemEnterKeyPressed\"),\n      onFocusedItemChanged: this._createActionByOption(\"onFocusedItemChanged\")\n    };\n  }\n\n  _initTemplates() {\n    super._initTemplates();\n\n    this._itemThumbnailTemplate = this.option(\"itemThumbnailTemplate\");\n    this._getTooltipText = this.option(\"getTooltipText\");\n\n    this._templateManager.addDefaultTemplates({\n      item: new BindableTemplate(function ($container, data, itemModel) {\n        var $itemElement = this._getDefaultItemTemplate(itemModel, $container);\n\n        $container.append($itemElement);\n      }.bind(this), [\"fileItem\"], this.option(\"integrationOptions.watchMethod\"))\n    });\n  }\n\n  _createScrollViewControl() {\n    if (!this._scrollView) {\n      this._scrollView = this._createComponent(this._$scrollView, ScrollView, {\n        scrollByContent: true,\n        scrollByThumb: true,\n        useKeyboard: false,\n        showScrollbar: \"onHover\"\n      });\n    }\n  }\n\n  _renderScrollView() {\n    if (!this._$scrollView) {\n      this._$scrollView = $(\"<div>\").appendTo(this.$element());\n    }\n  }\n\n  _renderItemsContainer() {\n    if (!this._$itemContainer) {\n      this._$itemContainer = $(\"<div>\").addClass(FILE_MANAGER_THUMBNAILS_ITEM_LIST_CONTAINER_CLASS).appendTo(this._$scrollView);\n    }\n  }\n\n  _render() {\n    super._render();\n\n    this._detachEventHandlers();\n\n    this._attachEventHandlers();\n  }\n\n  _clean() {\n    this._detachEventHandlers();\n\n    super._clean();\n  }\n\n  _supportedKeys() {\n    return extend(super._supportedKeys(), {\n      upArrow(e) {\n        this._beforeKeyProcessing(e);\n\n        this._processArrowKeys(-1, false, e);\n      },\n\n      downArrow(e) {\n        this._beforeKeyProcessing(e);\n\n        this._processArrowKeys(1, false, e);\n      },\n\n      home(e) {\n        this._beforeKeyProcessing(e);\n\n        this._processHomeEndKeys(0, true, e);\n      },\n\n      end(e) {\n        this._beforeKeyProcessing(e);\n\n        this._processHomeEndKeys(this._getItemsLength() - 1, true, e);\n      },\n\n      pageUp(e) {\n        this._beforeKeyProcessing(e);\n\n        this._processPageChange(true, e);\n      },\n\n      pageDown(e) {\n        this._beforeKeyProcessing(e);\n\n        this._processPageChange(false, e);\n      },\n\n      enter(e) {\n        this._beforeKeyProcessing(e);\n\n        this._actions.onItemEnterKeyPressed(this._getFocusedItem());\n      },\n\n      A(e) {\n        this._beforeKeyProcessing(e);\n\n        if (isCommandKeyPressed(e)) {\n          this.selectAll();\n        }\n      }\n\n    });\n  }\n\n  _beforeKeyProcessing(e) {\n    e.preventDefault();\n\n    this._layoutUtils.reset();\n  }\n\n  _processArrowKeys(offset, horizontal, eventArgs) {\n    var item = this._getFocusedItem();\n\n    if (item) {\n      if (!horizontal) {\n        var layout = this._layoutUtils.getLayoutModel();\n\n        if (!layout) {\n          return;\n        }\n\n        offset *= layout.itemPerRowCount;\n      }\n\n      var newItemIndex = this._getIndexByItem(item) + offset;\n\n      this._focusItemByIndex(newItemIndex, true, eventArgs);\n    }\n  }\n\n  _processHomeEndKeys(index, scrollToItem, eventArgs) {\n    this._focusItemByIndex(index, scrollToItem, eventArgs);\n  }\n\n  _processPageChange(pageUp, eventArgs) {\n    var item = this._getFocusedItem();\n\n    if (!item) {\n      return;\n    }\n\n    var layout = this._layoutUtils.getLayoutModel();\n\n    if (!layout) {\n      return;\n    }\n\n    var itemLayout = this._layoutUtils.createItemLayoutModel(this._getIndexByItem(item));\n\n    var rowOffset = pageUp ? layout.rowPerPageRate : -layout.rowPerPageRate;\n    var newRowRate = itemLayout.itemRowIndex - rowOffset;\n    var roundFunc = pageUp ? Math.ceil : Math.floor;\n    var newRowIndex = roundFunc(newRowRate);\n    var newItemIndex = newRowIndex * layout.itemPerRowCount + itemLayout.itemColumnIndex;\n\n    if (newItemIndex < 0) {\n      newItemIndex = 0;\n    } else if (newItemIndex >= this._getItemsLength()) {\n      newItemIndex = this._getItemsLength() - 1;\n    }\n\n    this._focusItemByIndex(newItemIndex, true, eventArgs);\n  }\n\n  _processLongTap(e) {\n    var $targetItem = this._closestItemElement($(e.target));\n\n    var itemIndex = this._getIndexByItemElement($targetItem);\n\n    this._selection.changeItemSelection(itemIndex, {\n      control: true\n    });\n  }\n\n  _attachEventHandlers() {\n    if (\"multiple\" === this.option(\"selectionMode\")) {\n      eventsEngine.on(this._itemContainer(), FILE_MANAGER_THUMBNAILS_LIST_BOX_HOLD_EVENT_NAME, \".\".concat(this._itemContentClass()), e => {\n        this._processLongTap(e);\n\n        e.stopPropagation();\n      });\n    }\n\n    eventsEngine.on(this._itemContainer(), \"mousedown selectstart\", e => {\n      if (e.shiftKey) {\n        e.preventDefault();\n      }\n    });\n  }\n\n  _detachEventHandlers() {\n    eventsEngine.off(this._itemContainer(), FILE_MANAGER_THUMBNAILS_LIST_BOX_HOLD_EVENT_NAME);\n    eventsEngine.off(this._itemContainer(), \"mousedown selectstart\");\n  }\n\n  _itemContainer() {\n    return this._$itemContainer;\n  }\n\n  _itemClass() {\n    return FILE_MANAGER_THUMBNAILS_ITEM_CLASS;\n  }\n\n  _itemDataKey() {\n    return FILE_MANAGER_THUMBNAILS_ITEM_DATA_KEY;\n  }\n\n  _getDefaultItemTemplate(fileItemInfo, $itemElement) {\n    $itemElement.attr(\"title\", this._getTooltipText(fileItemInfo));\n\n    var $itemThumbnail = this._itemThumbnailTemplate(fileItemInfo);\n\n    var $itemSpacer = $(\"<div>\").addClass(FILE_MANAGER_THUMBNAILS_ITEM_SPACER_CLASS);\n    var $itemName = $(\"<div>\").addClass(FILE_MANAGER_THUMBNAILS_ITEM_NAME_CLASS).text(fileItemInfo.fileItem.name);\n    $itemElement.append($itemThumbnail, $itemSpacer, $itemName);\n  }\n\n  _itemSelectHandler(e) {\n    var options = {};\n\n    if (\"multiple\" === this.option(\"selectionMode\")) {\n      if (!this._isPreserveSelectionMode) {\n        this._isPreserveSelectionMode = isCommandKeyPressed(e) || e.shiftKey;\n      }\n\n      options = {\n        control: this._isPreserveSelectionMode,\n        shift: e.shiftKey\n      };\n    }\n\n    var index = this._getIndexByItemElement(e.currentTarget);\n\n    this._selection.changeItemSelection(index, options);\n  }\n\n  _initSelectionModule() {\n    super._initSelectionModule();\n\n    var options = extend(this._selection.options, {\n      selectedKeys: this.option(\"selectedItemKeys\"),\n      onSelectionChanged: args => {\n        this.option(\"selectedItems\", this._getItemsByKeys(args.selectedItemKeys, args.selectedItems));\n\n        this._updateSelectedItems(args);\n      }\n    });\n    this._selection = new Selection(options);\n  }\n\n  _updateSelectedItems(args) {\n    var addedItemKeys = args.addedItemKeys;\n    var removedItemKeys = args.removedItemKeys;\n\n    if (this._rendered && (addedItemKeys.length || removedItemKeys.length)) {\n      var selectionChangePromise = this._selectionChangePromise;\n\n      if (!this._rendering) {\n        var addedSelection = [];\n        var normalizedIndex;\n        var removedSelection = [];\n\n        this._editStrategy.beginCache();\n\n        for (var i = 0; i < removedItemKeys.length; i++) {\n          normalizedIndex = this._getIndexByKey(removedItemKeys[i]);\n          removedSelection.push(normalizedIndex);\n\n          this._removeSelection(normalizedIndex);\n        }\n\n        for (var _i = 0; _i < addedItemKeys.length; _i++) {\n          normalizedIndex = this._getIndexByKey(addedItemKeys[_i]);\n          addedSelection.push(normalizedIndex);\n\n          this._addSelection(normalizedIndex);\n        }\n\n        this._editStrategy.endCache();\n\n        this._updateSelection(addedSelection, removedSelection);\n      }\n\n      when(selectionChangePromise).done(() => this._fireSelectionChangeEvent(args));\n    }\n  }\n\n  _fireSelectionChangeEvent(args) {\n    this._createActionByOption(\"onSelectionChanged\", {\n      excludeValidators: [\"disabled\", \"readOnly\"]\n    })(args);\n  }\n\n  _updateSelection(addedSelection, removedSelection) {\n    var selectedItemsCount = this.getSelectedItems().length;\n\n    if (0 === selectedItemsCount) {\n      this._isPreserveSelectionMode = false;\n    }\n  }\n\n  _normalizeSelectedItems() {\n    var newKeys = this._getKeysByItems(this.option(\"selectedItems\"));\n\n    var oldKeys = this._selection.getSelectedItemKeys();\n\n    if (!this._compareKeys(oldKeys, newKeys)) {\n      this._selection.setSelection(newKeys);\n    }\n\n    return new Deferred().resolve().promise();\n  }\n\n  _focusOutHandler() {}\n\n  _getItems() {\n    return this.option(\"items\") || [];\n  }\n\n  _getItemsLength() {\n    return this._getItems().length;\n  }\n\n  _getIndexByItemElement(itemElement) {\n    return this._editStrategy.getNormalizedIndex(itemElement);\n  }\n\n  _getItemByIndex(index) {\n    return this._getItems()[index];\n  }\n\n  _getFocusedItem() {\n    return this.getItemByItemElement(this.option(\"focusedElement\"));\n  }\n\n  _focusItem(item, scrollToItem) {\n    this.option(\"focusedElement\", this.getItemElementByItem(item));\n\n    if (scrollToItem) {\n      this._layoutUtils.scrollToItem(this._getIndexByItem(item));\n    }\n  }\n\n  _focusItemByIndex(index, scrollToItem, eventArgs) {\n    if (index >= 0 && index < this._getItemsLength()) {\n      var item = this._getItemByIndex(index);\n\n      this._focusItem(item, scrollToItem, eventArgs);\n    }\n  }\n\n  _syncFocusedItemKey() {\n    if (!this._syncFocusedItemKeyDeferred) {\n      this._syncFocusedItemKeyDeferred = new Deferred();\n    }\n\n    var deferred = this._syncFocusedItemKeyDeferred;\n\n    if (this._dataSource && this._dataSource.isLoading()) {\n      return deferred.promise();\n    }\n\n    var focusedItemKey = this.option(\"focusedItemKey\");\n\n    if (isDefined(focusedItemKey)) {\n      var items = this.option(\"items\");\n      var focusedItem = items.find(item => this.keyOf(item) === focusedItemKey);\n\n      if (focusedItem) {\n        this._focusItem(focusedItem, true);\n\n        deferred.resolve();\n      } else {\n        this.option(\"focusedItemKey\", void 0);\n        deferred.reject();\n      }\n    } else {\n      deferred.resolve();\n    }\n\n    this._syncFocusedItemKeyDeferred = null;\n    return deferred.promise();\n  }\n\n  _onFocusedItemChanged() {\n    var focusedItem = this._getFocusedItem();\n\n    var newFocusedItemKey = this.keyOf(focusedItem);\n    var oldFocusedItemKey = this.option(\"focusedItemKey\");\n\n    if (newFocusedItemKey !== oldFocusedItemKey) {\n      this._lockFocusedItemProcessing = true;\n      this.option(\"focusedItemKey\", newFocusedItemKey);\n      this._lockFocusedItemProcessing = false;\n\n      this._raiseFocusedItemChanged(focusedItem);\n    }\n  }\n\n  _raiseFocusedItemChanged(focusedItem) {\n    var args = {\n      item: focusedItem,\n      itemElement: this.option(\"focusedElement\")\n    };\n\n    this._actions.onFocusedItemChanged(args);\n  }\n\n  _changeItemSelection(item, select) {\n    if (this.isItemSelected(item) === select) {\n      return;\n    }\n\n    var itemElement = this.getItemElementByItem(item);\n\n    var index = this._getIndexByItemElement(itemElement);\n\n    this._selection.changeItemSelection(index, {\n      control: this._isPreserveSelectionMode\n    });\n  }\n\n  _chooseSelectOption() {\n    return \"selectedItemKeys\";\n  }\n\n  getSelectedItems() {\n    return this._selection.getSelectedItems();\n  }\n\n  getItemElementByItem(item) {\n    return this._editStrategy.getItemElement(item);\n  }\n\n  getItemByItemElement(itemElement) {\n    return this._getItemByIndex(this._getIndexByItemElement(itemElement));\n  }\n\n  selectAll() {\n    if (\"multiple\" !== this.option(\"selectionMode\")) {\n      return;\n    }\n\n    this._selection.selectAll();\n\n    this._isPreserveSelectionMode = true;\n  }\n\n  selectItem(item) {\n    this._changeItemSelection(item, true);\n  }\n\n  deselectItem(item) {\n    this._changeItemSelection(item, false);\n  }\n\n  clearSelection() {\n    this._selection.deselectAll();\n  }\n\n  _optionChanged(args) {\n    switch (args.name) {\n      case \"items\":\n        if (this._layoutUtils) {\n          this._layoutUtils.updateItems(this.itemElements().first());\n        }\n\n        super._optionChanged(args);\n\n        break;\n\n      case \"focusedItemKey\":\n        if (this._lockFocusedItemProcessing) {\n          break;\n        }\n\n        if (isDefined(args.value)) {\n          this._syncFocusedItemKey().done(() => {\n            var focusedItem = this._getFocusedItem();\n\n            this._raiseFocusedItemChanged(focusedItem);\n          });\n        } else {\n          this.option(\"focusedElement\", null);\n\n          this._raiseFocusedItemChanged(null);\n        }\n\n        break;\n\n      case \"onItemEnterKeyPressed\":\n      case \"onFocusedItemChanged\":\n        this._actions[args.name] = this._createActionByOption(args.name);\n        break;\n\n      default:\n        super._optionChanged(args);\n\n    }\n  }\n\n}\n\nclass ListBoxLayoutUtils {\n  constructor(scrollView, $viewPort, $itemContainer, $item) {\n    this._layoutModel = null;\n    this._scrollView = scrollView;\n    this._$viewPort = $viewPort;\n    this._$itemContainer = $itemContainer;\n    this._$item = $item;\n  }\n\n  updateItems($item) {\n    this._$item = $item;\n  }\n\n  reset() {\n    this._layoutModel = null;\n  }\n\n  getLayoutModel() {\n    if (!this._layoutModel) {\n      this._layoutModel = this._createLayoutModel();\n    }\n\n    return this._layoutModel;\n  }\n\n  _createLayoutModel() {\n    if (!this._$item) {\n      return null;\n    }\n\n    var itemWidth = getOuterWidth(this._$item, true);\n\n    if (0 === itemWidth) {\n      return null;\n    }\n\n    var itemHeight = getOuterHeight(this._$item, true);\n    var viewPortWidth = getInnerWidth(this._$itemContainer);\n    var viewPortHeight = getInnerHeight(this._$viewPort);\n\n    var viewPortScrollTop = this._scrollView.scrollTop();\n\n    var viewPortScrollBottom = viewPortScrollTop + viewPortHeight;\n    var itemPerRowCount = Math.floor(viewPortWidth / itemWidth);\n    var rowPerPageRate = viewPortHeight / itemHeight;\n    return {\n      itemWidth: itemWidth,\n      itemHeight: itemHeight,\n      viewPortWidth: viewPortWidth,\n      viewPortHeight: viewPortHeight,\n      viewPortScrollTop: viewPortScrollTop,\n      viewPortScrollBottom: viewPortScrollBottom,\n      itemPerRowCount: itemPerRowCount,\n      rowPerPageRate: rowPerPageRate\n    };\n  }\n\n  createItemLayoutModel(index) {\n    var layout = this.getLayoutModel();\n\n    if (!layout) {\n      return null;\n    }\n\n    var itemRowIndex = Math.floor(index / layout.itemPerRowCount);\n    var itemColumnIndex = index % layout.itemPerRowCount;\n    var itemTop = itemRowIndex * layout.itemHeight;\n    var itemBottom = itemTop + layout.itemHeight;\n    return {\n      itemRowIndex: itemRowIndex,\n      itemColumnIndex: itemColumnIndex,\n      itemTop: itemTop,\n      itemBottom: itemBottom\n    };\n  }\n\n  scrollToItem(index) {\n    var layout = this.getLayoutModel();\n\n    if (!layout) {\n      return;\n    }\n\n    var itemRowIndex = Math.floor(index / layout.itemPerRowCount);\n    var itemTop = itemRowIndex * layout.itemHeight;\n    var itemBottom = itemTop + layout.itemHeight;\n    var newScrollTop = layout.viewPortScrollTop;\n\n    if (itemTop < layout.viewPortScrollTop) {\n      newScrollTop = itemTop;\n    } else if (itemBottom > layout.viewPortScrollBottom) {\n      newScrollTop = itemBottom - layout.viewPortHeight;\n    }\n\n    this._scrollView.scrollTo(newScrollTop);\n  }\n\n}\n\nexport default FileManagerThumbnailListBox;","map":null,"metadata":{},"sourceType":"module"}