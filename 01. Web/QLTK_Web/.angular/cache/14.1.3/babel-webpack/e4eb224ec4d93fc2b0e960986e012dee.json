{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/slider/ui.slider.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getWidth, setWidth } from \"../../core/utils/size\";\nimport registerComponent from \"../../core/component_registrator\";\nimport devices from \"../../core/devices\";\nimport $ from \"../../core/renderer\";\nimport { applyServerDecimalSeparator } from \"../../core/utils/common\";\nimport { Deferred } from \"../../core/utils/deferred\";\nimport { extend } from \"../../core/utils/extend\";\nimport { name as clickName } from \"../../events/click\";\nimport { lock } from \"../../events/core/emitter.feedback\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport Swipeable from \"../../events/gesture/swipeable\";\nimport pointerEvents from \"../../events/pointer\";\nimport { addNamespace, isMouseEvent, isTouchEvent, eventData } from \"../../events/utils/index\";\nimport numberLocalization from \"../../localization/number\";\nimport { isMaterial, current as currentTheme } from \"../themes\";\nimport TrackBar from \"../track_bar\";\nimport { render } from \"../widget/utils.ink_ripple\";\nimport SliderHandle from \"./ui.slider_handle\";\nimport { roundFloatPart, getExponentLength, getRemainderByDivision } from \"../../core/utils/math\";\nvar SLIDER_CLASS = \"dx-slider\";\nvar SLIDER_WRAPPER_CLASS = \"dx-slider-wrapper\";\nvar SLIDER_HANDLE_SELECTOR = \".dx-slider-handle\";\nvar SLIDER_BAR_CLASS = \"dx-slider-bar\";\nvar SLIDER_RANGE_CLASS = \"dx-slider-range\";\nvar SLIDER_RANGE_VISIBLE_CLASS = \"dx-slider-range-visible\";\nvar SLIDER_LABEL_CLASS = \"dx-slider-label\";\nvar SLIDER_LABEL_POSITION_CLASS_PREFIX = \"dx-slider-label-position-\";\nvar SLIDER_TOOLTIP_POSITION_CLASS_PREFIX = \"dx-slider-tooltip-position-\";\nvar INVALID_MESSAGE_VISIBLE_CLASS = \"dx-invalid-message-visible\";\nvar SLIDER_VALIDATION_NAMESPACE = \"Validation\";\nvar Slider = TrackBar.inherit({\n  _activeStateUnit: SLIDER_HANDLE_SELECTOR,\n  _supportedKeys: function () {\n    var isRTL = this.option(\"rtlEnabled\");\n\n    var roundedValue = (offset, isLeftDirection) => {\n      offset = this._valueStep(offset);\n      var step = this.option(\"step\");\n      var value = this.option(\"value\");\n      var currentPosition = value - this.option(\"min\");\n      var remainder = getRemainderByDivision(currentPosition, step, this._getValueExponentLength());\n      var result = isLeftDirection ? value - offset + (remainder ? step - remainder : 0) : value + offset - remainder;\n      var min = this.option(\"min\");\n      var max = this.option(\"max\");\n\n      if (result < min) {\n        result = min;\n      } else if (result > max) {\n        result = max;\n      }\n\n      return this._roundToExponentLength(result);\n    };\n\n    var moveHandleRight = offset => {\n      this.option(\"value\", roundedValue(offset, isRTL));\n    };\n\n    var moveHandleLeft = offset => {\n      this.option(\"value\", roundedValue(offset, !isRTL));\n    };\n\n    return extend(this.callBase(), {\n      leftArrow: function (e) {\n        this._processKeyboardEvent(e);\n\n        moveHandleLeft(this.option(\"step\"));\n      },\n      rightArrow: function (e) {\n        this._processKeyboardEvent(e);\n\n        moveHandleRight(this.option(\"step\"));\n      },\n      pageUp: function (e) {\n        this._processKeyboardEvent(e);\n\n        moveHandleRight(this.option(\"step\") * this.option(\"keyStep\"));\n      },\n      pageDown: function (e) {\n        this._processKeyboardEvent(e);\n\n        moveHandleLeft(this.option(\"step\") * this.option(\"keyStep\"));\n      },\n      home: function (e) {\n        this._processKeyboardEvent(e);\n\n        var min = this.option(\"min\");\n        this.option(\"value\", min);\n      },\n      end: function (e) {\n        this._processKeyboardEvent(e);\n\n        var max = this.option(\"max\");\n        this.option(\"value\", max);\n      }\n    });\n  },\n  _processKeyboardEvent: function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n\n    this._saveValueChangeEvent(e);\n  },\n  _getDefaultOptions: function () {\n    return extend(this.callBase(), {\n      value: 50,\n      hoverStateEnabled: true,\n      activeStateEnabled: true,\n      step: 1,\n      showRange: true,\n      tooltip: {\n        enabled: false,\n        format: function (value) {\n          return value;\n        },\n        position: \"top\",\n        showMode: \"onHover\"\n      },\n      label: {\n        visible: false,\n        position: \"bottom\",\n        format: function (value) {\n          return value;\n        }\n      },\n      keyStep: 1,\n      useInkRipple: false,\n      validationMessageOffset: isMaterial() ? {\n        h: 18,\n        v: 0\n      } : {\n        h: 7,\n        v: 4\n      },\n      focusStateEnabled: true\n    });\n  },\n  _toggleValidationMessage: function (visible) {\n    if (!this.option(\"isValid\")) {\n      this.$element().toggleClass(INVALID_MESSAGE_VISIBLE_CLASS, visible);\n    }\n  },\n  _defaultOptionsRules: function () {\n    return this.callBase().concat([{\n      device: function () {\n        return \"desktop\" === devices.real().deviceType && !devices.isSimulator();\n      },\n      options: {\n        focusStateEnabled: true\n      }\n    }, {\n      device: function () {\n        var themeName = currentTheme();\n        return isMaterial(themeName);\n      },\n      options: {\n        useInkRipple: true\n      }\n    }]);\n  },\n  _initMarkup: function () {\n    this.$element().addClass(SLIDER_CLASS);\n\n    this._renderSubmitElement();\n\n    this.option(\"useInkRipple\") && this._renderInkRipple();\n    this.callBase();\n\n    this._renderLabels();\n\n    this._renderStartHandler();\n\n    this._renderAriaMinAndMax();\n  },\n  _attachFocusEvents: function () {\n    this.callBase();\n    var namespace = this.NAME + SLIDER_VALIDATION_NAMESPACE;\n    var focusInEvent = addNamespace(\"focusin\", namespace);\n    var focusOutEvent = addNamespace(\"focusout\", namespace);\n\n    var $focusTarget = this._focusTarget();\n\n    eventsEngine.on($focusTarget, focusInEvent, this._toggleValidationMessage.bind(this, true));\n    eventsEngine.on($focusTarget, focusOutEvent, this._toggleValidationMessage.bind(this, false));\n  },\n  _detachFocusEvents: function () {\n    this.callBase();\n\n    var $focusTarget = this._focusTarget();\n\n    this._toggleValidationMessage(false);\n\n    eventsEngine.off($focusTarget, this.NAME + SLIDER_VALIDATION_NAMESPACE);\n  },\n  _render: function () {\n    this.callBase();\n\n    this._repaintHandle();\n  },\n  _renderSubmitElement: function () {\n    this._$submitElement = $(\"<input>\").attr(\"type\", \"hidden\").appendTo(this.$element());\n  },\n  _getSubmitElement: function () {\n    return this._$submitElement;\n  },\n  _renderInkRipple: function () {\n    this._inkRipple = render({\n      waveSizeCoefficient: .7,\n      isCentered: true,\n      wavesNumber: 2,\n      useHoldAnimation: false\n    });\n  },\n  _renderInkWave: function (element, dxEvent, doRender, waveIndex) {\n    if (!this._inkRipple) {\n      return;\n    }\n\n    var config = {\n      element: element,\n      event: dxEvent,\n      wave: waveIndex\n    };\n\n    if (doRender) {\n      this._inkRipple.showWave(config);\n    } else {\n      this._inkRipple.hideWave(config);\n    }\n  },\n  _visibilityChanged: function () {\n    this.repaint();\n  },\n  _renderWrapper: function () {\n    this.callBase();\n\n    this._$wrapper.addClass(SLIDER_WRAPPER_CLASS);\n\n    this._createComponent(this._$wrapper, Swipeable, {\n      elastic: false,\n      immediate: true,\n      onStart: this._swipeStartHandler.bind(this),\n      onUpdated: this._swipeUpdateHandler.bind(this),\n      onEnd: this._swipeEndHandler.bind(this),\n      itemSizeFunc: this._itemWidthFunc.bind(this)\n    });\n  },\n  _renderContainer: function () {\n    this.callBase();\n\n    this._$bar.addClass(SLIDER_BAR_CLASS);\n  },\n  _renderRange: function () {\n    this.callBase();\n\n    this._$range.addClass(SLIDER_RANGE_CLASS);\n\n    this._renderHandle();\n\n    this._renderRangeVisibility();\n  },\n  _renderRangeVisibility: function () {\n    this._$range.toggleClass(SLIDER_RANGE_VISIBLE_CLASS, Boolean(this.option(\"showRange\")));\n  },\n  _renderHandle: function () {\n    this._$handle = this._renderHandleImpl(this.option(\"value\"), this._$handle);\n  },\n  _renderHandleImpl: function (value, $element) {\n    var $handle = $element || $(\"<div>\").appendTo(this._$range);\n    var tooltip = this.option(\"tooltip\");\n    this.$element().toggleClass(SLIDER_TOOLTIP_POSITION_CLASS_PREFIX + \"bottom\", tooltip.enabled && \"bottom\" === tooltip.position).toggleClass(SLIDER_TOOLTIP_POSITION_CLASS_PREFIX + \"top\", tooltip.enabled && \"top\" === tooltip.position);\n\n    this._createComponent($handle, SliderHandle, {\n      value: value,\n      tooltip: tooltip\n    });\n\n    return $handle;\n  },\n  _renderAriaMinAndMax: function () {\n    this.setAria({\n      valuemin: this.option(\"min\"),\n      valuemax: this.option(\"max\")\n    }, this._$handle);\n  },\n  _toggleActiveState: function ($element, value) {\n    this.callBase($element, value);\n\n    this._renderInkWave($element, null, !!value, 1);\n  },\n  _toggleFocusClass: function (isFocused, $element) {\n    this.callBase(isFocused, $element);\n\n    if (this._disposed) {\n      return;\n    }\n\n    var $focusTarget = $($element || this._focusTarget());\n\n    this._renderInkWave($focusTarget, null, isFocused, 0);\n  },\n  _renderLabels: function () {\n    this.$element().removeClass(SLIDER_LABEL_POSITION_CLASS_PREFIX + \"bottom\").removeClass(SLIDER_LABEL_POSITION_CLASS_PREFIX + \"top\");\n\n    if (this.option(\"label.visible\")) {\n      var min = this.option(\"min\");\n      var max = this.option(\"max\");\n      var position = this.option(\"label.position\");\n      var labelFormat = this.option(\"label.format\");\n\n      if (!this._$minLabel) {\n        this._$minLabel = $(\"<div>\").addClass(SLIDER_LABEL_CLASS).appendTo(this._$wrapper);\n      }\n\n      this._$minLabel.text(numberLocalization.format(min, labelFormat));\n\n      if (!this._$maxLabel) {\n        this._$maxLabel = $(\"<div>\").addClass(SLIDER_LABEL_CLASS).appendTo(this._$wrapper);\n      }\n\n      this._$maxLabel.text(numberLocalization.format(max, labelFormat));\n\n      this.$element().addClass(SLIDER_LABEL_POSITION_CLASS_PREFIX + position);\n    } else {\n      if (this._$minLabel) {\n        this._$minLabel.remove();\n\n        delete this._$minLabel;\n      }\n\n      if (this._$maxLabel) {\n        this._$maxLabel.remove();\n\n        delete this._$maxLabel;\n      }\n    }\n  },\n  _renderStartHandler: function () {\n    var pointerDownEventName = addNamespace(pointerEvents.down, this.NAME);\n    var clickEventName = addNamespace(clickName, this.NAME);\n\n    var startAction = this._createAction(this._startHandler.bind(this));\n\n    var $element = this.$element();\n    eventsEngine.off($element, pointerDownEventName);\n    eventsEngine.on($element, pointerDownEventName, e => {\n      if (isMouseEvent(e)) {\n        startAction({\n          event: e\n        });\n      }\n    });\n    eventsEngine.off($element, clickEventName);\n    eventsEngine.on($element, clickEventName, e => {\n      var $handle = this._activeHandle();\n\n      if ($handle) {\n        eventsEngine.trigger($handle, \"focusin\");\n        eventsEngine.trigger($handle, \"focus\");\n      }\n\n      startAction({\n        event: e\n      });\n    });\n  },\n  _itemWidthFunc: function () {\n    return this._itemWidthRatio;\n  },\n  _swipeStartHandler: function (e) {\n    var rtlEnabled = this.option(\"rtlEnabled\");\n\n    if (isTouchEvent(e.event)) {\n      this._createAction(this._startHandler.bind(this))({\n        event: e.event\n      });\n    }\n\n    this._feedbackDeferred = new Deferred();\n    lock(this._feedbackDeferred);\n\n    this._toggleActiveState(this._activeHandle(), this.option(\"activeStateEnabled\"));\n\n    this._startOffset = this._currentRatio;\n\n    var startOffset = this._startOffset * this._swipePixelRatio();\n\n    var endOffset = (1 - this._startOffset) * this._swipePixelRatio();\n\n    e.event.maxLeftOffset = rtlEnabled ? endOffset : startOffset;\n    e.event.maxRightOffset = rtlEnabled ? startOffset : endOffset;\n    this._itemWidthRatio = getWidth(this.$element()) / this._swipePixelRatio();\n    this._needPreventAnimation = true;\n  },\n  _swipeEndHandler: function (e) {\n    if (this._isSingleValuePossible()) {\n      return;\n    }\n\n    this._feedbackDeferred.resolve();\n\n    this._toggleActiveState(this._activeHandle(), false);\n\n    var offsetDirection = this.option(\"rtlEnabled\") ? -1 : 1;\n    delete this._needPreventAnimation;\n\n    this._saveValueChangeEvent(e.event);\n\n    this._changeValueOnSwipe(this._startOffset + offsetDirection * e.event.targetOffset / this._swipePixelRatio());\n\n    delete this._startOffset;\n\n    this._renderValue();\n  },\n  _activeHandle: function () {\n    return this._$handle;\n  },\n  _swipeUpdateHandler: function (e) {\n    if (this._isSingleValuePossible()) {\n      return;\n    }\n\n    this._saveValueChangeEvent(e.event);\n\n    this._updateHandlePosition(e);\n  },\n  _updateHandlePosition: function (e) {\n    var offsetDirection = this.option(\"rtlEnabled\") ? -1 : 1;\n    var newRatio = Math.min(this._startOffset + offsetDirection * e.event.offset / this._swipePixelRatio(), 1);\n    setWidth(this._$range, 100 * newRatio + \"%\");\n    SliderHandle.getInstance(this._activeHandle()).fitTooltipPosition;\n\n    this._changeValueOnSwipe(newRatio);\n  },\n  _swipePixelRatio: function () {\n    var min = this.option(\"min\");\n    var max = this.option(\"max\");\n\n    var step = this._valueStep(this.option(\"step\"));\n\n    return (max - min) / step;\n  },\n  _valueStep: function (step) {\n    if (!step || isNaN(step)) {\n      step = 1;\n    }\n\n    return step;\n  },\n  _getValueExponentLength: function () {\n    var {\n      step: step,\n      min: min\n    } = this.option();\n    return Math.max(getExponentLength(step), getExponentLength(min));\n  },\n  _roundToExponentLength: function (value) {\n    var valueExponentLength = this._getValueExponentLength();\n\n    return roundFloatPart(value, valueExponentLength);\n  },\n  _changeValueOnSwipe: function (ratio) {\n    var min = this.option(\"min\");\n    var max = this.option(\"max\");\n\n    var step = this._valueStep(this.option(\"step\"));\n\n    var newChange = ratio * (max - min);\n    var newValue = min + newChange;\n\n    if (step < 0) {\n      return;\n    }\n\n    if (newValue === max || newValue === min) {\n      this._setValueOnSwipe(newValue);\n    } else {\n      var stepCount = Math.round((newValue - min) / step);\n      newValue = this._roundToExponentLength(stepCount * step + min);\n\n      this._setValueOnSwipe(Math.max(Math.min(newValue, max), min));\n    }\n  },\n  _setValueOnSwipe: function (value) {\n    this.option(\"value\", value);\n\n    this._saveValueChangeEvent(void 0);\n  },\n  _isSingleValuePossible: function () {\n    var {\n      min: min,\n      max: max\n    } = this.option();\n    return min === max;\n  },\n  _startHandler: function (args) {\n    if (this._isSingleValuePossible()) {\n      return;\n    }\n\n    var e = args.event;\n    this._currentRatio = (eventData(e).x - this._$bar.offset().left) / getWidth(this._$bar);\n\n    if (this.option(\"rtlEnabled\")) {\n      this._currentRatio = 1 - this._currentRatio;\n    }\n\n    this._saveValueChangeEvent(e);\n\n    this._changeValueOnSwipe(this._currentRatio);\n  },\n  _renderValue: function () {\n    this.callBase();\n    var value = this.option(\"value\");\n\n    this._getSubmitElement().val(applyServerDecimalSeparator(value));\n\n    SliderHandle.getInstance(this._activeHandle()).option(\"value\", value);\n  },\n  _setRangeStyles: function (options) {\n    options && this._$range.css(options);\n  },\n  _callHandlerMethod: function (name, args) {\n    SliderHandle.getInstance(this._$handle)[name](args);\n  },\n  _repaintHandle: function () {\n    this._callHandlerMethod(\"repaint\");\n  },\n  _fitTooltip: function () {\n    this._callHandlerMethod(\"updateTooltipPosition\");\n  },\n  _optionChanged: function (args) {\n    switch (args.name) {\n      case \"visible\":\n        this.callBase(args);\n\n        this._renderHandle();\n\n        this._repaintHandle();\n\n        break;\n\n      case \"min\":\n      case \"max\":\n        this._renderValue();\n\n        this.callBase(args);\n\n        this._renderLabels();\n\n        this._renderAriaMinAndMax();\n\n        this._fitTooltip();\n\n        break;\n\n      case \"step\":\n        this._renderValue();\n\n        break;\n\n      case \"keyStep\":\n        break;\n\n      case \"showRange\":\n        this._renderRangeVisibility();\n\n        break;\n\n      case \"tooltip\":\n        this._renderHandle();\n\n        break;\n\n      case \"label\":\n        this._renderLabels();\n\n        break;\n\n      case \"useInkRipple\":\n        this._invalidate();\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _refresh: function () {\n    this._toggleRTLDirection(this.option(\"rtlEnabled\"));\n\n    this._renderDimensions();\n\n    this._renderValue();\n\n    this._renderHandle();\n\n    this._repaintHandle();\n  },\n  _clean: function () {\n    delete this._inkRipple;\n    this.callBase();\n  }\n});\nregisterComponent(\"dxSlider\", Slider);\nexport default Slider;","map":null,"metadata":{},"sourceType":"module"}