{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.work_space.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { setWidth, getOuterHeight, getOuterWidth, setOuterHeight, getHeight, getWidth } from \"../../../core/utils/size\";\nimport $ from \"../../../core/renderer\";\nimport domAdapter from \"../../../core/dom_adapter\";\nimport eventsEngine from \"../../../events/core/events_engine\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { getWindow, hasWindow } from \"../../../core/utils/window\";\nimport { getPublicElement } from \"../../../core/element\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport messageLocalization from \"../../../localization/message\";\nimport { noop } from \"../../../core/utils/common\";\nimport { isDefined } from \"../../../core/utils/type\";\nimport { addNamespace, isMouseEvent } from \"../../../events/utils/index\";\nimport pointerEvents from \"../../../events/pointer\";\nimport errors from \"../../widget/ui.errors\";\nimport { name as clickEventName } from \"../../../events/click\";\nimport { name as contextMenuEventName } from \"../../../events/contextmenu\";\nimport { enter as dragEventEnter, leave as dragEventLeave, drop as dragEventDrop } from \"../../../events/drag\";\nimport Scrollable from \"../../scroll_view/ui.scrollable\";\nimport HorizontalGroupedStrategy from \"./ui.scheduler.work_space.grouped.strategy.horizontal\";\nimport VerticalGroupedStrategy from \"./ui.scheduler.work_space.grouped.strategy.vertical\";\nimport tableCreatorModule from \"../table_creator\";\nvar {\n  tableCreator: tableCreator\n} = tableCreatorModule;\nimport VerticalShader from \"../shaders/ui.scheduler.current_time_shader.vertical\";\nimport AppointmentDragBehavior from \"../appointmentDragBehavior\";\nimport { APPOINTMENT_SETTINGS_KEY } from \"../constants\";\nimport { FIXED_CONTAINER_CLASS, VIRTUAL_CELL_CLASS, TIME_PANEL_CLASS, DATE_TABLE_CLASS, DATE_TABLE_ROW_CLASS, GROUP_ROW_CLASS, GROUP_HEADER_CONTENT_CLASS, VERTICAL_GROUP_COUNT_CLASSES } from \"../classes\";\nimport WidgetObserver from \"../base/widgetObserver\";\nimport { resetPosition, locate } from \"../../../animation/translator\";\nimport { VirtualScrollingDispatcher, VirtualScrollingRenderer } from \"./ui.scheduler.virtual_scrolling\";\nimport ViewDataProvider from \"./view_model/view_data_provider\";\nimport dxrDateTableLayout from \"../../../renovation/ui/scheduler/workspaces/base/date_table/layout.j\";\nimport dxrAllDayPanelTable from \"../../../renovation/ui/scheduler/workspaces/base/date_table/all_day_panel/table.j\";\nimport dxrAllDayPanelTitle from \"../../../renovation/ui/scheduler/workspaces/base/date_table/all_day_panel/title.j\";\nimport dxrTimePanelTableLayout from \"../../../renovation/ui/scheduler/workspaces/base/time_panel/layout.j\";\nimport dxrGroupPanel from \"../../../renovation/ui/scheduler/workspaces/base/group_panel/group_panel.j\";\nimport dxrDateHeader from \"../../../renovation/ui/scheduler/workspaces/base/header_panel/layout.j\";\nimport CellsSelectionState from \"./cells_selection_state\";\nimport { Cache } from \"./cache\";\nimport { CellsSelectionController } from \"./cells_selection_controller\";\nimport { calculateViewStartDate, getViewStartByOptions, validateDayHours, getStartViewDateTimeOffset, isDateAndTimeView, calculateIsGroupedAllDayPanel, getCellDuration } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { createResourcesTree, getCellGroups, getGroupsObjectFromGroupsArray, getGroupCount } from \"../resources/utils\";\nimport { ScrollSemaphore } from \"../../../renovation/ui/scheduler/utils/semaphore/scrollSemaphore\";\nimport { getCellWidth, getCellHeight, getAllDayHeight, getMaxAllowedPosition, PositionHelper } from \"./helpers/positionHelper\";\nimport { utils } from \"../utils\";\nimport { compileGetter } from \"../../../core/utils/data\";\nvar abstract = WidgetObserver.abstract;\nvar toMs = dateUtils.dateToMilliseconds;\nvar COMPONENT_CLASS = \"dx-scheduler-work-space\";\nvar GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-grouped\";\nvar VERTICAL_GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-vertical-grouped\";\nvar WORKSPACE_VERTICAL_GROUP_TABLE_CLASS = \"dx-scheduler-work-space-vertical-group-table\";\nvar WORKSPACE_WITH_BOTH_SCROLLS_CLASS = \"dx-scheduler-work-space-both-scrollbar\";\nvar WORKSPACE_WITH_COUNT_CLASS = \"dx-scheduler-work-space-count\";\nvar WORKSPACE_WITH_GROUP_BY_DATE_CLASS = \"dx-scheduler-work-space-group-by-date\";\nvar WORKSPACE_WITH_ODD_CELLS_CLASS = \"dx-scheduler-work-space-odd-cells\";\nvar TIME_PANEL_CELL_CLASS = \"dx-scheduler-time-panel-cell\";\nvar TIME_PANEL_ROW_CLASS = \"dx-scheduler-time-panel-row\";\nvar ALL_DAY_PANEL_CLASS = \"dx-scheduler-all-day-panel\";\nvar ALL_DAY_TABLE_CLASS = \"dx-scheduler-all-day-table\";\nvar ALL_DAY_CONTAINER_CLASS = \"dx-scheduler-all-day-appointments\";\nvar ALL_DAY_TITLE_CLASS = \"dx-scheduler-all-day-title\";\nvar ALL_DAY_TABLE_CELL_CLASS = \"dx-scheduler-all-day-table-cell\";\nvar ALL_DAY_TABLE_ROW_CLASS = \"dx-scheduler-all-day-table-row\";\nvar WORKSPACE_WITH_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day\";\nvar WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day-collapsed\";\nvar WORKSPACE_WITH_MOUSE_SELECTION_CLASS = \"dx-scheduler-work-space-mouse-selection\";\nvar HORIZONTAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-horizontal\";\nvar VERTICAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-vertical\";\nvar HEADER_PANEL_CLASS = \"dx-scheduler-header-panel\";\nvar HEADER_PANEL_CELL_CLASS = \"dx-scheduler-header-panel-cell\";\nvar HEADER_ROW_CLASS = \"dx-scheduler-header-row\";\nvar GROUP_HEADER_CLASS = \"dx-scheduler-group-header\";\nvar DATE_TABLE_CELL_CLASS = \"dx-scheduler-date-table-cell\";\nvar DATE_TABLE_FOCUSED_CELL_CLASS = \"dx-scheduler-focused-cell\";\nvar VIRTUAL_ROW_CLASS = \"dx-scheduler-virtual-row\";\nvar DATE_TABLE_DROPPABLE_CELL_CLASS = \"dx-scheduler-date-table-droppable-cell\";\nvar SCHEDULER_HEADER_SCROLLABLE_CLASS = \"dx-scheduler-header-scrollable\";\nvar SCHEDULER_SIDEBAR_SCROLLABLE_CLASS = \"dx-scheduler-sidebar-scrollable\";\nvar SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS = \"dx-scheduler-date-table-scrollable\";\nvar SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = addNamespace(pointerEvents.down, \"dxSchedulerWorkSpace\");\nvar DragEventNames = {\n  ENTER: addNamespace(dragEventEnter, \"dxSchedulerDateTable\"),\n  DROP: addNamespace(dragEventDrop, \"dxSchedulerDateTable\"),\n  LEAVE: addNamespace(dragEventLeave, \"dxSchedulerDateTable\")\n};\nvar SCHEDULER_CELL_DXCLICK_EVENT_NAME = addNamespace(clickEventName, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME = addNamespace(pointerEvents.down, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME = addNamespace(pointerEvents.up, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME = addNamespace(pointerEvents.move, \"dxSchedulerDateTable\");\nvar CELL_DATA = \"dxCellData\";\nvar DATE_TABLE_MIN_CELL_WIDTH = 75;\nvar DAY_MS = toMs(\"day\");\nvar HOUR_MS = toMs(\"hour\");\nvar DRAG_AND_DROP_SELECTOR = \".\".concat(DATE_TABLE_CLASS, \" td, .\").concat(ALL_DAY_TABLE_CLASS, \" td\");\nvar CELL_SELECTOR = \".\".concat(DATE_TABLE_CELL_CLASS, \", .\").concat(ALL_DAY_TABLE_CELL_CLASS);\n\nclass SchedulerWorkSpace extends WidgetObserver {\n  get viewDataProvider() {\n    if (!this._viewDataProvider) {\n      this._viewDataProvider = new ViewDataProvider(this.type);\n    }\n\n    return this._viewDataProvider;\n  }\n\n  get cache() {\n    if (!this._cache) {\n      this._cache = new Cache();\n    }\n\n    return this._cache;\n  }\n\n  get cellsSelectionState() {\n    if (!this._cellsSelectionState) {\n      this._cellsSelectionState = new CellsSelectionState(this.viewDataProvider);\n      var selectedCellsOption = this.option(\"selectedCellData\");\n\n      if ((null === selectedCellsOption || void 0 === selectedCellsOption ? void 0 : selectedCellsOption.length) > 0) {\n        var validSelectedCells = selectedCellsOption.map(selectedCell => {\n          var groups = selectedCell.groups;\n\n          if (!groups || 0 === this._getGroupCount()) {\n            return _extends({}, selectedCell, {\n              groupIndex: 0\n            });\n          }\n\n          var groupIndex = this._getGroupIndexByResourceId(groups);\n\n          return _extends({}, selectedCell, {\n            groupIndex: groupIndex\n          });\n        });\n\n        this._cellsSelectionState.setSelectedCellsByData(validSelectedCells);\n      }\n    }\n\n    return this._cellsSelectionState;\n  }\n\n  get cellsSelectionController() {\n    if (!this._cellsSelectionController) {\n      this._cellsSelectionController = new CellsSelectionController();\n    }\n\n    return this._cellsSelectionController;\n  }\n\n  get isAllDayPanelVisible() {\n    return this._isShowAllDayPanel() && this.supportAllDayRow();\n  }\n\n  get verticalGroupTableClass() {\n    return WORKSPACE_VERTICAL_GROUP_TABLE_CLASS;\n  }\n\n  get viewDirection() {\n    return \"vertical\";\n  }\n\n  get renovatedHeaderPanelComponent() {\n    return dxrDateHeader;\n  }\n\n  get timeZoneCalculator() {\n    return this.option(\"timeZoneCalculator\");\n  }\n\n  get isDefaultDraggingMode() {\n    return \"default\" === this.option(\"draggingMode\");\n  }\n\n  _supportedKeys() {\n    var clickHandler = function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      var selectedCells = this.cellsSelectionState.getSelectedCells();\n\n      if (null !== selectedCells && void 0 !== selectedCells && selectedCells.length) {\n        var selectedCellsElement = selectedCells.map(cellData => this._getCellByData(cellData)).filter(cell => !!cell);\n        e.target = selectedCellsElement;\n        this._showPopup = true;\n\n        this._cellClickAction({\n          event: e,\n          cellElement: $(selectedCellsElement),\n          cellData: selectedCells[0]\n        });\n      }\n    };\n\n    var onArrowPressed = (e, key) => {\n      var _this$cellsSelectionS;\n\n      e.preventDefault();\n      e.stopPropagation();\n      var focusedCellData = null === (_this$cellsSelectionS = this.cellsSelectionState.focusedCell) || void 0 === _this$cellsSelectionS ? void 0 : _this$cellsSelectionS.cellData;\n\n      if (focusedCellData) {\n        var isAllDayPanelCell = focusedCellData.allDay && !this._isVerticalGroupedWorkSpace();\n        var isMultiSelection = e.shiftKey;\n        var isMultiSelectionAllowed = this.option(\"allowMultipleCellSelection\");\n\n        var isRTL = this._isRTL();\n\n        var groupCount = this._getGroupCount();\n\n        var isGroupedByDate = this.isGroupedByDate();\n\n        var isHorizontalGrouping = this._isHorizontalGroupedWorkSpace();\n\n        var focusedCellPosition = this.viewDataProvider.findCellPositionInMap(_extends({}, focusedCellData, {\n          isAllDay: focusedCellData.allDay\n        }));\n        var edgeIndices = isHorizontalGrouping && isMultiSelection && !isGroupedByDate ? this.viewDataProvider.getGroupEdgeIndices(focusedCellData.groupIndex, isAllDayPanelCell) : this.viewDataProvider.getViewEdgeIndices(isAllDayPanelCell);\n        var nextCellData = this.cellsSelectionController.handleArrowClick({\n          focusedCellPosition: focusedCellPosition,\n          edgeIndices: edgeIndices,\n          isRTL: isRTL,\n          isGroupedByDate: isGroupedByDate,\n          groupCount: groupCount,\n          isMultiSelection: isMultiSelection,\n          isMultiSelectionAllowed: isMultiSelectionAllowed,\n          viewType: this.type,\n          key: key,\n          getCellDataByPosition: this.viewDataProvider.getCellData.bind(this.viewDataProvider),\n          isAllDayPanelCell: isAllDayPanelCell,\n          focusedCellData: focusedCellData\n        });\n\n        this._processNextSelectedCell(nextCellData, focusedCellData, isMultiSelection && isMultiSelectionAllowed);\n      }\n    };\n\n    return extend(super._supportedKeys(), {\n      enter: clickHandler,\n      space: clickHandler,\n      downArrow: e => {\n        onArrowPressed(e, \"down\");\n      },\n      upArrow: e => {\n        onArrowPressed(e, \"up\");\n      },\n      rightArrow: e => {\n        onArrowPressed(e, \"right\");\n      },\n      leftArrow: e => {\n        onArrowPressed(e, \"left\");\n      }\n    });\n  }\n\n  _isRTL() {\n    return this.option(\"rtlEnabled\");\n  }\n\n  _moveToCell($cell, isMultiSelection) {\n    if (!isDefined($cell) || !$cell.length) {\n      return;\n    }\n\n    var isMultiSelectionAllowed = this.option(\"allowMultipleCellSelection\");\n\n    var currentCellData = this._getFullCellData($cell);\n\n    var focusedCellData = this.cellsSelectionState.focusedCell.cellData;\n    var nextFocusedCellData = this.cellsSelectionController.moveToCell({\n      isMultiSelection: isMultiSelection,\n      isMultiSelectionAllowed: isMultiSelectionAllowed,\n      currentCellData: currentCellData,\n      focusedCellData: focusedCellData,\n      isVirtualCell: $cell.hasClass(VIRTUAL_CELL_CLASS)\n    });\n\n    this._processNextSelectedCell(nextFocusedCellData, focusedCellData, isMultiSelectionAllowed && isMultiSelection);\n  }\n\n  _processNextSelectedCell(nextCellData, focusedCellData, isMultiSelection) {\n    var nextCellPosition = this.viewDataProvider.findCellPositionInMap({\n      startDate: nextCellData.startDate,\n      groupIndex: nextCellData.groupIndex,\n      isAllDay: nextCellData.allDay,\n      index: nextCellData.index\n    });\n\n    if (!this.viewDataProvider.isSameCell(focusedCellData, nextCellData)) {\n      var $cell = nextCellData.allDay && !this._isVerticalGroupedWorkSpace() ? this._dom_getAllDayPanelCell(nextCellPosition.columnIndex) : this._dom_getDateCell(nextCellPosition);\n      var isNextCellAllDay = nextCellData.allDay;\n\n      this._setSelectedCellsStateAndUpdateSelection(isNextCellAllDay, nextCellPosition, isMultiSelection, $cell);\n\n      this._dateTableScrollable.scrollToElement($cell);\n    }\n  }\n\n  _setSelectedCellsStateAndUpdateSelection(isAllDay, cellPosition, isMultiSelection, $nextFocusedCell) {\n    var nextCellCoordinates = {\n      rowIndex: cellPosition.rowIndex,\n      columnIndex: cellPosition.columnIndex,\n      allDay: isAllDay\n    };\n    this.cellsSelectionState.setFocusedCell(nextCellCoordinates.rowIndex, nextCellCoordinates.columnIndex, isAllDay);\n\n    if (isMultiSelection) {\n      this.cellsSelectionState.setSelectedCells(nextCellCoordinates);\n    } else {\n      this.cellsSelectionState.setSelectedCells(nextCellCoordinates, nextCellCoordinates);\n    }\n\n    this.updateCellsSelection();\n\n    this._updateSelectedCellDataOption(this.cellsSelectionState.getSelectedCells(), $nextFocusedCell);\n  }\n\n  _hasAllDayClass($cell) {\n    return $cell.hasClass(ALL_DAY_TABLE_CELL_CLASS);\n  }\n\n  _focusInHandler(e) {\n    if ($(e.target).is(this._focusTarget()) && false !== this._isCellClick) {\n      delete this._isCellClick;\n      delete this._contextMenuHandled;\n\n      super._focusInHandler.apply(this, arguments);\n\n      this.cellsSelectionState.restoreSelectedAndFocusedCells();\n\n      if (!this.cellsSelectionState.focusedCell) {\n        var cellCoordinates = {\n          columnIndex: 0,\n          rowIndex: 0,\n          allDay: this._isVerticalGroupedWorkSpace() && this.isAllDayPanelVisible\n        };\n        this.cellsSelectionState.setFocusedCell(cellCoordinates.rowIndex, cellCoordinates.columnIndex, cellCoordinates.allDay);\n        this.cellsSelectionState.setSelectedCells(cellCoordinates, cellCoordinates);\n      }\n\n      this.updateCellsSelection();\n\n      this._updateSelectedCellDataOption(this.cellsSelectionState.getSelectedCells());\n    }\n  }\n\n  _focusOutHandler() {\n    super._focusOutHandler.apply(this, arguments);\n\n    if (!this._contextMenuHandled && !this._disposed) {\n      this.cellsSelectionState.releaseSelectedAndFocusedCells();\n      this.viewDataProvider.updateViewData(this.generateRenderOptions());\n      this.updateCellsSelection();\n    }\n  }\n\n  _focusTarget() {\n    return this.$element();\n  }\n\n  _isVerticalGroupedWorkSpace() {\n    return !!this.option(\"groups\").length && \"vertical\" === this.option(\"groupOrientation\");\n  }\n\n  _isHorizontalGroupedWorkSpace() {\n    return !!this.option(\"groups\").length && \"horizontal\" === this.option(\"groupOrientation\");\n  }\n\n  _isWorkSpaceWithCount() {\n    return this.option(\"intervalCount\") > 1;\n  }\n\n  _isWorkspaceWithOddCells() {\n    return .5 === this.option(\"hoursInterval\") && !this.isVirtualScrolling();\n  }\n\n  _getRealGroupOrientation() {\n    return this._isVerticalGroupedWorkSpace() ? \"vertical\" : \"horizontal\";\n  }\n\n  createRAllDayPanelElements() {\n    this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS);\n    this._$allDayTitle = $(\"<div>\").appendTo(this._$headerPanelEmptyCell);\n  }\n\n  _dateTableScrollableConfig() {\n    var config = {\n      useKeyboard: false,\n      bounceEnabled: false,\n      updateManually: true,\n      onScroll: () => {\n        var _this$_groupedStrateg;\n\n        null === (_this$_groupedStrateg = this._groupedStrategy.cache) || void 0 === _this$_groupedStrateg ? void 0 : _this$_groupedStrateg.clear();\n      }\n    };\n\n    if (this._needCreateCrossScrolling()) {\n      config = extend(config, this._createCrossScrollingConfig(config));\n    }\n\n    if (this.isVirtualScrolling() && (this.virtualScrollingDispatcher.horizontalScrollingAllowed || this.virtualScrollingDispatcher.height)) {\n      var currentOnScroll = config.onScroll;\n      config = _extends({}, config, {\n        onScroll: e => {\n          null === currentOnScroll || void 0 === currentOnScroll ? void 0 : currentOnScroll(e);\n          this.virtualScrollingDispatcher.handleOnScrollEvent(null === e || void 0 === e ? void 0 : e.scrollOffset);\n        }\n      });\n    }\n\n    return config;\n  }\n\n  _createCrossScrollingConfig(currentConfig) {\n    var config = {};\n    config.direction = \"both\";\n    var currentOnScroll = currentConfig.onScroll;\n\n    config.onScroll = e => {\n      currentOnScroll();\n\n      this._dataTableSemaphore.take(e.scrollOffset);\n\n      if (this._sideBarSemaphore.isFree(e.scrollOffset)) {\n        var _this$_sidebarScrolla;\n\n        null === (_this$_sidebarScrolla = this._sidebarScrollable) || void 0 === _this$_sidebarScrolla ? void 0 : _this$_sidebarScrolla.scrollTo({\n          top: e.scrollOffset.top\n        });\n      }\n\n      if (this._headerSemaphore.isFree(e.scrollOffset)) {\n        var _this$_headerScrollab;\n\n        null === (_this$_headerScrollab = this._headerScrollable) || void 0 === _this$_headerScrollab ? void 0 : _this$_headerScrollab.scrollTo({\n          left: e.scrollOffset.left\n        });\n      }\n\n      this._dataTableSemaphore.release();\n    };\n\n    config.onEnd = () => {\n      this.option(\"onScrollEnd\")();\n    };\n\n    return config;\n  }\n\n  _headerScrollableConfig() {\n    var config = {\n      useKeyboard: false,\n      showScrollbar: \"never\",\n      direction: \"horizontal\",\n      useNative: false,\n      updateManually: true,\n      bounceEnabled: false,\n      onScroll: e => {\n        this._headerSemaphore.take(e.scrollOffset);\n\n        this._dataTableSemaphore.isFree(e.scrollOffset) && this._dateTableScrollable.scrollTo({\n          left: e.scrollOffset.left\n        });\n\n        this._headerSemaphore.release();\n      }\n    };\n    return config;\n  }\n\n  _visibilityChanged(visible) {\n    this.cache.clear();\n\n    if (visible) {\n      this._updateGroupTableHeight();\n    }\n\n    if (visible && this._needCreateCrossScrolling()) {\n      this._setTableSizes();\n    }\n  }\n\n  _setTableSizes() {\n    this.cache.clear();\n\n    this._attachTableClasses();\n\n    var cellWidth = this.getCellWidth();\n\n    if (cellWidth < this.getCellMinWidth()) {\n      cellWidth = this.getCellMinWidth();\n    }\n\n    var minWidth = this.getWorkSpaceMinWidth();\n\n    var groupCount = this._getGroupCount();\n\n    var totalCellCount = this._getTotalCellCount(groupCount);\n\n    var width = cellWidth * totalCellCount;\n\n    if (width < minWidth) {\n      width = minWidth;\n    }\n\n    setWidth(this._$headerPanel, width);\n    setWidth(this._$dateTable, width);\n\n    if (this._$allDayTable) {\n      setWidth(this._$allDayTable, width);\n    }\n\n    this._attachHeaderTableClasses();\n\n    this._updateGroupTableHeight();\n\n    this._updateScrollable();\n  }\n\n  getWorkSpaceMinWidth() {\n    return this._groupedStrategy.getWorkSpaceMinWidth();\n  }\n\n  _dimensionChanged() {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    if (this.option(\"crossScrollingEnabled\")) {\n      this._setTableSizes();\n    }\n\n    this.updateHeaderEmptyCellWidth();\n\n    this._updateScrollable();\n\n    this.cache.clear();\n  }\n\n  _needCreateCrossScrolling() {\n    return this.option(\"crossScrollingEnabled\");\n  }\n\n  _getElementClass() {\n    return noop();\n  }\n\n  _getRowCount() {\n    return this.viewDataProvider.getRowCount({\n      intervalCount: this.option(\"intervalCount\"),\n      currentDate: this.option(\"currentDate\"),\n      viewType: this.type,\n      hoursInterval: this.option(\"hoursInterval\"),\n      startDayHour: this.option(\"startDayHour\"),\n      endDayHour: this.option(\"endDayHour\")\n    });\n  }\n\n  _getCellCount() {\n    return this.viewDataProvider.getCellCount({\n      intervalCount: this.option(\"intervalCount\"),\n      currentDate: this.option(\"currentDate\"),\n      viewType: this.type,\n      hoursInterval: this.option(\"hoursInterval\"),\n      startDayHour: this.option(\"startDayHour\"),\n      endDayHour: this.option(\"endDayHour\")\n    });\n  }\n\n  isRenovatedRender() {\n    return this.renovatedRenderSupported() && this.option(\"renovateRender\");\n  }\n\n  _isVirtualModeOn() {\n    return \"virtual\" === this.option(\"scrolling.mode\");\n  }\n\n  isVirtualScrolling() {\n    return this.isRenovatedRender() && this._isVirtualModeOn();\n  }\n\n  _initVirtualScrolling() {\n    if (this.virtualScrollingDispatcher) {\n      this.virtualScrollingDispatcher.dispose();\n      this.virtualScrollingDispatcher = null;\n    }\n\n    this.virtualScrollingDispatcher = new VirtualScrollingDispatcher(this._getVirtualScrollingDispatcherOptions());\n    this.virtualScrollingDispatcher.attachScrollableEvents();\n    this.renderer = new VirtualScrollingRenderer(this);\n  }\n\n  onDataSourceChanged() {}\n\n  isGroupedAllDayPanel() {\n    return calculateIsGroupedAllDayPanel(this.option(\"groups\"), this.option(\"groupOrientation\"), this.isAllDayPanelVisible);\n  }\n\n  generateRenderOptions(isProvideVirtualCellsWidth) {\n    var _this$_getToday;\n\n    var groupCount = this._getGroupCount();\n\n    var groupOrientation = groupCount > 0 ? this.option(\"groupOrientation\") : this._getDefaultGroupStrategy();\n\n    var options = _extends({\n      groupByDate: this.option(\"groupByDate\"),\n      startRowIndex: 0,\n      startCellIndex: 0,\n      groupOrientation: groupOrientation,\n      today: null === (_this$_getToday = this._getToday) || void 0 === _this$_getToday ? void 0 : _this$_getToday.call(this),\n      groups: this.option(\"groups\"),\n      isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\n      isAllDayPanelVisible: this.isAllDayPanelVisible,\n      selectedCells: this.cellsSelectionState.getSelectedCells(),\n      focusedCell: this.cellsSelectionState.focusedCell,\n      headerCellTextFormat: this._getFormat(),\n      getDateForHeaderText: (_, date) => date,\n      startDayHour: this.option(\"startDayHour\"),\n      endDayHour: this.option(\"endDayHour\"),\n      cellDuration: this.getCellDuration(),\n      viewType: this.type,\n      intervalCount: this.option(\"intervalCount\"),\n      hoursInterval: this.option(\"hoursInterval\"),\n      currentDate: this.option(\"currentDate\"),\n      startDate: this.option(\"startDate\"),\n      firstDayOfWeek: this.option(\"firstDayOfWeek\")\n    }, this.virtualScrollingDispatcher.getRenderState());\n\n    return options;\n  }\n\n  renovatedRenderSupported() {\n    return true;\n  }\n\n  _updateGroupTableHeight() {\n    if (this._isVerticalGroupedWorkSpace() && hasWindow()) {\n      this._setHorizontalGroupHeaderCellsHeight();\n    }\n  }\n\n  updateHeaderEmptyCellWidth() {\n    if (hasWindow() && this._isRenderHeaderPanelEmptyCell()) {\n      var timePanelWidth = this.getTimePanelWidth();\n      var groupPanelWidth = this.getGroupTableWidth();\n\n      this._$headerPanelEmptyCell.css(\"width\", timePanelWidth + groupPanelWidth);\n    }\n  }\n\n  _isGroupsSpecified(resources) {\n    return this.option(\"groups\").length && resources;\n  }\n\n  _getGroupIndexByResourceId(id) {\n    var groups = this.option(\"groups\");\n    var resourceTree = createResourcesTree(groups);\n\n    if (!resourceTree.length) {\n      return 0;\n    }\n\n    return this._getGroupIndexRecursively(resourceTree, id);\n  }\n\n  _getGroupIndexRecursively(resourceTree, id) {\n    var currentKey = resourceTree[0].name;\n    var currentValue = id[currentKey];\n    return resourceTree.reduce((prevIndex, _ref) => {\n      var {\n        leafIndex: leafIndex,\n        value: value,\n        children: children\n      } = _ref;\n      var areValuesEqual = currentValue === value;\n\n      if (areValuesEqual && void 0 !== leafIndex) {\n        return leafIndex;\n      }\n\n      if (areValuesEqual) {\n        return this._getGroupIndexRecursively(children, id);\n      }\n\n      return prevIndex;\n    }, 0);\n  }\n\n  _getViewStartByOptions() {\n    return getViewStartByOptions(this.option(\"startDate\"), this.option(\"currentDate\"), this._getIntervalDuration(), this.option(\"startDate\") ? this._calculateViewStartDate() : void 0);\n  }\n\n  _getIntervalDuration() {\n    return this.viewDataProvider.getIntervalDuration(this.option(\"intervalCount\"));\n  }\n\n  _getHeaderDate() {\n    return this.getStartViewDate();\n  }\n\n  _calculateViewStartDate() {\n    return calculateViewStartDate(this.option(\"startDate\"));\n  }\n\n  _firstDayOfWeek() {\n    return this.viewDataProvider.getFirstDayOfWeek(this.option(\"firstDayOfWeek\"));\n  }\n\n  _attachEvents() {\n    this._createSelectionChangedAction();\n\n    this._attachClickEvent();\n\n    this._attachContextMenuEvent();\n  }\n\n  _attachClickEvent() {\n    var that = this;\n\n    var pointerDownAction = this._createAction(function (e) {\n      that._pointerDownHandler(e.event);\n    });\n\n    this._createCellClickAction();\n\n    var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS;\n    var $element = this.$element();\n    eventsEngine.off($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME);\n    eventsEngine.off($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME);\n    eventsEngine.on($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, function (e) {\n      if (isMouseEvent(e) && e.which > 1) {\n        e.preventDefault();\n        return;\n      }\n\n      pointerDownAction({\n        event: e\n      });\n    });\n    eventsEngine.on($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME, cellSelector, function (e) {\n      var $cell = $(e.target);\n\n      that._cellClickAction({\n        event: e,\n        cellElement: getPublicElement($cell),\n        cellData: that.getCellData($cell)\n      });\n    });\n  }\n\n  _createCellClickAction() {\n    this._cellClickAction = this._createActionByOption(\"onCellClick\", {\n      afterExecute: e => this._cellClickHandler(e.args[0].event)\n    });\n  }\n\n  _createSelectionChangedAction() {\n    this._selectionChangedAction = this._createActionByOption(\"onSelectionChanged\");\n  }\n\n  _cellClickHandler() {\n    if (this._showPopup) {\n      delete this._showPopup;\n\n      this._handleSelectedCellsClick();\n    }\n  }\n\n  _pointerDownHandler(e) {\n    var $target = $(e.target);\n\n    if (!$target.hasClass(DATE_TABLE_CELL_CLASS) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {\n      this._isCellClick = false;\n      return;\n    }\n\n    this._isCellClick = true;\n\n    if ($target.hasClass(DATE_TABLE_FOCUSED_CELL_CLASS)) {\n      this._showPopup = true;\n    } else {\n      var cellCoordinates = this._getCoordinatesByCell($target);\n\n      var isAllDayCell = this._hasAllDayClass($target);\n\n      this._setSelectedCellsStateAndUpdateSelection(isAllDayCell, cellCoordinates, false, $target);\n    }\n  }\n\n  _handleSelectedCellsClick() {\n    var selectedCells = this.cellsSelectionState.getSelectedCells();\n    var firstCellData = selectedCells[0];\n    var lastCellData = selectedCells[selectedCells.length - 1];\n    var result = {\n      startDate: firstCellData.startDate,\n      endDate: lastCellData.endDate\n    };\n\n    if (void 0 !== lastCellData.allDay) {\n      result.allDay = lastCellData.allDay;\n    }\n\n    this.option(\"onSelectedCellsClick\")(result, lastCellData.groups);\n  }\n\n  _attachContextMenuEvent() {\n    this._createContextMenuAction();\n\n    var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS;\n    var $element = this.$element();\n    var eventName = addNamespace(contextMenuEventName, this.NAME);\n    eventsEngine.off($element, eventName, cellSelector);\n    eventsEngine.on($element, eventName, cellSelector, this._contextMenuHandler.bind(this));\n  }\n\n  _contextMenuHandler(e) {\n    var $cell = $(e.target);\n\n    this._contextMenuAction({\n      event: e,\n      cellElement: getPublicElement($cell),\n      cellData: this.getCellData($cell)\n    });\n\n    this._contextMenuHandled = true;\n  }\n\n  _createContextMenuAction() {\n    this._contextMenuAction = this._createActionByOption(\"onCellContextMenu\");\n  }\n\n  _getGroupHeaderContainer() {\n    if (this._isVerticalGroupedWorkSpace()) {\n      return this._$groupTable;\n    }\n\n    return this._$thead;\n  }\n\n  _getDateHeaderContainer() {\n    return this._$thead;\n  }\n\n  _getCalculateHeaderCellRepeatCount() {\n    return this._groupedStrategy.calculateHeaderCellRepeatCount();\n  }\n\n  _updateScrollable() {\n    var _this$_headerScrollab2, _this$_sidebarScrolla2;\n\n    this._dateTableScrollable.update();\n\n    null === (_this$_headerScrollab2 = this._headerScrollable) || void 0 === _this$_headerScrollab2 ? void 0 : _this$_headerScrollab2.update();\n    null === (_this$_sidebarScrolla2 = this._sidebarScrollable) || void 0 === _this$_sidebarScrolla2 ? void 0 : _this$_sidebarScrolla2.update();\n  }\n\n  _getTimePanelRowCount() {\n    return this._getCellCountInDay();\n  }\n\n  _getCellCountInDay() {\n    var hoursInterval = this.option(\"hoursInterval\");\n    var startDayHour = this.option(\"startDayHour\");\n    var endDayHour = this.option(\"endDayHour\");\n    return this.viewDataProvider.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n  }\n\n  _getTotalCellCount(groupCount) {\n    return this._groupedStrategy.getTotalCellCount(groupCount);\n  }\n\n  _getTotalRowCount(groupCount, includeAllDayPanelRows) {\n    var result = this._groupedStrategy.getTotalRowCount(groupCount);\n\n    if (includeAllDayPanelRows && this.isAllDayPanelVisible) {\n      result += groupCount;\n    }\n\n    return result;\n  }\n\n  _getGroupIndex(rowIndex, columnIndex) {\n    return this._groupedStrategy.getGroupIndex(rowIndex, columnIndex);\n  }\n\n  calculateEndDate(startDate) {\n    var viewDataGenerator = this.viewDataProvider.viewDataGenerator;\n    return viewDataGenerator.calculateEndDate(startDate, viewDataGenerator.getInterval(this.option(\"hoursInterval\")), this.option(\"endDayHour\"));\n  }\n\n  _getGroupCount() {\n    return getGroupCount(this.option(\"groups\"));\n  }\n\n  _attachTablesEvents() {\n    var element = this.$element();\n\n    this._attachDragEvents(element);\n\n    this._attachPointerEvents(element);\n  }\n\n  _detachDragEvents(element) {\n    eventsEngine.off(element, DragEventNames.ENTER);\n    eventsEngine.off(element, DragEventNames.LEAVE);\n    eventsEngine.off(element, DragEventNames.DROP);\n  }\n\n  _attachDragEvents(element) {\n    this._detachDragEvents(element);\n\n    eventsEngine.on(element, DragEventNames.ENTER, DRAG_AND_DROP_SELECTOR, {\n      checkDropTarget: (target, event) => !this._isOutsideScrollable(target, event)\n    }, e => {\n      if (!this.preventDefaultDragging) {\n        this.removeDroppableCellClass();\n        $(e.target).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n      }\n    });\n    eventsEngine.on(element, DragEventNames.LEAVE, () => {\n      if (!this.preventDefaultDragging) {\n        this.removeDroppableCellClass();\n      }\n    });\n    eventsEngine.on(element, DragEventNames.DROP, DRAG_AND_DROP_SELECTOR, () => {\n      var _this$dragBehavior, _this$dragBehavior$dr;\n\n      if (!(null !== (_this$dragBehavior = this.dragBehavior) && void 0 !== _this$dragBehavior && _this$dragBehavior.dragBetweenComponentsPromise)) {\n        this.dragBehavior.removeDroppableClasses();\n        return;\n      }\n\n      null === (_this$dragBehavior$dr = this.dragBehavior.dragBetweenComponentsPromise) || void 0 === _this$dragBehavior$dr ? void 0 : _this$dragBehavior$dr.then(() => {\n        this.dragBehavior.removeDroppableClasses();\n      });\n    });\n  }\n\n  _attachPointerEvents(element) {\n    var isPointerDown = false;\n    eventsEngine.off(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME);\n    eventsEngine.off(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME);\n    eventsEngine.on(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME, DRAG_AND_DROP_SELECTOR, e => {\n      if (isMouseEvent(e) && 1 === e.which) {\n        isPointerDown = true;\n        this.$element().addClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n        eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n        eventsEngine.on(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME, () => {\n          isPointerDown = false;\n          this.$element().removeClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n        });\n      }\n    });\n    eventsEngine.on(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME, DRAG_AND_DROP_SELECTOR, e => {\n      if (isPointerDown && this._dateTableScrollable && !this._dateTableScrollable.option(\"scrollByContent\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        this._moveToCell($(e.target), true);\n      }\n    });\n  }\n\n  _getFormat() {\n    return abstract();\n  }\n\n  getWorkArea() {\n    return this._$dateTableContainer;\n  }\n\n  getScrollable() {\n    return this._dateTableScrollable;\n  }\n\n  getScrollableScrollTop() {\n    return this._dateTableScrollable.scrollTop();\n  }\n\n  getGroupedScrollableScrollTop(allDay) {\n    return this._groupedStrategy.getScrollableScrollTop(allDay);\n  }\n\n  getScrollableScrollLeft() {\n    return this._dateTableScrollable.scrollLeft();\n  }\n\n  getScrollableOuterWidth() {\n    return this._dateTableScrollable.scrollWidth();\n  }\n\n  getScrollableContainer() {\n    return $(this._dateTableScrollable.container());\n  }\n\n  getHeaderPanelHeight() {\n    return this._$headerPanel && getOuterHeight(this._$headerPanel, true);\n  }\n\n  getTimePanelWidth() {\n    return this._$timePanel && getBoundingRect(this._$timePanel.get(0)).width;\n  }\n\n  getGroupTableWidth() {\n    return this._$groupTable ? getOuterWidth(this._$groupTable) : 0;\n  }\n\n  getWorkSpaceLeftOffset() {\n    return this._groupedStrategy.getLeftOffset();\n  }\n\n  _getCellCoordinatesByIndex(index) {\n    var columnIndex = Math.floor(index / this._getRowCount());\n    var rowIndex = index - this._getRowCount() * columnIndex;\n    return {\n      columnIndex: columnIndex,\n      rowIndex: rowIndex\n    };\n  }\n\n  _getDateGenerationOptions() {\n    var _this$viewDataProvide;\n\n    return {\n      startDayHour: this.option(\"startDayHour\"),\n      endDayHour: this.option(\"endDayHour\"),\n      isWorkView: this.viewDataProvider.viewDataGenerator.isWorkView,\n      interval: null === (_this$viewDataProvide = this.viewDataProvider.viewDataGenerator) || void 0 === _this$viewDataProvide ? void 0 : _this$viewDataProvide.getInterval(this.option(\"hoursInterval\")),\n      startViewDate: this.getStartViewDate(),\n      firstDayOfWeek: this._firstDayOfWeek()\n    };\n  }\n\n  _getIntervalBetween(currentDate, allDay) {\n    var firstViewDate = this.getStartViewDate();\n    var startDayTime = this.option(\"startDayHour\") * HOUR_MS;\n    var timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate);\n    var fullInterval = currentDate.getTime() - firstViewDate.getTime() - timeZoneOffset;\n\n    var days = this._getDaysOfInterval(fullInterval, startDayTime);\n\n    var weekendsCount = this._getWeekendsCount(days);\n\n    var result = (days - weekendsCount) * DAY_MS;\n\n    if (!allDay) {\n      var hiddenInterval = this.viewDataProvider.hiddenInterval;\n      var visibleDayDuration = this.getVisibleDayDuration();\n      result = fullInterval - days * hiddenInterval - weekendsCount * visibleDayDuration;\n    }\n\n    return result;\n  }\n\n  _getWeekendsCount() {\n    return 0;\n  }\n\n  _getDaysOfInterval(fullInterval, startDayTime) {\n    return Math.floor((fullInterval + startDayTime) / DAY_MS);\n  }\n\n  _updateIndex(index) {\n    return index * this._getRowCount();\n  }\n\n  _getDroppableCell() {\n    return this._getDateTables().find(\".\" + DATE_TABLE_DROPPABLE_CELL_CLASS);\n  }\n\n  _getWorkSpaceWidth() {\n    return this.cache.get(\"workspaceWidth\", () => {\n      if (this._needCreateCrossScrolling()) {\n        return getBoundingRect(this._$dateTable.get(0)).width;\n      }\n\n      var totalWidth = getBoundingRect(this.$element().get(0)).width;\n      var timePanelWidth = this.getTimePanelWidth();\n      var groupTableWidth = this.getGroupTableWidth();\n      return totalWidth - timePanelWidth - groupTableWidth;\n    });\n  }\n\n  _getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow) {\n    var indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex, inAllDayRow);\n\n    return this._dom_getDateCell(indexes);\n  }\n\n  _dom_getDateCell(position) {\n    return this._$dateTable.find(\"tr:not(.\".concat(VIRTUAL_ROW_CLASS, \")\")).eq(position.rowIndex).find(\"td:not(.\".concat(VIRTUAL_CELL_CLASS, \")\")).eq(position.columnIndex);\n  }\n\n  _dom_getAllDayPanelCell(columnIndex) {\n    return this._$allDayPanel.find(\"tr\").eq(0).find(\"td\").eq(columnIndex);\n  }\n\n  _getCells(allDay, direction) {\n    var cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;\n\n    if (\"vertical\" === direction) {\n      var result = [];\n\n      for (var i = 1;; i++) {\n        var cells = this.$element().find(\"tr .\".concat(cellClass, \":nth-child(\").concat(i, \")\"));\n\n        if (!cells.length) {\n          break;\n        }\n\n        result = result.concat(cells.toArray());\n      }\n\n      return $(result);\n    } else {\n      return this.$element().find(\".\" + cellClass);\n    }\n  }\n\n  _getAllCells(allDay) {\n    if (this._isVerticalGroupedWorkSpace()) {\n      return this._$dateTable.find(\"td:not(.\".concat(VIRTUAL_CELL_CLASS, \")\"));\n    }\n\n    var cellClass = allDay && this.supportAllDayRow() ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;\n    return this.$element().find(\".\".concat(cellClass));\n  }\n\n  _setHorizontalGroupHeaderCellsHeight() {\n    var height = getBoundingRect(this._$dateTable.get(0)).height;\n    setOuterHeight(this._$groupTable, height);\n  }\n\n  _getGroupHeaderCells() {\n    return this.$element().find(\".\" + GROUP_HEADER_CLASS);\n  }\n\n  _getScrollCoordinates(hours, minutes, date, groupIndex, allDay) {\n    var currentDate = date || new Date(this.option(\"currentDate\"));\n    var startDayHour = this.option(\"startDayHour\");\n    var endDayHour = this.option(\"endDayHour\");\n\n    if (hours < startDayHour) {\n      hours = startDayHour;\n    }\n\n    if (hours >= endDayHour) {\n      hours = endDayHour - 1;\n    }\n\n    currentDate.setHours(hours, minutes, 0, 0);\n    var cell = this.viewDataProvider.findGlobalCellPosition(currentDate, groupIndex, allDay);\n    var {\n      position: position,\n      cellData: cellData\n    } = cell;\n    return this.virtualScrollingDispatcher.calculateCoordinatesByDataAndPosition(cellData, position, currentDate, isDateAndTimeView(this.type), \"vertical\" === this.viewDirection);\n  }\n\n  _isOutsideScrollable(target, event) {\n    var $dateTableScrollableElement = this._dateTableScrollable.$element();\n\n    var scrollableSize = getBoundingRect($dateTableScrollableElement.get(0));\n    var window = getWindow();\n    var isTargetInAllDayPanel = !$(target).closest($dateTableScrollableElement).length;\n    var isOutsideHorizontalScrollable = event.pageX < scrollableSize.left || event.pageX > scrollableSize.left + scrollableSize.width + (window.scrollX || 0);\n    var isOutsideVerticalScrollable = event.pageY < scrollableSize.top || event.pageY > scrollableSize.top + scrollableSize.height + (window.scrollY || 0);\n\n    if (isTargetInAllDayPanel && !isOutsideHorizontalScrollable) {\n      return false;\n    }\n\n    return isOutsideVerticalScrollable || isOutsideHorizontalScrollable;\n  }\n\n  setCellDataCache(cellCoordinates, groupIndex, $cell) {\n    var key = JSON.stringify({\n      rowIndex: cellCoordinates.rowIndex,\n      columnIndex: cellCoordinates.columnIndex,\n      groupIndex: groupIndex\n    });\n    this.cache.set(key, this.getCellData($cell));\n  }\n\n  setCellDataCacheAlias(appointment, geometry) {\n    var key = JSON.stringify({\n      rowIndex: appointment.rowIndex,\n      columnIndex: appointment.columnIndex,\n      groupIndex: appointment.groupIndex\n    });\n    var aliasKey = JSON.stringify({\n      top: geometry.top,\n      left: geometry.left\n    });\n    this.cache.set(aliasKey, this.cache.get(key));\n  }\n\n  supportAllDayRow() {\n    return true;\n  }\n\n  keepOriginalHours() {\n    return false;\n  }\n\n  _filterCellDataFields(cellData) {\n    return extend(true, {}, {\n      startDate: cellData.startDate,\n      endDate: cellData.endDate,\n      groups: cellData.groups,\n      groupIndex: cellData.groupIndex,\n      allDay: cellData.allDay\n    });\n  }\n\n  getCellData($cell) {\n    var cellData = this._getFullCellData($cell) || {};\n    return this._filterCellDataFields(cellData);\n  }\n\n  _getFullCellData($cell) {\n    var currentCell = $cell[0];\n\n    if (currentCell) {\n      return this._getDataByCell($cell);\n    }\n\n    return;\n  }\n\n  _getVirtualRowOffset() {\n    return this.virtualScrollingDispatcher.virtualRowOffset;\n  }\n\n  _getVirtualCellOffset() {\n    return this.virtualScrollingDispatcher.virtualCellOffset;\n  }\n\n  _getDataByCell($cell) {\n    var rowIndex = $cell.parent().index() - this.virtualScrollingDispatcher.topVirtualRowsCount;\n    var columnIndex = $cell.index() - this.virtualScrollingDispatcher.leftVirtualCellsCount;\n    var {\n      viewDataProvider: viewDataProvider\n    } = this;\n\n    var isAllDayCell = this._hasAllDayClass($cell);\n\n    var cellData = viewDataProvider.getCellData(rowIndex, columnIndex, isAllDayCell);\n    return cellData ? cellData : void 0;\n  }\n\n  isGroupedByDate() {\n    return this.option(\"groupByDate\") && this._isHorizontalGroupedWorkSpace() && this._getGroupCount() > 0;\n  }\n\n  getCellIndexByDate(date, inAllDayRow) {\n    var viewDataGenerator = this.viewDataProvider.viewDataGenerator;\n    var timeInterval = inAllDayRow ? 864e5 : viewDataGenerator.getInterval(this.option(\"hoursInterval\"));\n    var startViewDateOffset = getStartViewDateTimeOffset(this.getStartViewDate(), this.option(\"startDayHour\"));\n    var dateTimeStamp = this._getIntervalBetween(date, inAllDayRow) + startViewDateOffset;\n    var index = Math.floor(dateTimeStamp / timeInterval);\n\n    if (inAllDayRow) {\n      index = this._updateIndex(index);\n    }\n\n    if (index < 0) {\n      index = 0;\n    }\n\n    return index;\n  }\n\n  getDroppableCellIndex() {\n    var $droppableCell = this._getDroppableCell();\n\n    var $row = $droppableCell.parent();\n    var rowIndex = $row.index();\n    return rowIndex * $row.find(\"td\").length + $droppableCell.index();\n  }\n\n  getDataByDroppableCell() {\n    var cellData = this.getCellData($(this._getDroppableCell()));\n    var allDay = cellData.allDay;\n    var startDate = cellData.startDate;\n    var endDate = cellData.endDate;\n    return {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay,\n      groups: cellData.groups\n    };\n  }\n\n  getDateRange() {\n    return [this.getStartViewDate(), this.getEndViewDateByEndDayHour()];\n  }\n\n  getCellMinWidth() {\n    return DATE_TABLE_MIN_CELL_WIDTH;\n  }\n\n  getRoundedCellWidth(groupIndex, startIndex, cellCount) {\n    if (groupIndex < 0 || !hasWindow()) {\n      return 0;\n    }\n\n    var $row = this.$element().find(\".\".concat(DATE_TABLE_ROW_CLASS)).eq(0);\n    var width = 0;\n    var $cells = $row.find(\".\" + DATE_TABLE_CELL_CLASS);\n    var totalCellCount = this._getCellCount() * groupIndex;\n    cellCount = cellCount || this._getCellCount();\n\n    if (!isDefined(startIndex)) {\n      startIndex = totalCellCount;\n    }\n\n    for (var i = startIndex; i < totalCellCount + cellCount; i++) {\n      var element = $($cells).eq(i).get(0);\n      var elementWidth = element ? getBoundingRect(element).width : 0;\n      width += elementWidth;\n    }\n\n    return width / (totalCellCount + cellCount - startIndex);\n  }\n\n  getCellWidth() {\n    return getCellWidth(this.getDOMElementsMetaData());\n  }\n\n  getCellHeight() {\n    return getCellHeight(this.getDOMElementsMetaData());\n  }\n\n  getAllDayHeight() {\n    return getAllDayHeight(this.option(\"showAllDayPanel\"), this._isVerticalGroupedWorkSpace(), this.getDOMElementsMetaData());\n  }\n\n  getMaxAllowedPosition(groupIndex) {\n    return getMaxAllowedPosition(groupIndex, this.viewDataProvider, this.option(\"rtlEnabled\"), this.getDOMElementsMetaData());\n  }\n\n  getAllDayOffset() {\n    return this._groupedStrategy.getAllDayOffset();\n  }\n\n  getCellIndexByCoordinates(coordinates, allDay) {\n    var cellCount = this._getTotalCellCount(this._getGroupCount());\n\n    var cellWidth = Math.floor(this._getWorkSpaceWidth() / cellCount);\n    var cellHeight = allDay ? this.getAllDayHeight() : this.getCellHeight();\n    var topIndex = Math.floor(Math.floor(coordinates.top) / Math.floor(cellHeight));\n    var leftIndex = Math.floor((coordinates.left + 5) / cellWidth);\n\n    if (this._isRTL()) {\n      leftIndex = cellCount - leftIndex - 1;\n    }\n\n    return cellCount * topIndex + leftIndex;\n  }\n\n  getStartViewDate() {\n    return this.viewDataProvider.getStartViewDate();\n  }\n\n  getEndViewDate() {\n    return this.viewDataProvider.getLastCellEndDate();\n  }\n\n  getEndViewDateByEndDayHour() {\n    return this.viewDataProvider.getLastViewDateByEndDayHour(this.option(\"endDayHour\"));\n  }\n\n  getCellDuration() {\n    return getCellDuration(this.type, this.option(\"startDayHour\"), this.option(\"endDayHour\"), this.option(\"hoursInterval\"));\n  }\n\n  getIntervalDuration(allDay) {\n    return allDay ? toMs(\"day\") : this.getCellDuration();\n  }\n\n  getVisibleDayDuration() {\n    var startDayHour = this.option(\"startDayHour\");\n    var endDayHour = this.option(\"endDayHour\");\n    var hoursInterval = this.option(\"hoursInterval\");\n    return this.viewDataProvider.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);\n  }\n\n  getGroupBounds(coordinates) {\n    var cellCount = this._getCellCount();\n\n    var $cells = this._getCells();\n\n    var cellWidth = this.getCellWidth();\n    var groupedDataMap = this.viewDataProvider.groupedDataMap;\n\n    var result = this._groupedStrategy.getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap);\n\n    if (this._isRTL()) {\n      var startOffset = result.left;\n      result.left = result.right - 2 * cellWidth;\n      result.right = startOffset + 2 * cellWidth;\n    }\n\n    return result;\n  }\n\n  needRecalculateResizableArea() {\n    return this._isVerticalGroupedWorkSpace() && 0 !== this.getScrollable().scrollTop();\n  }\n\n  getCellDataByCoordinates(coordinates, allDay) {\n    var key = JSON.stringify({\n      top: coordinates.top,\n      left: coordinates.left\n    });\n    return this.cache.get(key, () => {\n      var $cells = this._getCells(allDay);\n\n      var cellIndex = this.getCellIndexByCoordinates(coordinates, allDay);\n      var $cell = $cells.eq(cellIndex);\n      return this.getCellData($cell);\n    });\n  }\n\n  getVisibleBounds() {\n    var result = {};\n    var $scrollable = this.getScrollable().$element();\n    var cellHeight = this.getCellHeight();\n    var scrolledCellCount = this.getScrollableScrollTop() / cellHeight;\n    var totalCellCount = scrolledCellCount + getHeight($scrollable) / cellHeight;\n    result.top = {\n      hours: Math.floor(scrolledCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n      minutes: scrolledCellCount % 2 ? 30 : 0\n    };\n    result.bottom = {\n      hours: Math.floor(totalCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n      minutes: Math.floor(totalCellCount) % 2 ? 30 : 0\n    };\n    return result;\n  }\n\n  updateScrollPosition(date, groups) {\n    var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n    var newDate = this.timeZoneCalculator.createDate(date, {\n      path: \"toGrid\"\n    });\n    var inAllDayRow = allDay && this.isAllDayPanelVisible;\n\n    if (this.needUpdateScrollPosition(newDate, groups, inAllDayRow)) {\n      this.scrollTo(newDate, groups, inAllDayRow, false);\n    }\n  }\n\n  needUpdateScrollPosition(date, groups, inAllDayRow) {\n    var cells = this._getCellsInViewport(inAllDayRow);\n\n    var groupIndex = this._isGroupsSpecified(groups) ? this._getGroupIndexByResourceId(groups) : 0;\n    var time = date.getTime();\n    var trimmedTime = dateUtils.trimTime(date).getTime();\n    return cells.reduce((currentResult, cell) => {\n      var {\n        startDate: cellStartDate,\n        endDate: cellEndDate,\n        groupIndex: cellGroupIndex\n      } = this.getCellData(cell);\n      var cellStartTime = cellStartDate.getTime();\n      var cellEndTime = cellEndDate.getTime();\n\n      if ((!inAllDayRow && cellStartTime <= time && time < cellEndTime || inAllDayRow && trimmedTime === cellStartTime) && groupIndex === cellGroupIndex) {\n        return false;\n      }\n\n      return currentResult;\n    }, true);\n  }\n\n  _getCellsInViewport(inAllDayRow) {\n    var $scrollable = this.getScrollable().$element();\n    var cellHeight = this.getCellHeight();\n    var cellWidth = this.getCellWidth();\n\n    var totalColumnCount = this._getTotalCellCount(this._getGroupCount());\n\n    var scrollableScrollTop = this.getScrollableScrollTop();\n    var scrollableScrollLeft = this.getScrollableScrollLeft();\n    var fullScrolledRowCount = scrollableScrollTop / cellHeight - this.virtualScrollingDispatcher.topVirtualRowsCount;\n    var scrolledRowCount = Math.floor(fullScrolledRowCount);\n\n    if (scrollableScrollTop % cellHeight !== 0) {\n      scrolledRowCount += 1;\n    }\n\n    var fullScrolledColumnCount = scrollableScrollLeft / cellWidth;\n    var scrolledColumnCount = Math.floor(fullScrolledColumnCount);\n\n    if (scrollableScrollLeft % cellWidth !== 0) {\n      scrolledColumnCount += 1;\n    }\n\n    var rowCount = Math.floor(fullScrolledRowCount + getHeight($scrollable) / cellHeight);\n    var columnCount = Math.floor(fullScrolledColumnCount + getWidth($scrollable) / cellWidth);\n\n    var $cells = this._getAllCells(inAllDayRow);\n\n    var result = [];\n    $cells.each(function (index) {\n      var $cell = $(this);\n      var columnIndex = index % totalColumnCount;\n      var rowIndex = index / totalColumnCount;\n\n      if (scrolledColumnCount <= columnIndex && columnIndex < columnCount && scrolledRowCount <= rowIndex && rowIndex < rowCount) {\n        result.push($cell);\n      }\n    });\n    return result;\n  }\n\n  scrollToTime(hours, minutes, date) {\n    if (!this._isValidScrollDate(date)) {\n      return;\n    }\n\n    var coordinates = this._getScrollCoordinates(hours, minutes, date);\n\n    var scrollable = this.getScrollable();\n    scrollable.scrollBy({\n      top: coordinates.top - scrollable.scrollTop(),\n      left: 0\n    });\n  }\n\n  scrollTo(date, groups) {\n    var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n    var throwWarning = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;\n\n    if (!this._isValidScrollDate(date, throwWarning)) {\n      return;\n    }\n\n    var groupIndex = this._getGroupCount() && groups ? this._getGroupIndexByResourceId(groups) : 0;\n    var isScrollToAllDay = allDay && this.isAllDayPanelVisible;\n\n    var coordinates = this._getScrollCoordinates(date.getHours(), date.getMinutes(), date, groupIndex, isScrollToAllDay);\n\n    var scrollable = this.getScrollable();\n    var $scrollable = scrollable.$element();\n    var cellWidth = this.getCellWidth();\n    var offset = this.option(\"rtlEnabled\") ? cellWidth : 0;\n    var scrollableHeight = getHeight($scrollable);\n    var scrollableWidth = getWidth($scrollable);\n    var cellHeight = this.getCellHeight();\n    var xShift = (scrollableWidth - cellWidth) / 2;\n    var yShift = (scrollableHeight - cellHeight) / 2;\n    var left = coordinates.left - scrollable.scrollLeft() - xShift - offset;\n    var top = coordinates.top - scrollable.scrollTop() - yShift;\n\n    if (isScrollToAllDay && !this._isVerticalGroupedWorkSpace()) {\n      top = 0;\n    }\n\n    if (this.option(\"templatesRenderAsynchronously\")) {\n      setTimeout(() => {\n        scrollable.scrollBy({\n          left: left,\n          top: top\n        });\n      });\n    } else {\n      scrollable.scrollBy({\n        left: left,\n        top: top\n      });\n    }\n  }\n\n  _isValidScrollDate(date) {\n    var throwWarning = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;\n    var min = this.getStartViewDate();\n    var max = this.getEndViewDate();\n\n    if (date < min || date > max) {\n      throwWarning && errors.log(\"W1008\", date);\n      return false;\n    }\n\n    return true;\n  }\n\n  needApplyCollectorOffset() {\n    return false;\n  }\n\n  removeDroppableCellClass($cellElement) {\n    ($cellElement || this._getDroppableCell()).removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n  }\n\n  _getCoordinatesByCell($cell) {\n    var columnIndex = $cell.index() - this.virtualScrollingDispatcher.leftVirtualCellsCount;\n    var rowIndex = $cell.parent().index();\n\n    var isAllDayCell = this._hasAllDayClass($cell);\n\n    var isVerticalGrouping = this._isVerticalGroupedWorkSpace();\n\n    if (!(isAllDayCell && !isVerticalGrouping)) {\n      rowIndex -= this.virtualScrollingDispatcher.topVirtualRowsCount;\n    }\n\n    return {\n      rowIndex: rowIndex,\n      columnIndex: columnIndex\n    };\n  }\n\n  _isShowAllDayPanel() {\n    return this.option(\"showAllDayPanel\");\n  }\n\n  _getTimePanelCells() {\n    return this.$element().find(\".\".concat(TIME_PANEL_CELL_CLASS));\n  }\n\n  _getRDateTableProps() {\n    return {\n      viewData: this.viewDataProvider.viewData,\n      dataCellTemplate: this.option(\"dataCellTemplate\"),\n      addDateTableClass: !this.option(\"crossScrollingEnabled\") || this.isVirtualScrolling(),\n      groupOrientation: this.option(\"groupOrientation\"),\n      addVerticalSizesClassToRows: false\n    };\n  }\n\n  _updateSelectedCellDataOption(selectedCellData) {\n    var correctedSelectedCellData = selectedCellData.map(_ref2 => {\n      var {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: allDay,\n        groupIndex: groupIndex,\n        groups: groups\n      } = _ref2;\n      return {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: allDay,\n        groupIndex: groupIndex,\n        groups: groups\n      };\n    });\n    this.option(\"selectedCellData\", correctedSelectedCellData);\n\n    this._selectionChangedAction({\n      selectedCellData: correctedSelectedCellData\n    });\n  }\n\n  _getCellByData(cellData) {\n    var {\n      startDate: startDate,\n      groupIndex: groupIndex,\n      allDay: allDay,\n      index: index\n    } = cellData;\n    var position = this.viewDataProvider.findCellPositionInMap({\n      startDate: startDate,\n      groupIndex: groupIndex,\n      isAllDay: allDay,\n      index: index\n    });\n\n    if (!position) {\n      return;\n    }\n\n    return allDay && !this._isVerticalGroupedWorkSpace() ? this._dom_getAllDayPanelCell(position.columnIndex) : this._dom_getDateCell(position);\n  }\n\n  getDOMElementsMetaData() {\n    return this.cache.get(\"cellElementsMeta\", () => ({\n      dateTableCellsMeta: this._getDateTableDOMElementsInfo(),\n      allDayPanelCellsMeta: this._getAllDayPanelDOMElementsInfo()\n    }));\n  }\n\n  _getDateTableDOMElementsInfo() {\n    var dateTableCells = this._getAllCells(false);\n\n    if (!dateTableCells.length || !hasWindow()) {\n      return [[{}]];\n    }\n\n    var dateTable = this._getDateTable();\n\n    var dateTableRect = getBoundingRect(dateTable.get(0));\n    var columnsCount = this.viewDataProvider.getColumnsCount();\n    var result = [];\n    dateTableCells.each((index, cell) => {\n      var rowIndex = Math.floor(index / columnsCount);\n\n      if (result.length === rowIndex) {\n        result.push([]);\n      }\n\n      this._addCellMetaData(result[rowIndex], cell, dateTableRect);\n    });\n    return result;\n  }\n\n  _getAllDayPanelDOMElementsInfo() {\n    var result = [];\n\n    if (this.isAllDayPanelVisible && !this._isVerticalGroupedWorkSpace() && hasWindow()) {\n      var allDayCells = this._getAllCells(true);\n\n      if (!allDayCells.length) {\n        return [{}];\n      }\n\n      var allDayAppointmentContainer = this._$allDayPanel;\n      var allDayPanelRect = getBoundingRect(allDayAppointmentContainer.get(0));\n      allDayCells.each((_, cell) => {\n        this._addCellMetaData(result, cell, allDayPanelRect);\n      });\n    }\n\n    return result;\n  }\n\n  _addCellMetaData(cellMetaDataArray, cell, parentRect) {\n    var cellRect = getBoundingRect(cell);\n    cellMetaDataArray.push({\n      left: cellRect.left - parentRect.left,\n      top: cellRect.top - parentRect.top,\n      width: cellRect.width,\n      height: cellRect.height\n    });\n  }\n\n  _oldRender_getAllDayCellData(groupIndex) {\n    return (cell, rowIndex, columnIndex) => {\n      var validColumnIndex = columnIndex % this._getCellCount();\n\n      var options = this._getDateGenerationOptions(true);\n\n      var startDate = this.viewDataProvider.viewDataGenerator.getDateByCellIndices(options, rowIndex, validColumnIndex, this._getCellCountInDay());\n      startDate = dateUtils.trimTime(startDate);\n      var validGroupIndex = groupIndex || 0;\n\n      if (this.isGroupedByDate()) {\n        validGroupIndex = Math.floor(columnIndex % this._getGroupCount());\n      } else if (this._isHorizontalGroupedWorkSpace()) {\n        validGroupIndex = Math.floor(columnIndex / this._getCellCount());\n      }\n\n      var data = {\n        startDate: startDate,\n        endDate: startDate,\n        allDay: true,\n        groupIndex: validGroupIndex\n      };\n      var groupsArray = getCellGroups(validGroupIndex, this.option(\"groups\"));\n\n      if (groupsArray.length) {\n        data.groups = getGroupsObjectFromGroupsArray(groupsArray);\n      }\n\n      return {\n        key: CELL_DATA,\n        value: data\n      };\n    };\n  }\n\n  renderRWorkSpace(componentsToRender) {\n    var components = null !== componentsToRender && void 0 !== componentsToRender ? componentsToRender : {\n      header: true,\n      timePanel: true,\n      dateTable: true,\n      allDayPanel: true\n    };\n    components.header && this.renderRHeaderPanel();\n    components.timePanel && this.renderRTimeTable();\n    components.dateTable && this.renderRDateTable();\n    components.allDayPanel && this.renderRAllDayPanel();\n  }\n\n  renderRDateTable() {\n    utils.renovation.renderComponent(this, this._$dateTable, dxrDateTableLayout, \"renovatedDateTable\", this._getRDateTableProps());\n  }\n\n  renderRGroupPanel() {\n    var options = {\n      groups: this.option(\"groups\"),\n      groupOrientation: this.option(\"groupOrientation\"),\n      groupByDate: this.isGroupedByDate(),\n      resourceCellTemplate: this.option(\"resourceCellTemplate\"),\n      className: this.verticalGroupTableClass,\n      groupPanelData: this.viewDataProvider.getGroupPanelData(this.generateRenderOptions())\n    };\n\n    if (this.option(\"groups\").length) {\n      this._attachGroupCountClass();\n\n      utils.renovation.renderComponent(this, this._getGroupHeaderContainer(), dxrGroupPanel, \"renovatedGroupPanel\", options);\n    } else {\n      this._detachGroupCountClass();\n    }\n  }\n\n  renderRAllDayPanel() {\n    var visible = this.isAllDayPanelVisible && !this.isGroupedAllDayPanel();\n\n    if (visible) {\n      var _this$virtualScrollin;\n\n      this._toggleAllDayVisibility(false);\n\n      var options = _extends({\n        viewData: this.viewDataProvider.viewData,\n        dataCellTemplate: this.option(\"dataCellTemplate\"),\n        startCellIndex: 0\n      }, (null === (_this$virtualScrollin = this.virtualScrollingDispatcher.horizontalVirtualScrolling) || void 0 === _this$virtualScrollin ? void 0 : _this$virtualScrollin.getRenderState()) || {});\n\n      utils.renovation.renderComponent(this, this._$allDayTable, dxrAllDayPanelTable, \"renovatedAllDayPanel\", options);\n      utils.renovation.renderComponent(this, this._$allDayTitle, dxrAllDayPanelTitle, \"renovatedAllDayPanelTitle\", {});\n    }\n\n    this._toggleAllDayVisibility(true);\n  }\n\n  renderRTimeTable() {\n    utils.renovation.renderComponent(this, this._$timePanel, dxrTimePanelTableLayout, \"renovatedTimePanel\", {\n      timePanelData: this.viewDataProvider.timePanelData,\n      timeCellTemplate: this.option(\"timeCellTemplate\"),\n      groupOrientation: this.option(\"groupOrientation\")\n    });\n  }\n\n  renderRHeaderPanel() {\n    var isRenderDateHeader = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;\n\n    if (this.option(\"groups\").length) {\n      this._attachGroupCountClass();\n    } else {\n      this._detachGroupCountClass();\n    }\n\n    utils.renovation.renderComponent(this, this._$thead, this.renovatedHeaderPanelComponent, \"renovatedHeaderPanel\", {\n      dateHeaderData: this.viewDataProvider.dateHeaderData,\n      groupPanelData: this.viewDataProvider.getGroupPanelData(this.generateRenderOptions()),\n      dateCellTemplate: this.option(\"dateCellTemplate\"),\n      timeCellTemplate: this.option(\"timeCellTemplate\"),\n      groups: this.option(\"groups\"),\n      groupByDate: this.isGroupedByDate(),\n      groupOrientation: this.option(\"groupOrientation\"),\n      resourceCellTemplate: this.option(\"resourceCellTemplate\"),\n      isRenderDateHeader: isRenderDateHeader\n    });\n  }\n\n  initDragBehavior(scheduler) {\n    if (!this.dragBehavior && scheduler) {\n      this.dragBehavior = new AppointmentDragBehavior(scheduler);\n\n      this._createDragBehavior(this.getWorkArea());\n\n      this._createDragBehavior(this.getAllDayContainer());\n\n      this._createDragBehavior(this._$allDayPanel);\n    }\n  }\n\n  _createDragBehavior($element) {\n    var options = {\n      getItemData: (itemElement, appointments) => appointments._getItemData(itemElement),\n      getItemSettings: $itemElement => $itemElement.data(APPOINTMENT_SETTINGS_KEY)\n    };\n\n    this._createDragBehaviorBase($element, options);\n  }\n\n  _createDragBehaviorBase($element, options) {\n    var container = this.$element().find(\".\".concat(FIXED_CONTAINER_CLASS));\n    this.dragBehavior.addTo($element, createDragBehaviorConfig(container, this.isDefaultDraggingMode, this.dragBehavior, () => {\n      if (!this.isDefaultDraggingMode) {\n        this.preventDefaultDragging = false;\n      }\n    }, () => {\n      if (!this.isDefaultDraggingMode) {\n        this.preventDefaultDragging = true;\n      }\n    }, () => this._getDroppableCell(), () => this._getDateTables(), () => this.removeDroppableCellClass(), () => this.getCellWidth(), options));\n  }\n\n  _isRenderHeaderPanelEmptyCell() {\n    return this._isVerticalGroupedWorkSpace();\n  }\n\n  _dispose() {\n    super._dispose();\n\n    this.virtualScrollingDispatcher.dispose();\n  }\n\n  _getDefaultOptions() {\n    return extend(super._getDefaultOptions(), {\n      currentDate: new Date(),\n      intervalCount: 1,\n      startDate: null,\n      firstDayOfWeek: void 0,\n      startDayHour: 0,\n      endDayHour: 24,\n      hoursInterval: .5,\n      activeStateEnabled: true,\n      hoverStateEnabled: true,\n      groups: [],\n      showAllDayPanel: true,\n      allDayExpanded: false,\n      onCellClick: null,\n      crossScrollingEnabled: false,\n      dataCellTemplate: null,\n      timeCellTemplate: null,\n      resourceCellTemplate: null,\n      dateCellTemplate: null,\n      allowMultipleCellSelection: true,\n      indicatorTime: new Date(),\n      indicatorUpdateInterval: 5 * toMs(\"minute\"),\n      shadeUntilCurrentTime: true,\n      groupOrientation: \"horizontal\",\n      selectedCellData: [],\n      groupByDate: false,\n      scrolling: {\n        mode: \"standard\"\n      },\n      allDayPanelMode: \"all\",\n      renovateRender: true,\n      height: void 0,\n      draggingMode: \"outlook\",\n      onScrollEnd: () => {},\n      getHeaderHeight: void 0,\n      onRenderAppointments: () => {},\n      onShowAllDayPanel: () => {},\n      onSelectedCellsClick: () => {},\n      timeZoneCalculator: void 0,\n      schedulerHeight: void 0,\n      schedulerWidth: void 0\n    });\n  }\n\n  _optionChanged(args) {\n    switch (args.name) {\n      case \"startDayHour\":\n        validateDayHours(args.value, this.option(\"endDayHour\"));\n\n        this._cleanWorkSpace();\n\n        break;\n\n      case \"endDayHour\":\n        validateDayHours(this.option(\"startDayHour\"), args.value);\n\n        this._cleanWorkSpace();\n\n        break;\n\n      case \"dateCellTemplate\":\n      case \"resourceCellTemplate\":\n      case \"dataCellTemplate\":\n      case \"timeCellTemplate\":\n      case \"hoursInterval\":\n      case \"firstDayOfWeek\":\n      case \"currentDate\":\n      case \"startDate\":\n        this._cleanWorkSpace();\n\n        break;\n\n      case \"groups\":\n        this._cleanView();\n\n        this._removeAllDayElements();\n\n        this._initGrouping();\n\n        this.repaint();\n        break;\n\n      case \"groupOrientation\":\n        this._initGroupedStrategy();\n\n        this._createAllDayPanelElements();\n\n        this._removeAllDayElements();\n\n        this._cleanWorkSpace();\n\n        this._toggleGroupByDateClass();\n\n        break;\n\n      case \"showAllDayPanel\":\n        if (this._isVerticalGroupedWorkSpace()) {\n          this._cleanView();\n\n          this._removeAllDayElements();\n\n          this._initGrouping();\n\n          this.repaint();\n        } else if (!this.isRenovatedRender()) {\n          this._toggleAllDayVisibility(true);\n        } else {\n          this.renderWorkSpace();\n        }\n\n        break;\n\n      case \"allDayExpanded\":\n        this._changeAllDayVisibility();\n\n        this._attachTablesEvents();\n\n        this._updateScrollable();\n\n        break;\n\n      case \"onSelectionChanged\":\n        this._createSelectionChangedAction();\n\n        break;\n\n      case \"onCellClick\":\n        this._createCellClickAction();\n\n        break;\n\n      case \"onCellContextMenu\":\n        this._attachContextMenuEvent();\n\n        break;\n\n      case \"intervalCount\":\n        this._cleanWorkSpace();\n\n        this._toggleWorkSpaceCountClass();\n\n        break;\n\n      case \"groupByDate\":\n        this._cleanWorkSpace();\n\n        this._toggleGroupByDateClass();\n\n        break;\n\n      case \"crossScrollingEnabled\":\n        this._toggleHorizontalScrollClass();\n\n        this._dateTableScrollable.option(this._dateTableScrollableConfig());\n\n        break;\n\n      case \"allDayPanelMode\":\n        this.updateShowAllDayPanel();\n        this.updateAppointments();\n        break;\n\n      case \"width\":\n        super._optionChanged(args);\n\n        this._dimensionChanged();\n\n        break;\n\n      case \"timeZoneCalculator\":\n      case \"allowMultipleCellSelection\":\n      case \"selectedCellData\":\n        break;\n\n      case \"renovateRender\":\n      case \"scrolling\":\n        this.repaint();\n        break;\n\n      case \"schedulerHeight\":\n      case \"schedulerWidth\":\n        this.virtualScrollingDispatcher.updateDimensions(true);\n        break;\n\n      default:\n        super._optionChanged(args);\n\n    }\n  }\n\n  updateShowAllDayPanel() {\n    var isHiddenAllDayPanel = \"hidden\" === this.option(\"allDayPanelMode\");\n    this.option(\"onShowAllDayPanel\")(!isHiddenAllDayPanel);\n  }\n\n  _getVirtualScrollingDispatcherOptions() {\n    return {\n      getCellHeight: this.getCellHeight.bind(this),\n      getCellWidth: this.getCellWidth.bind(this),\n      getCellMinWidth: this.getCellMinWidth.bind(this),\n      isRTL: this._isRTL.bind(this),\n      getSchedulerHeight: () => this.option(\"schedulerHeight\"),\n      getSchedulerWidth: () => this.option(\"schedulerWidth\"),\n      getViewHeight: () => this.$element().height ? this.$element().height() : getHeight(this.$element()),\n      getViewWidth: () => this.$element().width ? this.$element().width() : getWidth(this.$element()),\n      getWindowHeight: () => getWindow().innerHeight,\n      getWindowWidth: () => getWindow().innerWidth,\n      getScrolling: () => this.option(\"scrolling\"),\n      getScrollableOuterWidth: this.getScrollableOuterWidth.bind(this),\n      getScrollable: this.getScrollable.bind(this),\n      createAction: this._createAction.bind(this),\n      updateRender: this.updateRender.bind(this),\n      updateGrid: this.updateGrid.bind(this),\n      getGroupCount: this._getGroupCount.bind(this),\n      isVerticalGrouping: this._isVerticalGroupedWorkSpace.bind(this),\n      getTotalRowCount: this._getTotalRowCount.bind(this),\n      getTotalCellCount: this._getTotalCellCount.bind(this)\n    };\n  }\n\n  _cleanWorkSpace() {\n    this._cleanView();\n\n    this._toggleGroupedClass();\n\n    this._toggleWorkSpaceWithOddCells();\n\n    this.virtualScrollingDispatcher.updateDimensions(true);\n\n    this._renderView();\n\n    this.option(\"crossScrollingEnabled\") && this._setTableSizes();\n    this.cache.clear();\n  }\n\n  _init() {\n    this._headerSemaphore = new ScrollSemaphore();\n    this._sideBarSemaphore = new ScrollSemaphore();\n    this._dataTableSemaphore = new ScrollSemaphore();\n    this._viewDataProvider = null;\n    this._cellsSelectionState = null;\n    this._activeStateUnit = CELL_SELECTOR;\n\n    super._init();\n\n    this._initGrouping();\n\n    this._toggleHorizontalScrollClass();\n\n    this._toggleWorkSpaceCountClass();\n\n    this._toggleGroupByDateClass();\n\n    this._toggleWorkSpaceWithOddCells();\n\n    this.$element().addClass(COMPONENT_CLASS).addClass(this._getElementClass());\n  }\n\n  _initPositionHelper() {\n    this.positionHelper = new PositionHelper({\n      key: this.option(\"key\"),\n      viewDataProvider: this.viewDataProvider,\n      viewStartDayHour: this.option(\"startDayHour\"),\n      viewEndDayHour: this.option(\"endDayHour\"),\n      cellDuration: this.getCellDuration(),\n      groupedStrategy: this._groupedStrategy,\n      isGroupedByDate: this.isGroupedByDate(),\n      rtlEnabled: this.option(\"rtlEnabled\"),\n      startViewDate: this.getStartViewDate(),\n      isVerticalGrouping: this._isVerticalGroupedWorkSpace(),\n      groupCount: this._getGroupCount(),\n      isVirtualScrolling: this.isVirtualScrolling(),\n      getDOMMetaDataCallback: this.getDOMElementsMetaData.bind(this)\n    });\n  }\n\n  _initGrouping() {\n    this._initGroupedStrategy();\n\n    this._toggleGroupingDirectionClass();\n\n    this._toggleGroupByDateClass();\n  }\n\n  isVerticalOrientation() {\n    var orientation = this.option(\"groups\").length ? this.option(\"groupOrientation\") : this._getDefaultGroupStrategy();\n    return \"vertical\" === orientation;\n  }\n\n  _initGroupedStrategy() {\n    var Strategy = this.isVerticalOrientation() ? VerticalGroupedStrategy : HorizontalGroupedStrategy;\n    this._groupedStrategy = new Strategy(this);\n  }\n\n  _getDefaultGroupStrategy() {\n    return \"horizontal\";\n  }\n\n  _toggleHorizontalScrollClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_BOTH_SCROLLS_CLASS, this.option(\"crossScrollingEnabled\"));\n  }\n\n  _toggleGroupByDateClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_GROUP_BY_DATE_CLASS, this.isGroupedByDate());\n  }\n\n  _toggleWorkSpaceCountClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_COUNT_CLASS, this._isWorkSpaceWithCount());\n  }\n\n  _toggleWorkSpaceWithOddCells() {\n    this.$element().toggleClass(WORKSPACE_WITH_ODD_CELLS_CLASS, this._isWorkspaceWithOddCells());\n  }\n\n  _toggleGroupingDirectionClass() {\n    this.$element().toggleClass(VERTICAL_GROUPED_WORKSPACE_CLASS, this._isVerticalGroupedWorkSpace());\n  }\n\n  _getDateTableCellClass(rowIndex, columnIndex) {\n    var cellClass = DATE_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, columnIndex + 1, rowIndex, columnIndex);\n  }\n\n  _getGroupHeaderClass(i) {\n    var cellClass = GROUP_HEADER_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1);\n  }\n\n  _initWorkSpaceUnits() {\n    this._$headerPanelContainer = $(\"<div>\").addClass(\"dx-scheduler-header-panel-container\");\n    this._$headerTablesContainer = $(\"<div>\").addClass(\"dx-scheduler-header-tables-container\");\n    this._$headerPanel = $(\"<table>\");\n    this._$thead = $(\"<thead>\").appendTo(this._$headerPanel);\n    this._$headerPanelEmptyCell = $(\"<div>\").addClass(\"dx-scheduler-header-panel-empty-cell\");\n    this._$allDayTable = $(\"<table>\");\n    this._$fixedContainer = $(\"<div>\").addClass(FIXED_CONTAINER_CLASS);\n    this._$allDayContainer = $(\"<div>\").addClass(ALL_DAY_CONTAINER_CLASS);\n    this._$dateTableScrollableContent = $(\"<div>\").addClass(\"dx-scheduler-date-table-scrollable-content\");\n    this._$sidebarScrollableContent = $(\"<div>\").addClass(\"dx-scheduler-side-bar-scrollable-content\");\n\n    this._initAllDayPanelElements();\n\n    if (this.isRenovatedRender()) {\n      this.createRAllDayPanelElements();\n    } else {\n      this._createAllDayPanelElements();\n    }\n\n    this._$timePanel = $(\"<table>\").addClass(TIME_PANEL_CLASS);\n    this._$dateTable = $(\"<table>\");\n    this._$dateTableContainer = $(\"<div>\").addClass(\"dx-scheduler-date-table-container\");\n    this._$groupTable = $(\"<div>\").addClass(WORKSPACE_VERTICAL_GROUP_TABLE_CLASS);\n  }\n\n  _initAllDayPanelElements() {\n    this._allDayTitles = [];\n    this._allDayTables = [];\n    this._allDayPanels = [];\n  }\n\n  _initDateTableScrollable() {\n    var $dateTableScrollable = $(\"<div>\").addClass(SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS);\n    this._dateTableScrollable = this._createComponent($dateTableScrollable, Scrollable, this._dateTableScrollableConfig());\n  }\n\n  _createWorkSpaceElements() {\n    if (this.option(\"crossScrollingEnabled\")) {\n      this._createWorkSpaceScrollableElements();\n    } else {\n      this._createWorkSpaceStaticElements();\n    }\n  }\n\n  _createWorkSpaceStaticElements() {\n    this._$dateTableContainer.append(this._$dateTable);\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      this._$dateTableContainer.append(this._$allDayContainer);\n\n      this._$dateTableScrollableContent.append(this._$groupTable, this._$timePanel, this._$dateTableContainer);\n\n      this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);\n\n      this._$headerTablesContainer.append(this._$headerPanel);\n    } else {\n      var _this$_$allDayPanel;\n\n      this._$dateTableScrollableContent.append(this._$timePanel, this._$dateTableContainer);\n\n      this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);\n\n      this._$headerTablesContainer.append(this._$headerPanel, this._$allDayPanel);\n\n      null === (_this$_$allDayPanel = this._$allDayPanel) || void 0 === _this$_$allDayPanel ? void 0 : _this$_$allDayPanel.append(this._$allDayContainer, this._$allDayTable);\n    }\n\n    this._appendHeaderPanelEmptyCellIfNecessary();\n\n    this._$headerPanelContainer.append(this._$headerTablesContainer);\n\n    this.$element().append(this._$fixedContainer, this._$headerPanelContainer, this._dateTableScrollable.$element());\n  }\n\n  _createWorkSpaceScrollableElements() {\n    this.$element().append(this._$fixedContainer);\n    this._$flexContainer = $(\"<div>\").addClass(\"dx-scheduler-work-space-flex-container\");\n\n    this._createHeaderScrollable();\n\n    this._headerScrollable.$content().append(this._$headerPanel);\n\n    this._appendHeaderPanelEmptyCellIfNecessary();\n\n    this._$headerPanelContainer.append(this._$headerTablesContainer);\n\n    this.$element().append(this._$headerPanelContainer);\n    this.$element().append(this._$flexContainer);\n\n    this._createSidebarScrollable();\n\n    this._$flexContainer.append(this._dateTableScrollable.$element());\n\n    this._$dateTableContainer.append(this._$dateTable);\n\n    this._$dateTableScrollableContent.append(this._$dateTableContainer);\n\n    this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      this._$dateTableContainer.append(this._$allDayContainer);\n\n      this._$sidebarScrollableContent.append(this._$groupTable, this._$timePanel);\n    } else {\n      var _this$_$allDayPanel2;\n\n      this._headerScrollable.$content().append(this._$allDayPanel);\n\n      null === (_this$_$allDayPanel2 = this._$allDayPanel) || void 0 === _this$_$allDayPanel2 ? void 0 : _this$_$allDayPanel2.append(this._$allDayContainer, this._$allDayTable);\n\n      this._$sidebarScrollableContent.append(this._$timePanel);\n    }\n\n    this._sidebarScrollable.$content().append(this._$sidebarScrollableContent);\n  }\n\n  _appendHeaderPanelEmptyCellIfNecessary() {\n    this._isRenderHeaderPanelEmptyCell() && this._$headerPanelContainer.append(this._$headerPanelEmptyCell);\n  }\n\n  _createHeaderScrollable() {\n    var $headerScrollable = $(\"<div>\").addClass(SCHEDULER_HEADER_SCROLLABLE_CLASS).appendTo(this._$headerTablesContainer);\n    this._headerScrollable = this._createComponent($headerScrollable, Scrollable, this._headerScrollableConfig());\n  }\n\n  _createSidebarScrollable() {\n    var $timePanelScrollable = $(\"<div>\").addClass(SCHEDULER_SIDEBAR_SCROLLABLE_CLASS).appendTo(this._$flexContainer);\n    this._sidebarScrollable = this._createComponent($timePanelScrollable, Scrollable, {\n      useKeyboard: false,\n      showScrollbar: \"never\",\n      direction: \"vertical\",\n      useNative: false,\n      updateManually: true,\n      bounceEnabled: false,\n      onScroll: e => {\n        this._sideBarSemaphore.take(e.scrollOffset);\n\n        if (this._dataTableSemaphore.isFree(e.scrollOffset)) {\n          this._dateTableScrollable.scrollTo({\n            top: e.scrollOffset.top\n          });\n        }\n\n        this._sideBarSemaphore.release();\n      }\n    });\n  }\n\n  _attachTableClasses() {\n    this._addTableClass(this._$dateTable, DATE_TABLE_CLASS);\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      var groupCount = this._getGroupCount();\n\n      for (var i = 0; i < groupCount; i++) {\n        this._addTableClass(this._allDayTables[i], ALL_DAY_TABLE_CLASS);\n      }\n    } else if (!this.isRenovatedRender()) {\n      this._addTableClass(this._$allDayTable, ALL_DAY_TABLE_CLASS);\n    }\n  }\n\n  _attachHeaderTableClasses() {\n    this._addTableClass(this._$headerPanel, HEADER_PANEL_CLASS);\n  }\n\n  _addTableClass($el, className) {\n    $el && !$el.hasClass(className) && $el.addClass(className);\n  }\n\n  _initMarkup() {\n    this.cache.clear();\n\n    this._initWorkSpaceUnits();\n\n    this._initVirtualScrolling();\n\n    this._initDateTableScrollable();\n\n    this._createWorkSpaceElements();\n\n    super._initMarkup();\n\n    if (!this.option(\"crossScrollingEnabled\")) {\n      this._attachTableClasses();\n\n      this._attachHeaderTableClasses();\n    }\n\n    this._toggleGroupedClass();\n\n    this._renderView();\n\n    this._attachEvents();\n  }\n\n  _render() {\n    super._render();\n\n    this._renderDateTimeIndication();\n\n    this._setIndicationUpdateInterval();\n  }\n\n  _toggleGroupedClass() {\n    this.$element().toggleClass(GROUPED_WORKSPACE_CLASS, this._getGroupCount() > 0);\n  }\n\n  _renderView() {\n    if (this.isRenovatedRender()) {\n      if (this._isVerticalGroupedWorkSpace()) {\n        this.renderRGroupPanel();\n      }\n    } else {\n      this._applyCellTemplates(this._renderGroupHeader());\n    }\n\n    this.renderWorkSpace();\n\n    this._updateGroupTableHeight();\n\n    this.updateHeaderEmptyCellWidth();\n    this._shader = new VerticalShader(this);\n  }\n\n  updateCellsSelection() {\n    var renderOptions = this.generateRenderOptions();\n    this.viewDataProvider.updateViewData(renderOptions);\n    this.renderRWorkSpace({\n      timePanel: true,\n      dateTable: true,\n      allDayPanel: true\n    });\n  }\n\n  _renderDateTimeIndication() {\n    return noop();\n  }\n\n  _setIndicationUpdateInterval() {\n    return noop();\n  }\n\n  _refreshDateTimeIndication() {\n    return noop();\n  }\n\n  _detachGroupCountClass() {\n    [...VERTICAL_GROUP_COUNT_CLASSES].forEach(className => {\n      this.$element().removeClass(className);\n    });\n  }\n\n  _attachGroupCountClass() {\n    var className = this._groupedStrategy.getGroupCountClass(this.option(\"groups\"));\n\n    this.$element().addClass(className);\n  }\n\n  _getDateHeaderTemplate() {\n    return this.option(\"dateCellTemplate\");\n  }\n\n  _toggleAllDayVisibility(isUpdateScrollable) {\n    var showAllDayPanel = this._isShowAllDayPanel();\n\n    this.$element().toggleClass(WORKSPACE_WITH_ALL_DAY_CLASS, showAllDayPanel);\n\n    this._changeAllDayVisibility();\n\n    isUpdateScrollable && this._updateScrollable();\n  }\n\n  _changeAllDayVisibility() {\n    this.cache.clear();\n    this.$element().toggleClass(WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS, !this.option(\"allDayExpanded\") && this._isShowAllDayPanel());\n  }\n\n  _getDateTables() {\n    return this._$dateTable.add(this._$allDayTable);\n  }\n\n  _getDateTable() {\n    return this._$dateTable;\n  }\n\n  _removeAllDayElements() {\n    this._$allDayTable && this._$allDayTable.remove();\n    this._$allDayTitle && this._$allDayTitle.remove();\n  }\n\n  _cleanView() {\n    var _this$_shader;\n\n    this.cache.clear();\n\n    this._cleanTableWidths();\n\n    this.cellsSelectionState.clearSelectedAndFocusedCells();\n\n    if (!this.isRenovatedRender()) {\n      var _this$_$allDayTable, _this$_$sidebarTable;\n\n      this._$thead.empty();\n\n      this._$dateTable.empty();\n\n      this._$timePanel.empty();\n\n      this._$groupTable.empty();\n\n      null === (_this$_$allDayTable = this._$allDayTable) || void 0 === _this$_$allDayTable ? void 0 : _this$_$allDayTable.empty();\n      null === (_this$_$sidebarTable = this._$sidebarTable) || void 0 === _this$_$sidebarTable ? void 0 : _this$_$sidebarTable.empty();\n    }\n\n    null === (_this$_shader = this._shader) || void 0 === _this$_shader ? void 0 : _this$_shader.clean();\n    delete this._interval;\n  }\n\n  _clean() {\n    eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n\n    this._disposeRenovatedComponents();\n\n    super._clean();\n  }\n\n  _cleanTableWidths() {\n    this._$headerPanel.css(\"width\", \"\");\n\n    this._$dateTable.css(\"width\", \"\");\n\n    this._$allDayTable && this._$allDayTable.css(\"width\", \"\");\n  }\n\n  _disposeRenovatedComponents() {\n    var _this$renovatedAllDay, _this$renovatedDateTa, _this$renovatedTimePa, _this$renovatedGroupP, _this$renovatedHeader;\n\n    null === (_this$renovatedAllDay = this.renovatedAllDayPanel) || void 0 === _this$renovatedAllDay ? void 0 : _this$renovatedAllDay.dispose();\n    this.renovatedAllDayPanel = void 0;\n    null === (_this$renovatedDateTa = this.renovatedDateTable) || void 0 === _this$renovatedDateTa ? void 0 : _this$renovatedDateTa.dispose();\n    this.renovatedDateTable = void 0;\n    null === (_this$renovatedTimePa = this.renovatedTimePanel) || void 0 === _this$renovatedTimePa ? void 0 : _this$renovatedTimePa.dispose();\n    this.renovatedTimePanel = void 0;\n    null === (_this$renovatedGroupP = this.renovatedGroupPanel) || void 0 === _this$renovatedGroupP ? void 0 : _this$renovatedGroupP.dispose();\n    this.renovatedGroupPanel = void 0;\n    null === (_this$renovatedHeader = this.renovatedHeaderPanel) || void 0 === _this$renovatedHeader ? void 0 : _this$renovatedHeader.dispose();\n    this.renovatedHeaderPanel = void 0;\n  }\n\n  getGroupedStrategy() {\n    return this._groupedStrategy;\n  }\n\n  getFixedContainer() {\n    return this._$fixedContainer;\n  }\n\n  getAllDayContainer() {\n    return this._$allDayContainer;\n  }\n\n  updateRender() {\n    this.renderer.updateRender();\n  }\n\n  updateGrid() {\n    this.renderer._renderGrid();\n  }\n\n  updateAppointments() {\n    var _this$dragBehavior2;\n\n    this.option(\"onRenderAppointments\")();\n    null === (_this$dragBehavior2 = this.dragBehavior) || void 0 === _this$dragBehavior2 ? void 0 : _this$dragBehavior2.updateDragSource();\n  }\n\n  _createAllDayPanelElements() {\n    var groupCount = this._getGroupCount();\n\n    if (this._isVerticalGroupedWorkSpace() && 0 !== groupCount) {\n      for (var i = 0; i < groupCount; i++) {\n        var $allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\"));\n\n        this._allDayTitles.push($allDayTitle);\n\n        this._$allDayTable = $(\"<table>\");\n\n        this._allDayTables.push(this._$allDayTable);\n\n        this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n\n        this._allDayPanels.push(this._$allDayPanel);\n      }\n    } else {\n      this._$allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\")).appendTo(this.$element());\n      this._$allDayTable = $(\"<table>\");\n      this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n    }\n  }\n\n  renderWorkSpace() {\n    var isGenerateNewViewData = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;\n    this.cache.clear();\n    this.viewDataProvider.update(this.generateRenderOptions(), isGenerateNewViewData);\n\n    if (this.isRenovatedRender()) {\n      this.renderRWorkSpace();\n      this.virtualScrollingDispatcher.updateDimensions();\n    } else {\n      this._renderDateHeader();\n\n      this._renderTimePanel();\n\n      this._renderGroupAllDayPanel();\n\n      this._renderDateTable();\n\n      this._renderAllDayPanel();\n    }\n\n    this._initPositionHelper();\n  }\n\n  _renderGroupHeader() {\n    var $container = this._getGroupHeaderContainer();\n\n    var groupCount = this._getGroupCount();\n\n    var cellTemplates = [];\n\n    if (groupCount) {\n      var groupRows = this._makeGroupRows(this.option(\"groups\"), this.option(\"groupByDate\"));\n\n      this._attachGroupCountClass();\n\n      $container.append(groupRows.elements);\n      cellTemplates = groupRows.cellTemplates;\n    } else {\n      this._detachGroupCountClass();\n    }\n\n    return cellTemplates;\n  }\n\n  _applyCellTemplates(templates) {\n    null === templates || void 0 === templates ? void 0 : templates.forEach(function (template) {\n      template();\n    });\n  }\n\n  _makeGroupRows(groups, groupByDate) {\n    var tableCreatorStrategy = this._isVerticalGroupedWorkSpace() ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;\n    return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {\n      groupHeaderRowClass: GROUP_ROW_CLASS,\n      groupRowClass: GROUP_ROW_CLASS,\n      groupHeaderClass: this._getGroupHeaderClass.bind(this),\n      groupHeaderContentClass: GROUP_HEADER_CONTENT_CLASS\n    }, this._getCellCount() || 1, this.option(\"resourceCellTemplate\"), this._getGroupCount(), groupByDate);\n  }\n\n  _renderDateHeader() {\n    var container = this._getDateHeaderContainer();\n\n    var $headerRow = $(\"<tr>\").addClass(HEADER_ROW_CLASS);\n\n    var count = this._getCellCount();\n\n    var cellTemplate = this._getDateHeaderTemplate();\n\n    var repeatCount = this._getCalculateHeaderCellRepeatCount();\n\n    var templateCallbacks = [];\n    var groupByDate = this.isGroupedByDate();\n\n    if (!groupByDate) {\n      for (var rowIndex = 0; rowIndex < repeatCount; rowIndex++) {\n        for (var columnIndex = 0; columnIndex < count; columnIndex++) {\n          var templateIndex = rowIndex * count + columnIndex;\n\n          this._renderDateHeaderTemplate($headerRow, columnIndex, templateIndex, cellTemplate, templateCallbacks);\n        }\n      }\n\n      container.append($headerRow);\n    } else {\n      var colSpan = groupByDate ? this._getGroupCount() : 1;\n\n      for (var _columnIndex = 0; _columnIndex < count; _columnIndex++) {\n        var _templateIndex = _columnIndex * repeatCount;\n\n        var cellElement = this._renderDateHeaderTemplate($headerRow, _columnIndex, _templateIndex, cellTemplate, templateCallbacks);\n\n        cellElement.attr(\"colSpan\", colSpan);\n      }\n\n      container.prepend($headerRow);\n    }\n\n    this._applyCellTemplates(templateCallbacks);\n\n    return $headerRow;\n  }\n\n  _renderDateHeaderTemplate(container, panelCellIndex, templateIndex, cellTemplate, templateCallbacks) {\n    var validTemplateIndex = this.isGroupedByDate() ? Math.floor(templateIndex / this._getGroupCount()) : templateIndex;\n    var completeDateHeaderMap = this.viewDataProvider.completeDateHeaderMap;\n    var {\n      text: text,\n      startDate: date\n    } = completeDateHeaderMap[completeDateHeaderMap.length - 1][validTemplateIndex];\n    var $cell = $(\"<th>\").addClass(this._getHeaderPanelCellClass(panelCellIndex)).attr(\"title\", text);\n\n    if (null !== cellTemplate && void 0 !== cellTemplate && cellTemplate.render) {\n      templateCallbacks.push(cellTemplate.render.bind(cellTemplate, {\n        model: _extends({\n          text: text,\n          date: date\n        }, this._getGroupsForDateHeaderTemplate(templateIndex)),\n        index: templateIndex,\n        container: getPublicElement($cell)\n      }));\n    } else {\n      $cell.text(text);\n    }\n\n    container.append($cell);\n    return $cell;\n  }\n\n  _getGroupsForDateHeaderTemplate(templateIndex) {\n    var indexMultiplier = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n    var groupIndex;\n    var groups;\n\n    if (this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate()) {\n      groupIndex = this._getGroupIndex(0, templateIndex * indexMultiplier);\n      var groupsArray = getCellGroups(groupIndex, this.option(\"groups\"));\n      groups = getGroupsObjectFromGroupsArray(groupsArray);\n    }\n\n    return {\n      groups: groups,\n      groupIndex: groupIndex\n    };\n  }\n\n  _getHeaderPanelCellClass(i) {\n    var cellClass = HEADER_PANEL_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1, void 0, void 0, this.isGroupedByDate());\n  }\n\n  _renderAllDayPanel(index) {\n    var cellCount = this._getCellCount();\n\n    if (!this._isVerticalGroupedWorkSpace()) {\n      cellCount *= this._getGroupCount() || 1;\n    }\n\n    var cellTemplates = this._renderTableBody({\n      container: this._allDayPanels.length ? getPublicElement(this._allDayTables[index]) : getPublicElement(this._$allDayTable),\n      rowCount: 1,\n      cellCount: cellCount,\n      cellClass: this._getAllDayPanelCellClass.bind(this),\n      rowClass: ALL_DAY_TABLE_ROW_CLASS,\n      cellTemplate: this.option(\"dataCellTemplate\"),\n      getCellData: this._oldRender_getAllDayCellData(index),\n      groupIndex: index\n    }, true);\n\n    this._toggleAllDayVisibility(true);\n\n    this._applyCellTemplates(cellTemplates);\n  }\n\n  _renderGroupAllDayPanel() {\n    if (this._isVerticalGroupedWorkSpace()) {\n      var groupCount = this._getGroupCount();\n\n      for (var i = 0; i < groupCount; i++) {\n        this._renderAllDayPanel(i);\n      }\n    }\n  }\n\n  _getAllDayPanelCellClass(i, j) {\n    var cellClass = ALL_DAY_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1);\n  }\n\n  _renderTimePanel() {\n    var repeatCount = this._groupedStrategy.calculateTimeCellRepeatCount();\n\n    var getData = (rowIndex, field) => {\n      var allDayPanelsCount = 0;\n\n      if (this.isAllDayPanelVisible) {\n        allDayPanelsCount = 1;\n      }\n\n      if (this.isGroupedAllDayPanel()) {\n        allDayPanelsCount = Math.ceil((rowIndex + 1) / this._getRowCount());\n      }\n\n      var validRowIndex = rowIndex + allDayPanelsCount;\n      return this.viewDataProvider.completeTimePanelMap[validRowIndex][field];\n    };\n\n    this._renderTableBody({\n      container: getPublicElement(this._$timePanel),\n      rowCount: this._getTimePanelRowCount() * repeatCount,\n      cellCount: 1,\n      cellClass: this._getTimeCellClass.bind(this),\n      rowClass: TIME_PANEL_ROW_CLASS,\n      cellTemplate: this.option(\"timeCellTemplate\"),\n      getCellText: rowIndex => getData(rowIndex, \"text\"),\n      getCellDate: rowIndex => getData(rowIndex, \"startDate\"),\n      groupCount: this._getGroupCount(),\n      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayTitles : void 0,\n      getTemplateData: (rowIndex => {\n        if (!this._isVerticalGroupedWorkSpace()) {\n          return {};\n        }\n\n        var groupIndex = this._getGroupIndex(rowIndex, 0);\n\n        var groupsArray = getCellGroups(groupIndex, this.option(\"groups\"));\n        var groups = getGroupsObjectFromGroupsArray(groupsArray);\n        return {\n          groupIndex: groupIndex,\n          groups: groups\n        };\n      }).bind(this)\n    });\n  }\n\n  _getTimeCellClass(i) {\n    var cellClass = TIME_PANEL_CELL_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n    return this._isVerticalGroupedWorkSpace() ? this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i, i) : cellClass;\n  }\n\n  _renderDateTable() {\n    var groupCount = this._getGroupCount();\n\n    this._renderTableBody({\n      container: getPublicElement(this._$dateTable),\n      rowCount: this._getTotalRowCount(groupCount),\n      cellCount: this._getTotalCellCount(groupCount),\n      cellClass: this._getDateTableCellClass.bind(this),\n      rowClass: DATE_TABLE_ROW_CLASS,\n      cellTemplate: this.option(\"dataCellTemplate\"),\n      getCellData: (_, rowIndex, columnIndex) => {\n        var isGroupedAllDayPanel = this.isGroupedAllDayPanel();\n        var validRowIndex = rowIndex;\n\n        if (isGroupedAllDayPanel) {\n          var rowCount = this._getRowCount();\n\n          var allDayPanelsCount = Math.ceil(rowIndex / rowCount);\n          validRowIndex += allDayPanelsCount;\n        }\n\n        var cellData = this.viewDataProvider.viewDataMap.dateTableMap[validRowIndex][columnIndex].cellData;\n        return {\n          value: this._filterCellDataFields(cellData),\n          fullValue: cellData,\n          key: CELL_DATA\n        };\n      },\n      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayPanels : void 0,\n      groupCount: groupCount,\n      groupByDate: this.option(\"groupByDate\")\n    });\n  }\n\n  _insertAllDayRowsIntoDateTable() {\n    return this._groupedStrategy.insertAllDayRowsIntoDateTable();\n  }\n\n  _renderTableBody(options, delayCellTemplateRendering) {\n    var result = [];\n\n    if (!delayCellTemplateRendering) {\n      this._applyCellTemplates(tableCreator.makeTable(options));\n    } else {\n      result = tableCreator.makeTable(options);\n    }\n\n    return result;\n  }\n\n}\n\nvar createDragBehaviorConfig = (container, isDefaultDraggingMode, dragBehavior, enableDefaultDragging, disableDefaultDragging, getDroppableCell, getDateTables, removeDroppableCellClass, getCellWidth, options) => {\n  var state = {\n    dragElement: void 0,\n    itemData: void 0\n  };\n\n  var isItemDisabled = () => {\n    var {\n      itemData: itemData\n    } = state;\n\n    if (itemData) {\n      var getter = compileGetter(\"disabled\");\n      return getter(itemData);\n    }\n\n    return true;\n  };\n\n  var cursorOffset = options.isSetCursorOffset ? () => {\n    var $dragElement = $(state.dragElement);\n    return {\n      x: getWidth($dragElement) / 2,\n      y: getHeight($dragElement) / 2\n    };\n  } : void 0;\n  return {\n    container: container,\n    dragTemplate: () => state.dragElement,\n    onDragStart: e => {\n      if (!isDefaultDraggingMode) {\n        disableDefaultDragging();\n      }\n\n      var canceled = e.cancel;\n      var event = e.event;\n      var $itemElement = $(e.itemElement);\n      var appointments = e.component._appointments;\n      state.itemData = options.getItemData(e.itemElement, appointments);\n      var settings = options.getItemSettings($itemElement, e);\n      var initialPosition = options.initialPosition;\n\n      if (!isItemDisabled()) {\n        event.data = event.data || {};\n\n        if (!canceled) {\n          if (!settings.isCompact) {\n            dragBehavior.updateDragSource(state.itemData, settings);\n          }\n\n          state.dragElement = ((itemData, settings, appointments) => {\n            var appointmentIndex = appointments.option(\"items\").length;\n            settings.isCompact = false;\n            settings.virtual = false;\n\n            var items = appointments._renderItem(appointmentIndex, {\n              itemData: itemData,\n              settings: [settings]\n            });\n\n            return items[0];\n          })(state.itemData, settings, appointments);\n\n          event.data.itemElement = state.dragElement;\n          event.data.initialPosition = null !== initialPosition && void 0 !== initialPosition ? initialPosition : locate($(state.dragElement));\n          event.data.itemData = state.itemData;\n          event.data.itemSettings = settings;\n          dragBehavior.onDragStart(event.data);\n          resetPosition($(state.dragElement));\n        }\n      }\n    },\n    onDragMove: () => {\n      if (isDefaultDraggingMode) {\n        return;\n      }\n\n      var appointmentWidth = getWidth(state.dragElement);\n      var cellWidth = getCellWidth();\n      var isWideAppointment = appointmentWidth > cellWidth;\n      var dragElementContainer = $(state.dragElement).parent();\n      var boundingRect = getBoundingRect(dragElementContainer.get(0));\n      var newX = boundingRect.left + 10;\n      var newY = boundingRect.top + 10;\n      var elements = isWideAppointment ? domAdapter.elementsFromPoint(newX, newY) : domAdapter.elementsFromPoint(newX + appointmentWidth / 2, newY);\n      var dateTables = getDateTables();\n      var droppableCell = elements.find(el => {\n        var classList = el.classList;\n        var isCurrentSchedulerElement = 1 === dateTables.find(el).length;\n        return isCurrentSchedulerElement && (classList.contains(DATE_TABLE_CELL_CLASS) || classList.contains(ALL_DAY_TABLE_CELL_CLASS));\n      });\n\n      if (droppableCell) {\n        var oldDroppableCell = getDroppableCell();\n\n        if (!oldDroppableCell.is(droppableCell)) {\n          removeDroppableCellClass();\n        }\n\n        $(droppableCell).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n      }\n    },\n    onDragEnd: e => {\n      var _state$dragElement;\n\n      if (!isDefaultDraggingMode) {\n        enableDefaultDragging();\n      }\n\n      if (!isItemDisabled()) {\n        dragBehavior.onDragEnd(e);\n      }\n\n      null === (_state$dragElement = state.dragElement) || void 0 === _state$dragElement ? void 0 : _state$dragElement.remove();\n      removeDroppableCellClass();\n    },\n    cursorOffset: cursorOffset,\n    filter: options.filter\n  };\n};\n\nexport default SchedulerWorkSpace;","map":null,"metadata":{},"sourceType":"module"}