{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/file_manager/file_items_controller.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport FileSystemProviderBase from \"../../file_management/provider_base\";\nimport FileSystemItem from \"../../file_management/file_system_item\";\nimport ObjectFileSystemProvider from \"../../file_management/object_provider\";\nimport RemoteFileSystemProvider from \"../../file_management/remote_provider\";\nimport CustomFileSystemProvider from \"../../file_management/custom_provider\";\nimport FileSystemError from \"../../file_management/error\";\nimport ErrorCode from \"../../file_management/error_codes\";\nimport { pathCombine, getEscapedFileName, getPathParts, getFileExtension } from \"../../file_management/utils\";\nimport { whenSome } from \"./ui.file_manager.common\";\nimport { Deferred, when } from \"../../core/utils/deferred\";\nimport { extend } from \"../../core/utils/extend\";\nimport { equalByValue } from \"../../core/utils/common\";\nimport { isDefined, isObject, isPromise } from \"../../core/utils/type\";\nimport Guid from \"../../core/guid\";\nvar DEFAULT_ROOT_FILE_SYSTEM_ITEM_NAME = \"Files\";\nexport default class FileItemsController {\n  constructor(options) {\n    options = options || {};\n    this._options = extend({}, options);\n    this._isInitialized = false;\n    this._dataLoading = false;\n    this._dataLoadingDeferred = null;\n    this._rootDirectoryInfo = this._createRootDirectoryInfo(options.rootText);\n    this._currentDirectoryInfo = this._rootDirectoryInfo;\n    this._defaultIconMap = this._createDefaultIconMap();\n    this.startSingleLoad();\n\n    this._setSecurityController();\n\n    this._setProvider(options.fileProvider);\n\n    this._initialize();\n  }\n\n  _initialize() {\n    var result = this._options.currentPathKeys && this._options.currentPathKeys.length ? this.setCurrentPathByKeys(this._options.currentPathKeys) : this.setCurrentPath(this._options.currentPath);\n\n    var completeInitialization = () => {\n      this._isInitialized = true;\n\n      this._raiseInitialized();\n    };\n\n    if (result) {\n      when(result).always(completeInitialization);\n    } else {\n      completeInitialization();\n    }\n  }\n\n  _setSecurityController() {\n    this._securityController = new FileSecurityController({\n      allowedFileExtensions: this._options.allowedFileExtensions,\n      maxFileSize: this._options.uploadMaxFileSize\n    });\n\n    this._resetState();\n  }\n\n  setAllowedFileExtensions(allowedFileExtensions) {\n    if (isDefined(allowedFileExtensions)) {\n      this._options.allowedFileExtensions = allowedFileExtensions;\n    }\n\n    this._setSecurityController();\n\n    this.refresh();\n  }\n\n  setUploadOptions(_ref) {\n    var {\n      maxFileSize: maxFileSize,\n      chunkSize: chunkSize\n    } = _ref;\n\n    if (isDefined(chunkSize)) {\n      this._options.uploadChunkSize = chunkSize;\n    }\n\n    if (isDefined(maxFileSize)) {\n      this._options.uploadMaxFileSize = maxFileSize;\n\n      this._setSecurityController();\n\n      this.refresh();\n    }\n  }\n\n  _setProvider(fileProvider) {\n    this._fileProvider = this._createFileProvider(fileProvider);\n\n    this._resetState();\n  }\n\n  updateProvider(fileProvider, currentPathKeys) {\n    if (!isDefined(currentPathKeys)) {\n      return this._updateProviderOnly(fileProvider);\n    }\n\n    return when(this._getDirectoryByPathParts(this._rootDirectoryInfo, currentPathKeys, true)).then(newDirectory => {\n      if (newDirectory !== this._rootDirectoryInfo) {\n        this._resetCurrentDirectory();\n      }\n\n      this._setProvider(fileProvider);\n    }).then(() => this.setCurrentPathByKeys(currentPathKeys));\n  }\n\n  _updateProviderOnly(fileProvider) {\n    this._resetCurrentDirectory();\n\n    this._setProvider(fileProvider);\n\n    return when(this.refresh());\n  }\n\n  _createFileProvider(fileProvider) {\n    if (!fileProvider) {\n      fileProvider = [];\n    }\n\n    if (Array.isArray(fileProvider)) {\n      return new ObjectFileSystemProvider({\n        data: fileProvider\n      });\n    }\n\n    if (fileProvider instanceof FileSystemProviderBase) {\n      return fileProvider;\n    }\n\n    switch (fileProvider.type) {\n      case \"remote\":\n        return new RemoteFileSystemProvider(fileProvider);\n\n      case \"custom\":\n        return new CustomFileSystemProvider(fileProvider);\n    }\n\n    return new ObjectFileSystemProvider(fileProvider);\n  }\n\n  setCurrentPath(path) {\n    var pathParts = getPathParts(path);\n    var rawPath = pathCombine(...pathParts);\n\n    if (this.getCurrentDirectory().fileItem.relativeName === rawPath) {\n      return new Deferred().resolve().promise();\n    }\n\n    return this._setCurrentDirectoryByPathParts(pathParts);\n  }\n\n  setCurrentPathByKeys(pathKeys) {\n    if (equalByValue(this.getCurrentDirectory().fileItem.pathKeys, pathKeys, 0, true)) {\n      return new Deferred().resolve().promise();\n    }\n\n    return this._setCurrentDirectoryByPathParts(pathKeys, true);\n  }\n\n  getCurrentPath() {\n    var currentPath = \"\";\n    var directory = this.getCurrentDirectory();\n\n    while (directory && !directory.fileItem.isRoot()) {\n      var escapedName = getEscapedFileName(directory.fileItem.name);\n      currentPath = pathCombine(escapedName, currentPath);\n      directory = directory.parentDirectory;\n    }\n\n    return currentPath;\n  }\n\n  getCurrentPathKeys() {\n    return this.getCurrentDirectory().fileItem.pathKeys;\n  }\n\n  getCurrentDirectory() {\n    return this._currentDirectoryInfo;\n  }\n\n  setCurrentDirectory(directoryInfo, checkActuality) {\n    if (!directoryInfo) {\n      return;\n    }\n\n    if (checkActuality) {\n      directoryInfo = this._getActualDirectoryInfo(directoryInfo);\n    }\n\n    if (this._currentDirectoryInfo && this._currentDirectoryInfo === directoryInfo) {\n      this._raisePathPotentiallyChanged();\n\n      return;\n    }\n\n    var requireRaiseSelectedDirectory = this._currentDirectoryInfo.fileItem.key !== directoryInfo.fileItem.key;\n    this._currentDirectoryInfo = directoryInfo;\n\n    if (requireRaiseSelectedDirectory && this._isInitialized) {\n      if (!this._dataLoading) {\n        this._raiseDataLoading(\"navigation\");\n      }\n\n      this._raiseSelectedDirectoryChanged(directoryInfo);\n    }\n  }\n\n  _resetCurrentDirectory() {\n    this._currentDirectoryInfo = this._rootDirectoryInfo;\n  }\n\n  getCurrentItems(onlyFiles) {\n    return this._dataLoadingDeferred ? this._dataLoadingDeferred.then(() => this._getCurrentItemsInternal(onlyFiles)) : this._getCurrentItemsInternal(onlyFiles);\n  }\n\n  _getCurrentItemsInternal(onlyFiles) {\n    var currentDirectory = this.getCurrentDirectory();\n    var getItemsPromise = this.getDirectoryContents(currentDirectory);\n    return getItemsPromise.then(items => {\n      var separatedItems = this._separateItemsByType(items);\n\n      currentDirectory.fileItem.hasSubDirectories = !!separatedItems.folders.length;\n      return onlyFiles ? separatedItems.files : items;\n    });\n  }\n\n  getDirectories(parentDirectoryInfo, skipNavigationOnError) {\n    return this.getDirectoryContents(parentDirectoryInfo, skipNavigationOnError).then(itemInfos => itemInfos.filter(info => info.fileItem.isDirectory));\n  }\n\n  _separateItemsByType(itemInfos) {\n    var folders = [];\n    var files = [];\n    itemInfos.forEach(info => info.fileItem.isDirectory ? folders.push(info) : files.push(info));\n    return {\n      folders: folders,\n      files: files\n    };\n  }\n\n  getDirectoryContents(parentDirectoryInfo, skipNavigationOnError) {\n    if (!parentDirectoryInfo) {\n      return new Deferred().resolve([this._rootDirectoryInfo]).promise();\n    }\n\n    if (parentDirectoryInfo.itemsLoaded) {\n      return new Deferred().resolve(parentDirectoryInfo.items).promise();\n    }\n\n    if (this._singleOperationLockId && parentDirectoryInfo.itemsSingleLoadErrorId === this._singleOperationLockId) {\n      this._changeDirectoryOnError(parentDirectoryInfo, skipNavigationOnError, true);\n\n      return new Deferred().reject().promise();\n    }\n\n    var dirKey = parentDirectoryInfo.getInternalKey();\n    var loadItemsDeferred = this._loadedItems[dirKey];\n\n    if (loadItemsDeferred) {\n      return loadItemsDeferred;\n    }\n\n    loadItemsDeferred = this._getFileItems(parentDirectoryInfo, skipNavigationOnError).then(fileItems => {\n      fileItems = fileItems || [];\n      parentDirectoryInfo.items = fileItems.map(fileItem => fileItem.isDirectory && this._createDirectoryInfo(fileItem, parentDirectoryInfo) || this._createFileInfo(fileItem, parentDirectoryInfo));\n      parentDirectoryInfo.itemsLoaded = true;\n      return parentDirectoryInfo.items;\n    }, () => {\n      if (this._singleOperationLockId && parentDirectoryInfo.itemsSingleLoadErrorId !== this._singleOperationLockId) {\n        parentDirectoryInfo.itemsSingleLoadErrorId = this._singleOperationLockId;\n      }\n\n      return [];\n    });\n    this._loadedItems[dirKey] = loadItemsDeferred;\n    loadItemsDeferred.always(() => {\n      delete this._loadedItems[dirKey];\n    });\n    return loadItemsDeferred;\n  }\n\n  _getFileItems(parentDirectoryInfo, skipNavigationOnError) {\n    var loadItemsDeferred = null;\n\n    try {\n      loadItemsDeferred = this._fileProvider.getItems(parentDirectoryInfo.fileItem);\n    } catch (error) {\n      return this._handleItemLoadError(parentDirectoryInfo, error, skipNavigationOnError);\n    }\n\n    return when(loadItemsDeferred).then(fileItems => this._securityController.getAllowedItems(fileItems), errorInfo => this._handleItemLoadError(parentDirectoryInfo, errorInfo, skipNavigationOnError));\n  }\n\n  createDirectory(parentDirectoryInfo, name) {\n    var parentDirItem = parentDirectoryInfo.fileItem;\n\n    var tempDirInfo = this._createDirInfoByName(name, parentDirectoryInfo);\n\n    var actionInfo = this._createEditActionInfo(\"create\", tempDirInfo, parentDirectoryInfo);\n\n    return this._processEditAction(actionInfo, args => {\n      args.parentDirectory = parentDirItem;\n      args.name = name;\n\n      this._editingEvents.onDirectoryCreating(args);\n    }, () => this._fileProvider.createDirectory(parentDirItem, name).done(info => {\n      if (!parentDirItem.isRoot()) {\n        parentDirItem.hasSubDirectories = true;\n      }\n\n      return info;\n    }), () => {\n      var args = {\n        parentDirectory: parentDirItem,\n        name: name\n      };\n\n      this._editingEvents.onDirectoryCreated(args);\n    }, () => this._resetDirectoryState(parentDirectoryInfo, true));\n  }\n\n  renameItem(fileItemInfo, name) {\n    var sourceItem = fileItemInfo.fileItem.createClone();\n\n    var actionInfo = this._createEditActionInfo(\"rename\", fileItemInfo, fileItemInfo.parentDirectory, {\n      itemNewName: name\n    });\n\n    return this._processEditAction(actionInfo, (args, itemInfo) => {\n      if (!itemInfo.fileItem.isDirectory) {\n        this._securityController.validateExtension(name);\n      }\n\n      args.item = sourceItem;\n      args.newName = name;\n\n      this._editingEvents.onItemRenaming(args);\n    }, item => this._fileProvider.renameItem(item, name), () => {\n      var args = {\n        sourceItem: sourceItem,\n        itemName: name\n      };\n\n      this._editingEvents.onItemRenamed(args);\n    }, () => {\n      var parentDirectory = this._getActualDirectoryInfo(fileItemInfo.parentDirectory);\n\n      this._resetDirectoryState(parentDirectory);\n\n      this.setCurrentDirectory(parentDirectory);\n    });\n  }\n\n  moveItems(itemInfos, destinationDirectory) {\n    var actionInfo = this._createEditActionInfo(\"move\", itemInfos, destinationDirectory);\n\n    return this._processEditAction(actionInfo, (args, itemInfo) => {\n      args.item = itemInfo.fileItem;\n      args.destinationDirectory = destinationDirectory.fileItem;\n\n      this._editingEvents.onItemMoving(args);\n    }, item => this._fileProvider.moveItems([item], destinationDirectory.fileItem), itemInfo => {\n      var args = {\n        sourceItem: itemInfo.fileItem,\n        parentDirectory: destinationDirectory.fileItem,\n        itemName: itemInfo.fileItem.name,\n        itemPath: pathCombine(destinationDirectory.fileItem.path, itemInfo.fileItem.name)\n      };\n\n      this._editingEvents.onItemMoved(args);\n    }, needChangeCurrentDirectory => {\n      if (needChangeCurrentDirectory) {\n        destinationDirectory = this._getActualDirectoryInfo(destinationDirectory);\n\n        this._resetDirectoryState(destinationDirectory);\n\n        this.setCurrentDirectory(destinationDirectory);\n        destinationDirectory.expanded = true;\n      }\n\n      itemInfos.forEach(itemInfo => this._resetDirectoryState(itemInfo.parentDirectory, true));\n    });\n  }\n\n  copyItems(itemInfos, destinationDirectory) {\n    var actionInfo = this._createEditActionInfo(\"copy\", itemInfos, destinationDirectory);\n\n    return this._processEditAction(actionInfo, (args, itemInfo) => {\n      args.item = itemInfo.fileItem;\n      args.destinationDirectory = destinationDirectory.fileItem;\n\n      this._editingEvents.onItemCopying(args);\n    }, item => this._fileProvider.copyItems([item], destinationDirectory.fileItem), itemInfo => {\n      var args = {\n        sourceItem: itemInfo.fileItem,\n        parentDirectory: destinationDirectory.fileItem,\n        itemName: itemInfo.fileItem.name,\n        itemPath: pathCombine(destinationDirectory.fileItem.path, itemInfo.fileItem.name)\n      };\n\n      this._editingEvents.onItemCopied(args);\n    }, needChangeCurrentDirectory => {\n      if (needChangeCurrentDirectory) {\n        destinationDirectory = this._getActualDirectoryInfo(destinationDirectory);\n\n        this._resetDirectoryState(destinationDirectory);\n\n        this.setCurrentDirectory(destinationDirectory);\n        destinationDirectory.expanded = true;\n      }\n    });\n  }\n\n  deleteItems(itemInfos) {\n    var directory = itemInfos.length > 0 ? itemInfos[0].parentDirectory : null;\n\n    var actionInfo = this._createEditActionInfo(\"delete\", itemInfos, directory);\n\n    return this._processEditAction(actionInfo, (args, itemInfo) => {\n      args.item = itemInfo.fileItem;\n\n      this._editingEvents.onItemDeleting(args);\n    }, item => this._fileProvider.deleteItems([item]), itemInfo => this._editingEvents.onItemDeleted({\n      item: itemInfo.fileItem\n    }), () => {\n      itemInfos.forEach(itemInfo => {\n        var parentDir = this._getActualDirectoryInfo(itemInfo.parentDirectory);\n\n        this._resetDirectoryState(parentDir);\n\n        this.setCurrentDirectory(parentDir);\n      });\n    });\n  }\n\n  processUploadSession(sessionInfo, uploadDirectoryInfo) {\n    var itemInfos = this._getItemInfosForUploaderFiles(sessionInfo.files, uploadDirectoryInfo);\n\n    var actionInfo = this._createEditActionInfo(\"upload\", itemInfos, uploadDirectoryInfo, {\n      sessionInfo: sessionInfo\n    });\n\n    return this._processEditAction(actionInfo, () => {}, (_, index) => sessionInfo.deferreds[index], () => {}, () => this._resetDirectoryState(uploadDirectoryInfo, true));\n  }\n\n  uploadFileChunk(fileData, chunksInfo, destinationDirectory) {\n    var startDeferred = null;\n\n    if (0 === chunksInfo.chunkIndex) {\n      this._securityController.validateMaxFileSize(fileData.size);\n\n      this._securityController.validateExtension(fileData.name);\n\n      startDeferred = this._processBeforeItemEditAction(args => {\n        args.fileData = fileData;\n        args.destinationDirectory = destinationDirectory;\n\n        this._editingEvents.onFileUploading(args);\n      });\n    } else {\n      startDeferred = new Deferred().resolve().promise();\n    }\n\n    var result = startDeferred.then(() => this._fileProvider.uploadFileChunk(fileData, chunksInfo, destinationDirectory));\n\n    if (chunksInfo.chunkIndex === chunksInfo.chunkCount - 1) {\n      result = result.done(() => {\n        var args = {\n          fileData: fileData,\n          parentDirectory: destinationDirectory\n        };\n\n        this._editingEvents.onFileUploaded(args);\n      });\n    }\n\n    return result;\n  }\n\n  abortFileUpload(fileData, chunksInfo, destinationDirectory) {\n    return when(this._fileProvider.abortFileUpload(fileData, chunksInfo, destinationDirectory));\n  }\n\n  getFileUploadChunkSize() {\n    var chunkSize = this._options.uploadChunkSize;\n\n    if (chunkSize && chunkSize > 0) {\n      return chunkSize;\n    }\n\n    return this._fileProvider.getFileUploadChunkSize();\n  }\n\n  downloadItems(itemInfos) {\n    var deferreds = itemInfos.map(itemInfo => this._processBeforeItemEditAction(args => {\n      args.item = itemInfo.fileItem;\n\n      this._editingEvents.onItemDownloading(args);\n    }, itemInfo));\n    return when(...deferreds).then(() => {\n      var items = itemInfos.map(i => i.fileItem);\n      return when(this._getItemActionResult(this._fileProvider.downloadItems(items))).then(() => {}, errorInfo => {\n        this._raiseDownloadItemsError(itemInfos, itemInfos[0].parentDirectory, errorInfo);\n      });\n    }, errorInfo => {\n      this._raiseDownloadItemsError(itemInfos, itemInfos[0].parentDirectory, errorInfo);\n    });\n  }\n\n  getItemContent(itemInfos) {\n    var items = itemInfos.map(i => i.fileItem);\n    return when(this._fileProvider.getItemsContent(items));\n  }\n\n  _handleItemLoadError(parentDirectoryInfo, errorInfo, skipNavigationOnError) {\n    parentDirectoryInfo = this._getActualDirectoryInfo(parentDirectoryInfo);\n\n    this._raiseGetItemsError(parentDirectoryInfo, errorInfo);\n\n    this._changeDirectoryOnError(parentDirectoryInfo, skipNavigationOnError);\n\n    return new Deferred().reject().promise();\n  }\n\n  _raiseGetItemsError(parentDirectoryInfo, errorInfo) {\n    var actionInfo = this._createEditActionInfo(\"getItems\", parentDirectoryInfo, parentDirectoryInfo);\n\n    this._raiseEditActionStarting(actionInfo);\n\n    this._raiseEditActionResultAcquired(actionInfo);\n\n    this._raiseEditActionError(actionInfo, {\n      errorCode: errorInfo.errorCode,\n      errorText: errorInfo.errorText,\n      fileItem: parentDirectoryInfo.fileItem,\n      index: 0\n    });\n  }\n\n  _raiseDownloadItemsError(targetFileInfos, directory, errorInfo) {\n    var actionInfo = this._createEditActionInfo(\"download\", targetFileInfos, directory);\n\n    var itemsLength = targetFileInfos.length;\n    actionInfo.singleRequest = 1 === itemsLength;\n\n    this._raiseEditActionStarting(actionInfo);\n\n    this._raiseEditActionResultAcquired(actionInfo);\n\n    for (var index = 0; index < itemsLength - 1; index++) {\n      this._raiseEditActionItemError(actionInfo, {\n        errorCode: errorInfo.errorCode,\n        errorText: errorInfo.errorText,\n        fileItem: targetFileInfos[index].fileItem,\n        index: index\n      });\n    }\n\n    this._raiseEditActionError(actionInfo, {\n      errorCode: errorInfo.errorCode,\n      errorText: errorInfo.errorText,\n      fileItem: targetFileInfos[itemsLength - 1].fileItem,\n      index: itemsLength - 1\n    });\n  }\n\n  _changeDirectoryOnError(dirInfo, skipNavigationOnError, isActualDirectoryRequired) {\n    if (isActualDirectoryRequired) {\n      dirInfo = this._getActualDirectoryInfo(dirInfo);\n    }\n\n    this._resetDirectoryState(dirInfo);\n\n    dirInfo.expanded = false;\n\n    if (!skipNavigationOnError) {\n      this.setCurrentDirectory(dirInfo.parentDirectory);\n    }\n  }\n\n  _getItemActionResult(actionResult) {\n    return Array.isArray(actionResult) ? actionResult[0] : actionResult;\n  }\n\n  _processEditAction(actionInfo, beforeAction, action, afterAction, completeAction) {\n    var isAnyOperationSuccessful = false;\n\n    this._raiseEditActionStarting(actionInfo);\n\n    var actionResult = actionInfo.itemInfos.map((itemInfo, itemIndex) => this._processBeforeItemEditAction(beforeAction, itemInfo).then(() => {\n      var itemActionResult = this._getItemActionResult(action(itemInfo.fileItem, itemIndex));\n\n      return itemActionResult.done(() => afterAction(itemInfo));\n    }));\n    actionInfo.singleRequest = 1 === actionResult.length;\n\n    this._raiseEditActionResultAcquired(actionInfo);\n\n    return whenSome(actionResult, info => {\n      isAnyOperationSuccessful = true;\n\n      this._raiseCompleteEditActionItem(actionInfo, info);\n    }, errorInfo => this._raiseEditActionItemError(actionInfo, errorInfo)).then(() => {\n      completeAction(isAnyOperationSuccessful);\n\n      this._raiseCompleteEditAction(actionInfo);\n    });\n  }\n\n  _createEditActionInfo(name, targetItemInfos, directory, customData) {\n    targetItemInfos = Array.isArray(targetItemInfos) ? targetItemInfos : [targetItemInfos];\n    customData = customData || {};\n    var items = targetItemInfos.map(itemInfo => itemInfo.fileItem);\n    return {\n      name: name,\n      itemInfos: targetItemInfos,\n      items: items,\n      directory: directory,\n      customData: customData,\n      singleRequest: true\n    };\n  }\n\n  _processBeforeItemEditAction(action, itemInfo) {\n    var deferred = new Deferred();\n\n    var args = this._createBeforeActionArgs();\n\n    try {\n      action(args, itemInfo);\n    } catch (errorInfo) {\n      return deferred.reject(errorInfo).promise();\n    }\n\n    if (!args.cancel) {\n      deferred.resolve();\n    } else if (true === args.cancel) {\n      return deferred.reject({\n        errorText: args.errorText,\n        errorCode: args.errorCode\n      });\n    } else if (isPromise(args.cancel)) {\n      when(args.cancel).then(res => {\n        if (true === res) {\n          deferred.reject();\n        } else if (isObject(res) && true === res.cancel) {\n          deferred.reject({\n            errorText: res.errorText,\n            errorCode: res.errorCode\n          });\n        }\n\n        deferred.resolve();\n      }, deferred.resolve);\n    }\n\n    return deferred.promise();\n  }\n\n  _createBeforeActionArgs() {\n    return {\n      errorCode: void 0,\n      errorText: \"\",\n      cancel: false\n    };\n  }\n\n  _getItemInfosForUploaderFiles(files, parentDirectoryInfo) {\n    var pathInfo = this._getPathInfo(parentDirectoryInfo);\n\n    var result = [];\n\n    for (var i = 0; i < files.length; i++) {\n      var file = files[i];\n      var item = new FileSystemItem(pathInfo, file.name, false);\n\n      var itemInfo = this._createFileInfo(item, parentDirectoryInfo);\n\n      result.push(itemInfo);\n    }\n\n    return result;\n  }\n\n  refresh() {\n    if (this._lockRefresh) {\n      return this._refreshDeferred;\n    }\n\n    this._lockRefresh = true;\n    return this._executeDataLoad(() => this._refreshDeferred = this._refreshInternal(), \"refresh\");\n  }\n\n  startSingleLoad() {\n    this._singleOperationLockId = new Guid().toString();\n  }\n\n  endSingleLoad() {\n    delete this._singleOperationLockId;\n  }\n\n  _refreshInternal() {\n    var cachedRootInfo = {\n      items: this._rootDirectoryInfo.items\n    };\n\n    var selectedKeyParts = this._getDirectoryPathKeyParts(this.getCurrentDirectory());\n\n    this._resetDirectoryState(this._rootDirectoryInfo);\n\n    return this._loadItemsRecursive(this._rootDirectoryInfo, cachedRootInfo).then(() => {\n      var dirInfo = this._findDirectoryByPathKeyParts(selectedKeyParts);\n\n      this.setCurrentDirectory(dirInfo);\n      delete this._lockRefresh;\n    });\n  }\n\n  _loadItemsRecursive(directoryInfo, cachedDirectoryInfo) {\n    var _this = this;\n\n    return this.getDirectories(directoryInfo).then(dirInfos => {\n      var itemDeferreds = [];\n\n      var _loop = function (i) {\n        var cachedItem = cachedDirectoryInfo.items.find(cache => dirInfos[i].fileItem.key === cache.fileItem.key);\n\n        if (!cachedItem) {\n          return \"continue\";\n        }\n\n        dirInfos[i].expanded = cachedItem.expanded;\n\n        if (dirInfos[i].expanded) {\n          itemDeferreds.push(_this._loadItemsRecursive(dirInfos[i], cachedItem));\n        }\n      };\n\n      for (var i = 0; i < dirInfos.length; i++) {\n        var _ret = _loop(i);\n\n        if (\"continue\" === _ret) {\n          continue;\n        }\n      }\n\n      return whenSome(itemDeferreds);\n    }, () => null);\n  }\n\n  _setCurrentDirectoryByPathParts(pathParts, useKeys) {\n    return this._executeDataLoad(() => this._setCurrentDirectoryByPathPartsInternal(pathParts, useKeys), \"navigation\");\n  }\n\n  _setCurrentDirectoryByPathPartsInternal(pathParts, useKeys) {\n    return this._getDirectoryByPathParts(this._rootDirectoryInfo, pathParts, useKeys).then(directoryInfo => {\n      for (var info = directoryInfo.parentDirectory; info; info = info.parentDirectory) {\n        info.expanded = true;\n      }\n\n      this.setCurrentDirectory(directoryInfo);\n    }, () => {\n      this._raisePathPotentiallyChanged();\n    });\n  }\n\n  _executeDataLoad(action, operation) {\n    if (this._dataLoadingDeferred) {\n      return this._dataLoadingDeferred.then(() => this._executeDataLoad(action, operation));\n    }\n\n    this._dataLoading = true;\n    this._dataLoadingDeferred = new Deferred();\n\n    if (this._isInitialized) {\n      this._raiseDataLoading(operation);\n    }\n\n    return action().always(() => {\n      var tempDeferred = this._dataLoadingDeferred;\n      this._dataLoadingDeferred = null;\n      this._dataLoading = false;\n      tempDeferred.resolve();\n    });\n  }\n\n  _getDirectoryByPathParts(parentDirectoryInfo, pathParts, useKeys) {\n    if (pathParts.length < 1) {\n      return new Deferred().resolve(parentDirectoryInfo).promise();\n    }\n\n    var fieldName = useKeys ? \"key\" : \"name\";\n    return this.getDirectories(parentDirectoryInfo).then(dirInfos => {\n      var subDirInfo = dirInfos.find(d => d.fileItem[fieldName] === pathParts[0]);\n\n      if (!subDirInfo) {\n        return new Deferred().reject().promise();\n      }\n\n      var restPathParts = [...pathParts].splice(1);\n      return this._getDirectoryByPathParts(subDirInfo, restPathParts, useKeys);\n    });\n  }\n\n  _getDirectoryPathKeyParts(directoryInfo) {\n    var pathParts = [];\n\n    while (directoryInfo && directoryInfo.parentDirectory) {\n      pathParts.unshift(directoryInfo.fileItem.key);\n      directoryInfo = directoryInfo.parentDirectory;\n    }\n\n    return pathParts;\n  }\n\n  _findDirectoryByPathKeyParts(keyParts) {\n    var selectedDirInfo = this._rootDirectoryInfo;\n\n    if (0 === keyParts.length) {\n      return selectedDirInfo;\n    }\n\n    var i = 0;\n    var newSelectedDir = selectedDirInfo;\n\n    while (newSelectedDir && i < keyParts.length) {\n      newSelectedDir = selectedDirInfo.items.find(info => info.fileItem.key === keyParts[i]);\n\n      if (newSelectedDir) {\n        selectedDirInfo = newSelectedDir;\n      }\n\n      i++;\n    }\n\n    return selectedDirInfo;\n  }\n\n  _getActualDirectoryInfo(directoryInfo) {\n    var keys = this._getDirectoryPathKeyParts(directoryInfo);\n\n    return this._findDirectoryByPathKeyParts(keys);\n  }\n\n  _createDirInfoByName(name, parentDirectoryInfo) {\n    var dirPathInfo = this._getPathInfo(parentDirectoryInfo);\n\n    var fileItem = new FileSystemItem(dirPathInfo, name, true);\n    return this._createDirectoryInfo(fileItem, parentDirectoryInfo);\n  }\n\n  _createDirectoryInfo(fileItem, parentDirectoryInfo) {\n    return extend(this._createFileInfo(fileItem, parentDirectoryInfo), {\n      icon: \"folder\",\n      expanded: fileItem.isRoot(),\n      items: []\n    });\n  }\n\n  _createFileInfo(fileItem, parentDirectoryInfo) {\n    return {\n      fileItem: fileItem,\n      parentDirectory: parentDirectoryInfo,\n      icon: this._getFileItemDefaultIcon(fileItem),\n\n      getInternalKey() {\n        return \"FIK_\".concat(this.fileItem.key);\n      },\n\n      getDisplayName() {\n        return this.displayName || this.fileItem.name;\n      }\n\n    };\n  }\n\n  _resetDirectoryState(directoryInfo, isActualDirectoryRequired) {\n    if (isActualDirectoryRequired) {\n      directoryInfo = this._getActualDirectoryInfo(directoryInfo);\n    }\n\n    directoryInfo.itemsLoaded = false;\n    directoryInfo.items = [];\n  }\n\n  _getFileItemDefaultIcon(fileItem) {\n    if (fileItem.isDirectory) {\n      return \"folder\";\n    }\n\n    var extension = fileItem.getFileExtension();\n    var icon = this._defaultIconMap[extension];\n    return icon || \"doc\";\n  }\n\n  _createDefaultIconMap() {\n    var result = {\n      \".txt\": \"txtfile\",\n      \".rtf\": \"rtffile\",\n      \".doc\": \"docfile\",\n      \".docx\": \"docxfile\",\n      \".xls\": \"xlsfile\",\n      \".xlsx\": \"xlsxfile\",\n      \".ppt\": \"pptfile\",\n      \".pptx\": \"pptxfile\",\n      \".pdf\": \"pdffile\"\n    };\n    [\".png\", \".gif\", \".jpg\", \".jpeg\", \".ico\", \".bmp\"].forEach(extension => {\n      result[extension] = \"image\";\n    });\n    return result;\n  }\n\n  _createRootDirectoryInfo(text) {\n    var rootDirectory = new FileSystemItem(null, \"\", true);\n\n    var result = this._createDirectoryInfo(rootDirectory, null);\n\n    result.displayName = text || DEFAULT_ROOT_FILE_SYSTEM_ITEM_NAME;\n    return result;\n  }\n\n  setRootText(rootText) {\n    this._rootDirectoryInfo.displayName = rootText || DEFAULT_ROOT_FILE_SYSTEM_ITEM_NAME;\n  }\n\n  _raiseInitialized() {\n    this._tryCallAction(\"onInitialized\", {\n      controller: this\n    });\n  }\n\n  _raiseDataLoading(operation) {\n    this._tryCallAction(\"onDataLoading\", {\n      operation: operation\n    });\n  }\n\n  _raiseSelectedDirectoryChanged(directoryInfo) {\n    this._tryCallAction(\"onSelectedDirectoryChanged\", {\n      selectedDirectoryInfo: directoryInfo\n    });\n  }\n\n  _raiseEditActionStarting(actionInfo) {\n    this._tryCallAction(\"onEditActionStarting\", actionInfo);\n  }\n\n  _raiseEditActionResultAcquired(actionInfo) {\n    this._tryCallAction(\"onEditActionResultAcquired\", actionInfo);\n  }\n\n  _raiseEditActionError(actionInfo, errorInfo) {\n    this._tryCallAction(\"onEditActionError\", actionInfo, errorInfo);\n  }\n\n  _raiseEditActionItemError(actionInfo, errorInfo) {\n    this._tryCallAction(\"onEditActionItemError\", actionInfo, errorInfo);\n  }\n\n  _raiseCompleteEditActionItem(actionInfo, info) {\n    this._tryCallAction(\"onCompleteEditActionItem\", actionInfo, info);\n  }\n\n  _raiseCompleteEditAction(actionInfo) {\n    this._tryCallAction(\"onCompleteEditAction\", actionInfo);\n  }\n\n  _raisePathPotentiallyChanged() {\n    this._tryCallAction(\"onPathPotentiallyChanged\");\n  }\n\n  _tryCallAction(actionName) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if (this._isInitialized && this._options[actionName]) {\n      this._options[actionName](...args);\n    }\n  }\n\n  _resetState() {\n    this._selectedDirectory = null;\n    this._rootDirectoryInfo.items = [];\n    this._rootDirectoryInfo.itemsLoaded = false;\n    this._loadedItems = {};\n  }\n\n  _getPathInfo(directoryInfo) {\n    var pathInfo = [];\n\n    for (var dirInfo = directoryInfo; dirInfo && !dirInfo.fileItem.isRoot(); dirInfo = dirInfo.parentDirectory) {\n      pathInfo.unshift({\n        key: dirInfo.fileItem.key,\n        name: dirInfo.fileItem.name\n      });\n    }\n\n    return pathInfo;\n  }\n\n  on(eventName, eventHandler) {\n    var finalEventName = \"on\".concat(eventName);\n    this._options[finalEventName] = eventHandler;\n  }\n\n  get _editingEvents() {\n    return this._options.editingEvents;\n  }\n\n}\n\nclass FileSecurityController {\n  constructor(options) {\n    this._options = extend({\n      allowedFileExtensions: [],\n      maxFileSize: 0\n    }, options);\n    this._extensionsMap = {};\n\n    this._allowedFileExtensions.forEach(extension => {\n      this._extensionsMap[extension.toUpperCase()] = true;\n    });\n  }\n\n  getAllowedItems(items) {\n    if (0 === this._allowedFileExtensions.length) {\n      return items;\n    }\n\n    return items.filter(item => item.isDirectory || this._isValidExtension(item.name));\n  }\n\n  validateExtension(name) {\n    if (!this._isValidExtension(name)) {\n      throw new FileSystemError(ErrorCode.WrongFileExtension, null);\n    }\n  }\n\n  validateMaxFileSize(size) {\n    if (this._maxFileSize && size > this._maxFileSize) {\n      throw new FileSystemError(ErrorCode.MaxFileSizeExceeded, null);\n    }\n  }\n\n  _isValidExtension(name) {\n    if (0 === this._allowedFileExtensions.length) {\n      return true;\n    }\n\n    var extension = getFileExtension(name).toUpperCase();\n    return this._extensionsMap[extension];\n  }\n\n  get _allowedFileExtensions() {\n    return this._options.allowedFileExtensions;\n  }\n\n  get _maxFileSize() {\n    return this._options.maxFileSize;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}