{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/range_series.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend } from \"../../core/utils/extend\";\nvar _extend = extend;\nimport { isDefined as _isDefined } from \"../../core/utils/type\";\nimport { map as _map } from \"../core/utils\";\nimport { noop as _noop } from \"../../core/utils/common\";\nimport { chart as scatterSeries } from \"./scatter_series\";\nimport { chart as barChart } from \"./bar_series\";\nimport { chart as areaChart } from \"./area_series\";\nvar barSeries = barChart.bar;\nvar areaSeries = areaChart.area;\nvar chart = {};\nvar baseRangeSeries = {\n  areErrorBarsVisible: _noop,\n  _createErrorBarGroup: _noop,\n  _checkData: function (data, skippedFields) {\n    var valueFields = this.getValueFields();\n    return scatterSeries._checkData.call(this, data, skippedFields, {\n      minValue: valueFields[0],\n      value: valueFields[1]\n    }) && data.minValue === data.minValue;\n  },\n  getValueRangeInitialValue: scatterSeries.getValueRangeInitialValue,\n  _getPointDataSelector: function (data) {\n    var valueFields = this.getValueFields();\n    var val1Field = valueFields[0];\n    var val2Field = valueFields[1];\n    var tagField = this.getTagField();\n    var argumentField = this.getArgumentField();\n    return data => ({\n      tag: data[tagField],\n      minValue: this._processEmptyValue(data[val1Field]),\n      value: this._processEmptyValue(data[val2Field]),\n      argument: data[argumentField],\n      data: data\n    });\n  },\n  _defaultAggregator: \"range\",\n  _aggregators: {\n    range(_ref, series) {\n      var {\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd,\n        data: data\n      } = _ref;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueFields = series.getValueFields();\n      var val1Field = valueFields[0];\n      var val2Field = valueFields[1];\n      var result = data.reduce((result, item) => {\n        var val1 = item[val1Field];\n        var val2 = item[val2Field];\n\n        if (!_isDefined(val1) || !_isDefined(val2)) {\n          return result;\n        }\n\n        result[val1Field] = Math.min(result[val1Field], Math.min(val1, val2));\n        result[val2Field] = Math.max(result[val2Field], Math.max(val1, val2));\n        return result;\n      }, {\n        [val1Field]: 1 / 0,\n        [val2Field]: -1 / 0,\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n      });\n\n      if (!isFinite(result[val1Field]) || !isFinite(result[val2Field])) {\n        if (data.filter(i => null === i[val1Field] && null === i[val2Field]).length === data.length) {\n          result[val1Field] = result[val2Field] = null;\n        } else {\n          return;\n        }\n      }\n\n      return result;\n    }\n\n  },\n  getValueFields: function () {\n    return [this._options.rangeValue1Field || \"val1\", this._options.rangeValue2Field || \"val2\"];\n  },\n\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var {\n      rotated: rotated\n    } = this._options;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var minCoordName = rotated ? \"minX\" : \"minY\";\n    var oppositeCoordName = isOpposite ? \"vx\" : \"vy\";\n    var points = this.getPoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : void 0;\n      } else {\n        var coords = [Math.min(p[coordName], p[minCoordName]), Math.max(p[coordName], p[minCoordName])];\n        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p[oppositeCoordName] : void 0;\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n\n};\nchart.rangebar = _extend({}, barSeries, baseRangeSeries);\nchart.rangearea = _extend({}, areaSeries, {\n  _drawPoint: function (options) {\n    var point = options.point;\n\n    if (point.isInVisibleArea()) {\n      point.clearVisibility();\n      point.draw(this._renderer, options.groups);\n\n      this._drawnPoints.push(point);\n\n      if (!point.visibleTopMarker) {\n        point.hideMarker(\"top\");\n      }\n\n      if (!point.visibleBottomMarker) {\n        point.hideMarker(\"bottom\");\n      }\n    } else {\n      point.setInvisibility();\n    }\n  },\n  _prepareSegment: function (points, rotated) {\n    var processedPoints = this._processSinglePointsAreaSegment(points, rotated);\n\n    var processedMinPointsCoords = _map(processedPoints, function (pt) {\n      return pt.getCoords(true);\n    });\n\n    return {\n      line: processedPoints,\n      bottomLine: processedMinPointsCoords,\n      area: _map(processedPoints, function (pt) {\n        return pt.getCoords();\n      }).concat(processedMinPointsCoords.slice().reverse()),\n      singlePointSegment: processedPoints !== points\n    };\n  },\n  _getDefaultSegment: function (segment) {\n    var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);\n\n    defaultSegment.bottomLine = defaultSegment.line;\n    return defaultSegment;\n  },\n  _removeElement: function (element) {\n    areaSeries._removeElement.call(this, element);\n\n    element.bottomLine && element.bottomLine.remove();\n  },\n  _drawElement: function (segment, group) {\n    var drawnElement = areaSeries._drawElement.call(this, segment, group);\n\n    drawnElement.bottomLine = this._bordersGroup && this._createBorderElement(segment.bottomLine, {\n      \"stroke-width\": this._styles.normal.border[\"stroke-width\"]\n    }).append(this._bordersGroup);\n    return drawnElement;\n  },\n  _applyStyle: function (style) {\n    var elementsGroup = this._elementsGroup;\n    var bordersGroup = this._bordersGroup;\n    elementsGroup && elementsGroup.smartAttr(style.elements);\n    bordersGroup && bordersGroup.attr(style.border);\n    (this._graphics || []).forEach(function (graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      });\n      graphic.bottomLine && graphic.bottomLine.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      });\n    });\n  },\n  _updateElement: function (element, segment, animate, complete) {\n    var bottomLineParams = {\n      points: segment.bottomLine\n    };\n    var bottomBorderElement = element.bottomLine;\n\n    areaSeries._updateElement.apply(this, arguments);\n\n    if (bottomBorderElement) {\n      animate ? bottomBorderElement.animate(bottomLineParams) : bottomBorderElement.attr(bottomLineParams);\n    }\n  }\n}, baseRangeSeries);\nexport { chart };","map":null,"metadata":{},"sourceType":"module"}