{"ast":null,"code":"/**\r\n * DevExtreme (esm/core/utils/array.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"./type\";\nimport { orderEach } from \"./object\";\nimport config from \"../config\";\n\nfunction createOccurrenceMap(array) {\n  return array.reduce((map, value) => {\n    var _map$value;\n\n    map[value] = (null !== (_map$value = map[value]) && void 0 !== _map$value ? _map$value : 0) + 1;\n    return map;\n  }, {});\n}\n\nexport var wrapToArray = function (item) {\n  return Array.isArray(item) ? item : [item];\n};\nexport var getUniqueValues = function (values) {\n  return [...new Set(values)];\n};\nexport var getIntersection = function (firstArray, secondArray) {\n  var secondArrayMap = createOccurrenceMap(secondArray);\n  return firstArray.filter(value => secondArrayMap[value]--);\n};\nexport var removeDuplicates = function () {\n  var from = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];\n  var toRemove = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];\n  var toRemoveMap = createOccurrenceMap(toRemove);\n  return from.filter(value => !toRemoveMap[value]--);\n};\nexport var normalizeIndexes = function (items, indexPropName, currentItem, needIndexCallback) {\n  var indexedItems = {};\n  var {\n    useLegacyVisibleIndex: useLegacyVisibleIndex\n  } = config();\n  var currentIndex = 0;\n\n  var shouldUpdateIndex = item => !isDefined(item[indexPropName]) && (!needIndexCallback || needIndexCallback(item));\n\n  items.forEach(item => {\n    var index = item[indexPropName];\n\n    if (index >= 0) {\n      indexedItems[index] = indexedItems[index] || [];\n\n      if (item === currentItem) {\n        indexedItems[index].unshift(item);\n      } else {\n        indexedItems[index].push(item);\n      }\n    } else {\n      item[indexPropName] = void 0;\n    }\n  });\n\n  if (!useLegacyVisibleIndex) {\n    items.forEach(item => {\n      if (shouldUpdateIndex(item)) {\n        while (indexedItems[currentIndex]) {\n          currentIndex++;\n        }\n\n        indexedItems[currentIndex] = [item];\n        currentIndex++;\n      }\n    });\n  }\n\n  currentIndex = 0;\n  orderEach(indexedItems, function (index, items) {\n    items.forEach(item => {\n      if (index >= 0) {\n        item[indexPropName] = currentIndex++;\n      }\n    });\n  });\n\n  if (useLegacyVisibleIndex) {\n    items.forEach(item => {\n      if (shouldUpdateIndex(item)) {\n        item[indexPropName] = currentIndex++;\n      }\n    });\n  }\n};\nexport var groupBy = (array, getGroupName) => array.reduce((groupedResult, item) => {\n  var _groupedResult$groupN;\n\n  var groupName = getGroupName(item);\n  groupedResult[groupName] = null !== (_groupedResult$groupN = groupedResult[groupName]) && void 0 !== _groupedResult$groupN ? _groupedResult$groupN : [];\n  groupedResult[groupName].push(item);\n  return groupedResult;\n}, {});","map":null,"metadata":{},"sourceType":"module"}