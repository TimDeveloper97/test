{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/html_editor/modules/tableResizing.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getOuterWidth, getOuterHeight, getHeight } from \"../../../core/utils/size\";\nimport $ from \"../../../core/renderer\";\nimport eventsEngine from \"../../../events/core/events_engine\";\nimport { isDefined } from \"../../../core/utils/type\";\nimport { addNamespace } from \"../../../events/utils/index\";\nimport _windowResizeCallbacks from \"../../../core/utils/resize_callbacks\";\nimport { move } from \"../../../animation/translator\";\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport BaseModule from \"./base\";\nimport Draggable from \"../../draggable\";\nimport { each } from \"../../../core/utils/iterator\";\nimport { getWindow, hasWindow } from \"../../../core/utils/window\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { setLineElementsFormat, getLineElements, getAutoSizedElements, getColumnElements, unfixTableWidth } from \"../utils/table_helper\";\nvar DX_COLUMN_RESIZE_FRAME_CLASS = \"dx-table-resize-frame\";\nvar DX_COLUMN_RESIZER_CLASS = \"dx-htmleditor-column-resizer\";\nvar DX_ROW_RESIZER_CLASS = \"dx-htmleditor-row-resizer\";\nvar DEFAULTS = {\n  minColumnWidth: 40,\n  minRowHeight: 24\n};\nvar DRAGGABLE_ELEMENT_OFFSET = 2;\nvar ROUGH_OFFSET = 3;\nvar MODULE_NAMESPACE = \"dxHtmlTableResizingModule\";\nvar POINTERDOWN_EVENT = addNamespace(\"dxpointerdown\", MODULE_NAMESPACE);\nvar SCROLL_EVENT = addNamespace(\"scroll\", MODULE_NAMESPACE);\nexport default class TableResizingModule extends BaseModule {\n  constructor(quill, options) {\n    super(quill, options);\n    this.enabled = !!options.enabled;\n    this._tableResizeFrames = [];\n    this._minColumnWidth = this._minSizeLimit(\"minColumnWidth\", options.minColumnWidth);\n    this._minRowHeight = this._minSizeLimit(\"minRowHeight\", options.minRowHeight);\n    this._quillContainer = this.editorInstance._getQuillContainer();\n    this._tableData = [];\n\n    if (this.enabled) {\n      this._applyResizing();\n    }\n  }\n\n  _applyResizing(forcedStart) {\n    if (forcedStart) {\n      this._applyResizingImpl();\n    } else {\n      this.editorInstance.addContentInitializedCallback(this._applyResizingImpl.bind(this));\n    }\n\n    this.addCleanCallback(this.clean.bind(this));\n    this._resizeHandlerWithContext = _windowResizeCallbacks.add(this._resizeHandler.bind(this));\n  }\n\n  _minSizeLimit(propertyName, newValue) {\n    return isDefined(newValue) ? Math.max(newValue, 0) : DEFAULTS[propertyName];\n  }\n\n  _applyResizingImpl() {\n    var $tables = this._findTables();\n\n    if ($tables.length) {\n      this._fixTablesWidths($tables);\n\n      this._createResizeFrames($tables);\n\n      this._updateFramesPositions();\n\n      this._updateFramesSeparators();\n    }\n\n    this._attachEvents();\n  }\n\n  _attachEvents() {\n    eventsEngine.on(this.editorInstance._getContent(), SCROLL_EVENT, this._updateFramesPositions.bind(this));\n    this.quill.on(\"text-change\", this._getQuillTextChangeHandler());\n  }\n\n  _detachEvents() {\n    eventsEngine.off(this.editorInstance._getContent(), MODULE_NAMESPACE);\n    this.quill.off(\"text-change\", this._quillTextChangeHandler);\n  }\n\n  _getQuillTextChangeHandler(delta, oldContent, source) {\n    return (delta, oldContent, source) => {\n      if (this._isTableChanging()) {\n        var $tables = this._findTables();\n\n        this._removeResizeFrames();\n\n        if (\"api\" === source) {\n          this._fixTablesWidths($tables);\n        }\n\n        this._updateTablesColumnsWidth($tables);\n\n        this._createResizeFrames($tables);\n\n        this._updateFramesPositions();\n\n        this._updateFramesSeparators();\n      } else {\n        this._updateFramesPositions();\n\n        if (!this._isDragging) {\n          this._updateFramesSeparators();\n        }\n      }\n    };\n  }\n\n  _getFrameForTable($table) {\n    var _this$_framesForTable;\n\n    return null === (_this$_framesForTable = this._framesForTables) || void 0 === _this$_framesForTable ? void 0 : _this$_framesForTable.get($table.get(0));\n  }\n\n  _resizeHandler() {\n    this._windowResizeTimeout = setTimeout(() => {\n      var $tables = this._findTables();\n\n      each($tables, (index, table) => {\n        var $table = $(table);\n        var frame = this._tableResizeFrames[index];\n        var actualTableWidth = getOuterWidth($table);\n\n        var lastTableWidth = this._tableLastWidth(frame);\n\n        if (Math.abs(actualTableWidth - lastTableWidth) > 1) {\n          this._tableLastWidth(frame, actualTableWidth);\n\n          this._updateColumnsWidth($table, index);\n        }\n      });\n\n      this._updateFramesPositions();\n\n      this._updateFramesSeparators();\n    });\n  }\n\n  _findTables() {\n    return $(this._quillContainer).find(\"table\");\n  }\n\n  _getWidthStyleValue($element) {\n    var styleValue = $element[0].style.width;\n    return \"\" !== styleValue ? parseInt(styleValue) : void 0;\n  }\n\n  _tableLastWidth(frame, newValue) {\n    if (isDefined(newValue)) {\n      frame.lastWidth = newValue;\n    } else {\n      return null === frame || void 0 === frame ? void 0 : frame.lastWidth;\n    }\n  }\n\n  _fixTablesWidths($tables) {\n    each($tables, (index, table) => {\n      var $table = $(table);\n\n      var $columnElements = this._getTableDeterminantElements($table, \"horizontal\");\n\n      if (!this._tableResizeFrames[index]) {\n        this._tableResizeFrames[index] = {\n          lastWidth: void 0\n        };\n      }\n\n      var frame = this._getFrameForTable($table);\n\n      if (!frame) {\n        this._tableResizeFrames.push({\n          $table: $table\n        });\n      }\n\n      if (0 === getAutoSizedElements($table).length) {\n        var _this$_tableLastWidth;\n\n        var {\n          columnsSum: columnsSum\n        } = this._getColumnElementsSum($columnElements);\n\n        unfixTableWidth($table, {\n          quill: this.quill\n        });\n        var tableWidth = null !== (_this$_tableLastWidth = this._tableLastWidth(frame)) && void 0 !== _this$_tableLastWidth ? _this$_tableLastWidth : getOuterWidth($table);\n\n        if (frame) {\n          this._tableLastWidth(frame, Math.max(columnsSum, tableWidth));\n        }\n      }\n    });\n  }\n\n  _createResizeFrames($tables) {\n    this._framesForTables = new Map();\n    $tables.each((index, table) => {\n      var _this$_tableResizeFra;\n\n      var $table = $(table);\n      var $lastTable = null === (_this$_tableResizeFra = this._tableResizeFrames[index]) || void 0 === _this$_tableResizeFra ? void 0 : _this$_tableResizeFra.$table;\n      var $tableLastWidth = this._tableResizeFrames[index].lastWidth;\n      this._tableResizeFrames[index] = {\n        $frame: this._createTableResizeFrame(table),\n        $table: $table,\n        index: index,\n        lastWidth: $lastTable && table === $lastTable.get(0) ? $tableLastWidth : void 0,\n        columnsCount: this._getTableDeterminantElements($table, \"horizontal\").length,\n        rowsCount: this._getTableDeterminantElements($table, \"vertical\").length\n      };\n\n      this._framesForTables.set(table, this._tableResizeFrames[index]);\n    });\n    this._tableResizeFrames.length = $tables.length;\n  }\n\n  _isTableChanging() {\n    var $tables = this._findTables();\n\n    var result = false;\n\n    if ($tables.length !== this._tableResizeFrames.length) {\n      result = true;\n    } else {\n      each($tables, (index, table) => {\n        var $table = $(table);\n        var frame = this._tableResizeFrames[index];\n\n        var isColumnsCountChanged = (null === frame || void 0 === frame ? void 0 : frame.columnsCount) !== this._getTableDeterminantElements($table, \"horizontal\").length;\n\n        var isRowCountChanged = (null === frame || void 0 === frame ? void 0 : frame.rowsCount) !== this._getTableDeterminantElements($table, \"vertical\").length;\n\n        if (isColumnsCountChanged || isRowCountChanged) {\n          result = true;\n          return false;\n        }\n      });\n    }\n\n    return result;\n  }\n\n  _removeResizeFrames(clearArray) {\n    var _this$_framesForTable2;\n\n    each(this._tableResizeFrames, (index, resizeFrame) => {\n      if (resizeFrame.$frame) {\n        var _resizeFrame$$frame;\n\n        var resizerElementsSelector = \".\".concat(DX_COLUMN_RESIZER_CLASS, \", .\").concat(DX_ROW_RESIZER_CLASS);\n\n        this._detachSeparatorEvents(null === (_resizeFrame$$frame = resizeFrame.$frame) || void 0 === _resizeFrame$$frame ? void 0 : _resizeFrame$$frame.find(resizerElementsSelector));\n\n        resizeFrame.$frame.remove();\n      }\n    });\n    null === (_this$_framesForTable2 = this._framesForTables) || void 0 === _this$_framesForTable2 ? void 0 : _this$_framesForTable2.clear();\n\n    if (clearArray) {\n      this._tableResizeFrames = [];\n    }\n  }\n\n  _detachSeparatorEvents($lineSeparators) {\n    $lineSeparators.each((i, $lineSeparator) => {\n      eventsEngine.off($lineSeparator, POINTERDOWN_EVENT);\n    });\n  }\n\n  _createTableResizeFrame() {\n    return $(\"<div>\").addClass(DX_COLUMN_RESIZE_FRAME_CLASS).appendTo(this._quillContainer);\n  }\n\n  _updateFramesPositions() {\n    each(this._tableResizeFrames, (index, tableResizeFrame) => {\n      this._updateFramePosition(tableResizeFrame.$table, tableResizeFrame.$frame);\n    });\n  }\n\n  _updateFramePosition($table, $frame) {\n    var {\n      height: height,\n      width: width,\n      top: targetTop,\n      left: targetLeft\n    } = getBoundingRect($table.get(0));\n    var {\n      top: containerTop,\n      left: containerLeft\n    } = getBoundingRect(this.quill.root);\n    $frame.css({\n      height: height,\n      width: width,\n      top: targetTop - containerTop,\n      left: targetLeft - containerLeft\n    });\n    move($frame, {\n      left: 0,\n      top: 0\n    });\n  }\n\n  _updateFramesSeparators(direction) {\n    each(this._tableResizeFrames, (index, frame) => {\n      if (direction) {\n        this._updateFrameSeparators(frame, direction);\n      } else {\n        this._updateFrameSeparators(frame, \"vertical\");\n\n        this._updateFrameSeparators(frame, \"horizontal\");\n      }\n    });\n  }\n\n  _isDraggable($element) {\n    return $element.hasClass(\"dx-draggable\") && $element.is(\":visible\");\n  }\n\n  _removeDraggable($currentLineSeparator, lineResizerClass) {\n    if (this._isDraggable($currentLineSeparator)) {\n      var draggable = $($currentLineSeparator).dxDraggable(\"instance\");\n      draggable.dispose();\n      $($currentLineSeparator).addClass(lineResizerClass);\n    }\n  }\n\n  _getDirectionInfo(direction) {\n    if (\"vertical\" === direction) {\n      return {\n        lineResizerClass: DX_ROW_RESIZER_CLASS,\n        sizeFunction: x => getOuterHeight(x),\n        positionCoordinate: \"top\",\n        positionStyleProperty: \"height\",\n        positionCoordinateName: \"y\"\n      };\n    } else {\n      return {\n        lineResizerClass: DX_COLUMN_RESIZER_CLASS,\n        sizeFunction: x => getOuterWidth(x),\n        positionCoordinate: this.editorInstance.option(\"rtlEnabled\") ? \"right\" : \"left\",\n        positionStyleProperty: \"width\",\n        positionCoordinateName: \"x\"\n      };\n    }\n  }\n\n  _getSize($element, directionInfo) {\n    return directionInfo.sizeFunction($element);\n  }\n\n  _updateFrameSeparators(frame, direction) {\n    var $determinantElements = this._getTableDeterminantElements(frame.$table, direction);\n\n    var determinantElementsCount = $determinantElements.length;\n    var determinantElementsSeparatorsCount = determinantElementsCount - 1;\n\n    var directionInfo = this._getDirectionInfo(direction);\n\n    var lineSeparators = frame.$frame.find(\".\".concat(directionInfo.lineResizerClass));\n    var styleOptions = {\n      transform: \"none\"\n    };\n    var currentPosition = 0;\n\n    for (var i = 0; i <= determinantElementsSeparatorsCount; i++) {\n      currentPosition += this._getSize($determinantElements.eq(i), directionInfo);\n\n      if (!isDefined(lineSeparators[i])) {\n        lineSeparators[i] = $(\"<div>\").addClass(directionInfo.lineResizerClass).appendTo(frame.$frame).get(0);\n      }\n\n      var $currentLineSeparator = $(lineSeparators[i]);\n\n      this._removeDraggable($currentLineSeparator, directionInfo.lineResizerClass);\n\n      styleOptions[directionInfo.positionCoordinate] = currentPosition - DRAGGABLE_ELEMENT_OFFSET;\n      $($currentLineSeparator).css(styleOptions);\n      var attachSeparatorData = {\n        lineSeparator: lineSeparators[i],\n        index: i,\n        $determinantElements: $determinantElements,\n        frame: frame,\n        direction: direction\n      };\n\n      this._attachColumnSeparatorEvents(attachSeparatorData);\n    }\n  }\n\n  _getTableDeterminantElements($table, direction) {\n    if (\"vertical\" === direction) {\n      return $table.find(\"th:first-child, td:first-child\");\n    } else {\n      return getColumnElements($table);\n    }\n  }\n\n  _attachColumnSeparatorEvents(options) {\n    eventsEngine.on(options.lineSeparator, POINTERDOWN_EVENT, () => {\n      this._createDraggableElement(options);\n    });\n  }\n\n  _dragStartHandler(_ref) {\n    var {\n      $determinantElements: $determinantElements,\n      index: index,\n      frame: frame,\n      direction: direction,\n      lineSeparator: lineSeparator\n    } = _ref;\n\n    var directionInfo = this._getDirectionInfo(direction);\n\n    this._isDragging = true;\n\n    this._fixColumnsWidth(frame.$table);\n\n    this._startLineSize = parseInt(this._getSize($($determinantElements[index]), directionInfo));\n    this._startTableWidth = getOuterWidth(frame.$table);\n    this._startLineSeparatorPosition = parseInt($(lineSeparator).css(directionInfo.positionCoordinate));\n    this._nextLineSize = 0;\n\n    if ($determinantElements[index + 1]) {\n      this._nextLineSize = parseInt(this._getSize($($determinantElements[index + 1]), directionInfo));\n    } else if (\"horizontal\" === direction) {\n      unfixTableWidth(frame.$table, {\n        quill: this.quill\n      });\n    }\n  }\n\n  _shouldRevertOffset(direction) {\n    return \"horizontal\" === direction && this.editorInstance.option(\"rtlEnabled\");\n  }\n\n  _isNextColumnWidthEnough(nextColumnNewSize, $nextColumnElement, eventOffset) {\n    if (!this._nextLineSize) {\n      return true;\n    } else if (nextColumnNewSize >= this._minColumnWidth) {\n      var isWidthIncreased = this._nextColumnOffsetLimit ? eventOffset < this._nextColumnOffsetLimit : eventOffset < 0;\n      var isWidthLimited = Math.abs(this._getWidthStyleValue($nextColumnElement) - getOuterWidth($nextColumnElement)) > ROUGH_OFFSET;\n      return isWidthIncreased || !isWidthLimited;\n    }\n\n    return false;\n  }\n\n  _shouldSetNextColumnWidth(nextColumnNewSize) {\n    return this._nextLineSize && nextColumnNewSize > 0;\n  }\n\n  _horizontalDragHandler(_ref2) {\n    var {\n      currentLineNewSize: currentLineNewSize,\n      directionInfo: directionInfo,\n      eventOffset: eventOffset,\n      $determinantElements: $determinantElements,\n      index: index,\n      frame: frame\n    } = _ref2;\n    var nextColumnNewSize = this._nextLineSize && this._nextLineSize - eventOffset;\n    var isCurrentColumnWidthEnough = currentLineNewSize >= this._minColumnWidth;\n    var $lineElements = getLineElements(frame.$table, index);\n    var $nextLineElements = getLineElements(frame.$table, index + 1);\n    var realWidthDiff = getOuterWidth($lineElements.eq(0)) - currentLineNewSize;\n\n    if (isCurrentColumnWidthEnough) {\n      if (this._isNextColumnWidthEnough(nextColumnNewSize, $determinantElements.eq(index + 1), eventOffset)) {\n        setLineElementsFormat(this, {\n          elements: $lineElements,\n          property: directionInfo.positionStyleProperty,\n          value: currentLineNewSize\n        });\n\n        if (this._shouldSetNextColumnWidth(nextColumnNewSize)) {\n          setLineElementsFormat(this, {\n            elements: $nextLineElements,\n            property: directionInfo.positionStyleProperty,\n            value: nextColumnNewSize\n          });\n        }\n\n        var isTableWidthChanged = Math.abs(this._startTableWidth - getOuterWidth(frame.$table)) < ROUGH_OFFSET;\n        var shouldRevertNewValue = Math.abs(realWidthDiff) > ROUGH_OFFSET || !this._nextLineSize && isTableWidthChanged;\n\n        if (shouldRevertNewValue) {\n          setLineElementsFormat(this, {\n            elements: $lineElements,\n            property: directionInfo.positionStyleProperty,\n            value: getOuterWidth($lineElements.eq(0))\n          });\n          nextColumnNewSize += currentLineNewSize - getOuterWidth($lineElements.eq(0));\n\n          if (this._shouldSetNextColumnWidth(nextColumnNewSize)) {\n            setLineElementsFormat(this, {\n              elements: $nextLineElements,\n              property: directionInfo.positionStyleProperty,\n              value: nextColumnNewSize\n            });\n          }\n        }\n      } else {\n        this._nextColumnOffsetLimit = this._nextColumnOffsetLimit || eventOffset;\n      }\n    }\n\n    this._$highlightedElement.css(directionInfo.positionCoordinate, this._startLineSeparatorPosition + eventOffset + realWidthDiff + \"px\");\n  }\n\n  _verticalDragHandler(_ref3) {\n    var {\n      currentLineNewSize: currentLineNewSize,\n      directionInfo: directionInfo,\n      eventOffset: eventOffset,\n      $determinantElements: $determinantElements,\n      index: index,\n      frame: frame\n    } = _ref3;\n    var newHeight = Math.max(currentLineNewSize, this._minRowHeight);\n    var $lineElements = getLineElements(frame.$table, index, \"vertical\");\n    setLineElementsFormat(this, {\n      elements: $lineElements,\n      property: directionInfo.positionStyleProperty,\n      value: newHeight\n    });\n    var rowHeightDiff = getOuterHeight($determinantElements.eq(index)) - currentLineNewSize;\n\n    this._$highlightedElement.css(directionInfo.positionCoordinate, this._startLineSeparatorPosition + eventOffset + rowHeightDiff + \"px\");\n  }\n\n  _dragMoveHandler(event, _ref4) {\n    var {\n      $determinantElements: $determinantElements,\n      index: index,\n      frame: frame,\n      direction: direction\n    } = _ref4;\n\n    var directionInfo = this._getDirectionInfo(direction);\n\n    var eventOffset = event.offset[directionInfo.positionCoordinateName];\n\n    this.editorInstance._saveValueChangeEvent(event);\n\n    if (this._shouldRevertOffset(direction)) {\n      eventOffset = -eventOffset;\n    }\n\n    var currentLineNewSize = this._startLineSize + eventOffset;\n\n    if (\"horizontal\" === direction) {\n      this._horizontalDragHandler({\n        currentLineNewSize: currentLineNewSize,\n        directionInfo: directionInfo,\n        eventOffset: eventOffset,\n        $determinantElements: $determinantElements,\n        index: index,\n        frame: frame\n      });\n    } else {\n      this._verticalDragHandler({\n        currentLineNewSize: currentLineNewSize,\n        directionInfo: directionInfo,\n        eventOffset: eventOffset,\n        $determinantElements: $determinantElements,\n        index: index,\n        frame: frame\n      });\n    }\n\n    this._updateFramePosition(frame.$table, frame.$frame);\n  }\n\n  _dragEndHandler(options) {\n    var _this$_$highlightedEl;\n\n    null === (_this$_$highlightedEl = this._$highlightedElement) || void 0 === _this$_$highlightedEl ? void 0 : _this$_$highlightedEl.remove();\n    this._isDragging = void 0;\n    this._nextColumnOffsetLimit = void 0;\n\n    this._tableLastWidth(options.frame, getOuterWidth(options.frame.$table));\n\n    this._updateFramesPositions();\n\n    this._updateFramesSeparators();\n  }\n\n  _isLastColumnResizing(_ref5) {\n    var {\n      $determinantElements: $determinantElements,\n      index: index\n    } = _ref5;\n    return !isDefined($determinantElements[index + 1]);\n  }\n\n  _getBoundaryConfig(options) {\n    var result = {};\n\n    if (\"vertical\" === options.direction) {\n      result.boundary = options.frame.$table;\n      result.boundOffset = {\n        bottom: hasWindow() ? -getHeight(getWindow()) : -getOuterHeight(this._quillContainer),\n        top: 0,\n        left: 0,\n        right: 0\n      };\n    } else if (!this._isLastColumnResizing(options)) {\n      result.boundary = options.frame.$table;\n    } else {\n      var $content = this.editorInstance._getContent();\n\n      result.boundary = $content;\n      result.boundOffset = {\n        bottom: 0,\n        top: 0,\n        left: $content.css(\"paddingLeft\"),\n        right: $content.css(\"paddingRight\")\n      };\n    }\n\n    return result;\n  }\n\n  _createDraggableElement(options) {\n    var _this$_$highlightedEl2;\n\n    var boundaryConfig = this._getBoundaryConfig(options);\n\n    var directionClass = \"vertical\" === options.direction ? \"dx-htmleditor-highlighted-row\" : \"dx-htmleditor-highlighted-column\";\n    null === (_this$_$highlightedEl2 = this._$highlightedElement) || void 0 === _this$_$highlightedEl2 ? void 0 : _this$_$highlightedEl2.remove();\n    this._$highlightedElement = $(\"<div>\").addClass(\"\".concat(directionClass)).insertAfter($(options.lineSeparator));\n    var config = {\n      contentTemplate: null,\n      allowMoveByClick: false,\n      dragDirection: options.direction,\n      onDragMove: _ref6 => {\n        var {\n          component: component,\n          event: event\n        } = _ref6;\n\n        this._dragMoveHandler(event, options);\n      },\n      onDragStart: () => {\n        this._dragStartHandler(options);\n      },\n      onDragEnd: () => {\n        this._dragEndHandler(options);\n      }\n    };\n    extend(config, boundaryConfig);\n    this._currentDraggableElement = this.editorInstance._createComponent(options.lineSeparator, Draggable, config);\n  }\n\n  _fixColumnsWidth($table) {\n    var determinantElements = this._getTableDeterminantElements($table);\n\n    each(determinantElements, (index, element) => {\n      var columnWidth = getOuterWidth(element);\n      var $lineElements = getLineElements($table, index);\n      setLineElementsFormat(this, {\n        elements: $lineElements,\n        property: \"width\",\n        value: Math.max(columnWidth, this._minColumnWidth)\n      });\n    });\n  }\n\n  _getColumnElementsSum(columnElements) {\n    var columnsWidths = [];\n    var columnsSum = 0;\n    each(columnElements, (index, element) => {\n      var $element = $(element);\n      var columnWidth = this._getWidthStyleValue($element) || getOuterWidth($element);\n      columnsWidths[index] = Math.max(columnWidth, this._minColumnWidth);\n      columnsSum += columnsWidths[index];\n    });\n    return {\n      columnsWidths: columnsWidths,\n      columnsSum: columnsSum\n    };\n  }\n\n  _setColumnsRatioWidth(columnElements, ratio, columnsWidths, $table) {\n    each(columnElements, index => {\n      var $lineElements = getLineElements($table, index);\n      var resultWidth;\n\n      if (ratio > 0) {\n        resultWidth = this._minColumnWidth + Math.round((columnsWidths[index] - this._minColumnWidth) * ratio);\n      } else {\n        resultWidth = this._minColumnWidth;\n      }\n\n      setLineElementsFormat(this, {\n        elements: $lineElements,\n        property: \"width\",\n        value: resultWidth\n      });\n    });\n  }\n\n  _updateColumnsWidth($table, frameIndex) {\n    var determinantElements = this._getTableDeterminantElements($table);\n\n    var frame = this._tableResizeFrames[frameIndex];\n\n    if (!frame) {\n      this._tableResizeFrames[frameIndex] = {};\n    }\n\n    frame = this._tableResizeFrames[frameIndex];\n    var tableWidth = this._tableLastWidth(frame) || getOuterWidth($table);\n    var ratio;\n\n    var {\n      columnsWidths: columnsWidths,\n      columnsSum: columnsSum\n    } = this._getColumnElementsSum(determinantElements);\n\n    var minWidthForColumns = determinantElements.length * this._minColumnWidth;\n\n    if (columnsSum > minWidthForColumns) {\n      ratio = (tableWidth - minWidthForColumns) / (columnsSum - minWidthForColumns);\n    } else {\n      ratio = -1;\n    }\n\n    this._tableLastWidth(frame, ratio > 0 ? tableWidth : minWidthForColumns);\n\n    this._setColumnsRatioWidth(determinantElements, ratio, columnsWidths, $table);\n  }\n\n  _updateTablesColumnsWidth($tables) {\n    each($tables, (index, table) => {\n      this._updateColumnsWidth($(table), index);\n    });\n  }\n\n  option(option, value) {\n    if (\"tableResizing\" === option) {\n      this.handleOptionChangeValue(value);\n      return;\n    }\n\n    if (\"enabled\" === option) {\n      this.enabled = value;\n      value ? this._applyResizing(true) : this.clean();\n    } else if ([\"minColumnWidth\", \"minRowHeight\"].includes(option)) {\n      this[\"_\".concat(option)] = this._minSizeLimit(option, value);\n    }\n  }\n\n  clean() {\n    this._removeResizeFrames(true);\n\n    this._detachEvents();\n\n    _windowResizeCallbacks.remove(this._resizeHandlerWithContext);\n\n    clearTimeout(this._windowResizeTimeout);\n    this._resizeHandlerWithContext = void 0;\n    this._isDragging = void 0;\n    this._startTableWidth = void 0;\n    clearTimeout(this._attachResizerTimeout);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}