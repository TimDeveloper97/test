{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/settingsGenerator.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { isEmptyObject } from \"../../../core/utils/type\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getRecurrenceProcessor } from \"../recurrence\";\nimport timeZoneUtils from \"../utils.timeZone\";\nimport { createResourcesTree, getDataAccessors, getGroupCount, getResourceTreeLeaves } from \"../resources/utils\";\nimport { createAppointmentAdapter } from \"../appointmentAdapter\";\nimport { CellPositionCalculator } from \"./cellPositionCalculator\";\nimport { ExpressionUtils } from \"../expressionUtils\";\nimport { isDateAndTimeView } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { createFormattedDateText } from \"./textUtils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar APPOINTMENT_DATE_TEXT_FORMAT = \"TIME\";\nexport class DateGeneratorBaseStrategy {\n  constructor(options) {\n    this.options = options;\n  }\n\n  get rawAppointment() {\n    return this.options.rawAppointment;\n  }\n\n  get timeZoneCalculator() {\n    return this.options.timeZoneCalculator;\n  }\n\n  get viewDataProvider() {\n    return this.options.viewDataProvider;\n  }\n\n  get appointmentTakesAllDay() {\n    return this.options.appointmentTakesAllDay;\n  }\n\n  get supportAllDayRow() {\n    return this.options.supportAllDayRow;\n  }\n\n  get isAllDayRowAppointment() {\n    return this.options.isAllDayRowAppointment;\n  }\n\n  get timeZone() {\n    return this.options.timeZone;\n  }\n\n  get dateRange() {\n    return this.options.dateRange;\n  }\n\n  get firstDayOfWeek() {\n    return this.options.firstDayOfWeek;\n  }\n\n  get viewStartDayHour() {\n    return this.options.viewStartDayHour;\n  }\n\n  get viewEndDayHour() {\n    return this.options.viewEndDayHour;\n  }\n\n  get endViewDate() {\n    return this.options.endViewDate;\n  }\n\n  get viewType() {\n    return this.options.viewType;\n  }\n\n  get isGroupedByDate() {\n    return this.options.isGroupedByDate;\n  }\n\n  get isVerticalOrientation() {\n    return this.options.isVerticalGroupOrientation;\n  }\n\n  get dataAccessors() {\n    return this.options.dataAccessors;\n  }\n\n  get loadedResources() {\n    return this.options.loadedResources;\n  }\n\n  get isDateAppointment() {\n    return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n  }\n\n  getIntervalDuration() {\n    return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration;\n  }\n\n  generate(appointmentAdapter) {\n    var itemGroupIndices = this._getGroupIndices(this.rawAppointment);\n\n    var appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);\n\n    appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);\n\n    if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\n      appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter);\n    }\n\n    var dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);\n\n    dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, this.rawAppointment);\n    dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);\n\n    if (this._needSeparateLongParts()) {\n      dateSettings = this._separateLongParts(dateSettings, appointmentAdapter);\n    }\n\n    var {\n      isRecurrent: isRecurrent\n    } = appointmentAdapter;\n    return {\n      dateSettings: dateSettings,\n      itemGroupIndices: itemGroupIndices,\n      isRecurrent: isRecurrent\n    };\n  }\n\n  _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\n    var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\n\n    if (hasAppointmentTimeZone) {\n      var appointmentOffsets = {\n        startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\n        endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\n      };\n      appointmentList.forEach(a => {\n        var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\n            sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\n        var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\n        var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\n\n        if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\n          a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"));\n        }\n\n        if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\n          a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"));\n        }\n      });\n    }\n\n    return appointmentList;\n  }\n\n  _createAppointments(appointment, groupIndices) {\n    var appointments = this._createRecurrenceAppointments(appointment, groupIndices);\n\n    if (!appointment.isRecurrent && 0 === appointments.length) {\n      appointments.push({\n        startDate: appointment.startDate,\n        endDate: appointment.endDate\n      });\n    }\n\n    appointments = appointments.map(item => {\n      var _item$endDate;\n\n      var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\n\n      if (item.startDate.getTime() === resultEndTime) {\n        item.endDate.setTime(resultEndTime + toMs(\"minute\"));\n      }\n\n      return _extends({}, item, {\n        exceptionDate: new Date(item.startDate)\n      });\n    });\n    return appointments;\n  }\n\n  _canProcessNotNativeTimezoneDates(appointment) {\n    var isTimeZoneSet = !isEmptyObject(this.timeZone);\n\n    if (!isTimeZoneSet) {\n      return false;\n    }\n\n    if (!appointment.isRecurrent) {\n      return false;\n    }\n\n    return !timeZoneUtils.isEqualLocalTimeZone(this.timeZone, appointment.startDate);\n  }\n\n  _getProcessedNotNativeDateIfCrossDST(date, offset) {\n    if (offset < 0) {\n      var newDate = new Date(date);\n      var newDateMinusOneHour = new Date(newDate);\n      newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\n      var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\n      var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\n\n      if (newDateOffset !== newDateMinusOneHourOffset) {\n        return 0;\n      }\n    }\n\n    return offset;\n  }\n\n  _getCommonOffset(date) {\n    return this.timeZoneCalculator.getOffsets(date).common;\n  }\n\n  _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\n    return appointmentList.map(item => {\n      var diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);\n\n      var diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);\n\n      if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\n        return item;\n      }\n\n      diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\n      diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\n      var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\n      var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\n      var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\n        path: \"toGrid\"\n      });\n      var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\n        path: \"toGrid\"\n      });\n\n      if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\n        newEndDate = new Date(newStartDate.getTime() + appointment.duration);\n      }\n\n      return _extends({}, item, {\n        startDate: newStartDate,\n        endDate: newEndDate,\n        exceptionDate: new Date(newStartDate)\n      });\n    });\n  }\n\n  _needSeparateLongParts() {\n    return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay;\n  }\n\n  normalizeEndDateByViewEnd(rawAppointment, endDate) {\n    var result = new Date(endDate.getTime());\n    var isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n\n    if (!isAllDay) {\n      var roundedEndViewDate = dateUtils.roundToHour(this.endViewDate);\n\n      if (result > roundedEndViewDate) {\n        result = roundedEndViewDate;\n      }\n    }\n\n    var endDayHour = this.viewEndDayHour;\n    var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", rawAppointment);\n    var currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));\n\n    if (result.getTime() > currentViewEndTime.getTime() || allDay && result.getHours() < endDayHour) {\n      result = currentViewEndTime;\n    }\n\n    return result;\n  }\n\n  _fillNormalizedEndDate(dateSettings, rawAppointment) {\n    return dateSettings.map(item => {\n      var {\n        endDate: endDate\n      } = item;\n      var normalizedEndDate = this.normalizeEndDateByViewEnd(rawAppointment, endDate);\n      return _extends({}, item, {\n        normalizedEndDate: normalizedEndDate\n      });\n    });\n  }\n\n  _separateLongParts(gridAppointmentList, appointmentAdapter) {\n    var result = [];\n    gridAppointmentList.forEach(gridAppointment => {\n      var maxDate = new Date(this.dateRange[1]);\n      var {\n        normalizedEndDate: endDateOfPart\n      } = gridAppointment;\n      var longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\n        milliseconds: this.getIntervalDuration(this.appointmentTakesAllDay)\n      });\n      var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => {\n        var endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));\n        var normalizedEndDate = this.normalizeEndDateByViewEnd(this.rawAppointment, endDate);\n        return {\n          startDate: date,\n          endDate: endDate,\n          normalizedEndDate: normalizedEndDate,\n          source: gridAppointment.source\n        };\n      });\n      result = result.concat(list);\n    });\n    return result;\n  }\n\n  _createGridAppointmentList(appointmentList, appointment) {\n    return appointmentList.map(source => {\n      var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\n\n      if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointment)) {\n        source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.exceptionDate = new Date(source.startDate);\n      }\n\n      var startDate = this.timeZoneCalculator.createDate(source.startDate, {\n        path: \"toGrid\"\n      });\n      var endDate = this.timeZoneCalculator.createDate(source.endDate, {\n        path: \"toGrid\"\n      });\n      return {\n        startDate: startDate,\n        endDate: endDate,\n        source: source\n      };\n    });\n  }\n\n  _createExtremeRecurrenceDates() {\n    var startViewDate = this.appointmentTakesAllDay ? dateUtils.trimTime(this.dateRange[0]) : this.dateRange[0];\n    var endViewDateByEndDayHour = this.dateRange[1];\n\n    if (this.timeZone) {\n      startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\n        path: \"fromGrid\"\n      });\n      endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {\n        path: \"fromGrid\"\n      });\n      var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);\n\n      if (daylightOffset) {\n        endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset);\n      }\n    }\n\n    return [startViewDate, endViewDateByEndDayHour];\n  }\n\n  _createRecurrenceOptions(appointment, groupIndex) {\n    var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(groupIndex);\n\n    return {\n      rule: appointment.recurrenceRule,\n      exception: appointment.recurrenceException,\n      min: minRecurrenceDate,\n      max: maxRecurrenceDate,\n      firstDayOfWeek: this.firstDayOfWeek,\n      start: appointment.startDate,\n      end: appointment.endDate,\n      appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(appointment.startDate, appointment.rawAppointment.startDateTimeZone, true),\n      getPostProcessedException: date => {\n        if (isEmptyObject(this.timeZone) || timeZoneUtils.isEqualLocalTimeZone(this.timeZone, date)) {\n          return date;\n        }\n\n        var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\n        var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\n        var diff = appointmentOffset - exceptionAppointmentOffset;\n        diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\n        return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"));\n      }\n    };\n  }\n\n  _createRecurrenceAppointments(appointment, groupIndices) {\n    var {\n      duration: duration\n    } = appointment;\n\n    var option = this._createRecurrenceOptions(appointment);\n\n    var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n    return generatedStartDates.map(date => {\n      var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n      utcDate.setTime(utcDate.getTime() + duration);\n      var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n      return {\n        startDate: new Date(date),\n        endDate: endDate\n      };\n    });\n  }\n\n  _cropAppointmentsByStartDayHour(appointments, rawAppointment) {\n    return appointments.filter(appointment => {\n      var firstViewDate = this._getAppointmentFirstViewDate(appointment);\n\n      if (!firstViewDate) {\n        return false;\n      }\n\n      var startDayHour = this._getViewStartDayHour(firstViewDate);\n\n      var startDate = new Date(appointment.startDate);\n      appointment.startDate = this._getAppointmentResultDate({\n        appointment: appointment,\n        rawAppointment: rawAppointment,\n        startDate: startDate,\n        startDayHour: startDayHour,\n        firstViewDate: firstViewDate\n      });\n      return !this.isAllDayRowAppointment ? appointment.endDate > appointment.startDate : true;\n    });\n  }\n\n  _getViewStartDayHour() {\n    return this.viewStartDayHour;\n  }\n\n  _getAppointmentResultDate(options) {\n    var {\n      appointment: appointment,\n      startDayHour: startDayHour,\n      firstViewDate: firstViewDate\n    } = options;\n    var {\n      startDate: startDate\n    } = options;\n    var resultDate = new Date(appointment.startDate);\n\n    if (this.appointmentTakesAllDay) {\n      resultDate = dateUtils.normalizeDate(startDate, firstViewDate);\n    } else {\n      if (startDate < firstViewDate) {\n        startDate = firstViewDate;\n      }\n\n      resultDate = dateUtils.normalizeDate(appointment.startDate, startDate);\n    }\n\n    return !this.isDateAppointment ? dateUtils.roundDateByStartDayHour(resultDate, startDayHour) : resultDate;\n  }\n\n  _getAppointmentFirstViewDate(appointment) {\n    var groupIndex = appointment.source.groupIndex || 0;\n    var {\n      startDate: startDate,\n      endDate: endDate\n    } = appointment;\n    return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isAllDayRowAppointment, this.isDateAppointment);\n  }\n\n  _getGroupIndices(rawAppointment) {\n    var result = [];\n\n    if (rawAppointment && this.loadedResources.length) {\n      var tree = createResourcesTree(this.loadedResources);\n      result = getResourceTreeLeaves((field, action) => getDataAccessors(this.options.dataAccessors.resources, field, action), tree, rawAppointment);\n    }\n\n    return result;\n  }\n\n}\nexport class DateGeneratorVirtualStrategy extends DateGeneratorBaseStrategy {\n  get groupCount() {\n    return getGroupCount(this.loadedResources);\n  }\n\n  _createRecurrenceAppointments(appointment, groupIndices) {\n    var {\n      duration: duration\n    } = appointment;\n    var result = [];\n    var validGroupIndices = this.groupCount ? groupIndices : [0];\n    validGroupIndices.forEach(groupIndex => {\n      var option = this._createRecurrenceOptions(appointment, groupIndex);\n\n      var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n      var recurrentInfo = generatedStartDates.map(date => {\n        var startDate = new Date(date);\n        var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n        utcDate.setTime(utcDate.getTime() + duration);\n        var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          groupIndex: groupIndex\n        };\n      });\n      result.push(...recurrentInfo);\n    });\n    return result;\n  }\n\n  _getViewStartDayHour(firstViewDate) {\n    return firstViewDate.getHours();\n  }\n\n  _updateGroupIndices(appointments, groupIndices) {\n    var result = [];\n    groupIndices.forEach(groupIndex => {\n      var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\n\n      if (groupStartDate) {\n        appointments.forEach(appointment => {\n          var appointmentCopy = extend({}, appointment);\n          appointmentCopy.groupIndex = groupIndex;\n          result.push(appointmentCopy);\n        });\n      }\n    });\n    return result;\n  }\n\n  _getGroupIndices(resources) {\n    var _groupIndices;\n\n    var groupIndices = super._getGroupIndices(resources);\n\n    var viewDataGroupIndices = this.viewDataProvider.getGroupIndices();\n\n    if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\n      groupIndices = [0];\n    }\n\n    return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex));\n  }\n\n  _createAppointments(appointment, groupIndices) {\n    var appointments = super._createAppointments(appointment, groupIndices);\n\n    return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments;\n  }\n\n}\nexport class AppointmentSettingsGenerator {\n  constructor(options) {\n    this.options = options;\n    this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator);\n  }\n\n  get rawAppointment() {\n    return this.options.rawAppointment;\n  }\n\n  get dataAccessors() {\n    return this.options.dataAccessors;\n  }\n\n  get timeZoneCalculator() {\n    return this.options.timeZoneCalculator;\n  }\n\n  get isAllDayRowAppointment() {\n    return this.options.appointmentTakesAllDay && this.options.supportAllDayRow;\n  }\n\n  get groups() {\n    return this.options.groups;\n  }\n\n  get dateSettingsStrategy() {\n    var options = _extends({}, this.options, {\n      isAllDayRowAppointment: this.isAllDayRowAppointment\n    });\n\n    return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options) : new DateGeneratorBaseStrategy(options);\n  }\n\n  create() {\n    var {\n      dateSettings: dateSettings,\n      itemGroupIndices: itemGroupIndices,\n      isRecurrent: isRecurrent\n    } = this._generateDateSettings();\n\n    var cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);\n\n    var result = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);\n\n    return result;\n  }\n\n  _generateDateSettings() {\n    return this.dateSettingsStrategy.generate(this.appointmentAdapter);\n  }\n\n  _calculateCellPositions(dateSettings, itemGroupIndices) {\n    var cellPositionCalculator = new CellPositionCalculator(_extends({}, this.options, {\n      dateSettings: dateSettings\n    }));\n    return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent);\n  }\n\n  _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {\n    var infos = [];\n    cellPositions.forEach(_ref => {\n      var {\n        coordinates: coordinates,\n        dateSettingIndex: dateSettingIndex\n      } = _ref;\n      var dateSetting = dateSettings[dateSettingIndex];\n\n      var dateText = this._getAppointmentDateText(dateSetting);\n\n      var info = {\n        appointment: dateSetting,\n        sourceAppointment: dateSetting.source,\n        dateText: dateText,\n        isRecurrent: isRecurrent\n      };\n      infos.push(_extends({}, coordinates, {\n        info: info\n      }));\n    });\n    return infos;\n  }\n\n  _getAppointmentDateText(sourceAppointment) {\n    var {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay\n    } = sourceAppointment;\n    return createFormattedDateText({\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay,\n      format: APPOINTMENT_DATE_TEXT_FORMAT\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}