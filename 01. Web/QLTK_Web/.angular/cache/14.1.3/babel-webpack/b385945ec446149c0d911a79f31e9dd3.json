{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, NgModule, Component, Injectable, PLATFORM_ID, Inject, VERSION, Optional } from '@angular/core';\nimport { isPlatformServer, DOCUMENT } from '@angular/common';\nimport * as i3 from '@angular/platform-browser';\nimport { makeStateKey, BrowserTransferStateModule } from '@angular/platform-browser';\nimport domAdapter from 'devextreme/core/dom_adapter';\nimport { one, triggerHandler } from 'devextreme/events';\nimport render from 'devextreme/core/renderer';\nimport { equalByValue } from 'devextreme/core/utils/common';\nimport httpRequest from 'devextreme/core/http_request';\nimport readyCallbacks from 'devextreme/core/utils/ready_callbacks';\nimport eventsEngine from 'devextreme/events/core/events_engine';\nimport * as i1 from '@angular/common/http';\nimport ajax from 'devextreme/core/utils/ajax';\nimport { Deferred } from 'devextreme/core/utils/deferred';\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\nclass NgEventsStrategy {\n  constructor(instance, zone) {\n    this.instance = instance;\n    this.zone = zone;\n    this.subscriptions = {};\n    this.events = {};\n  }\n\n  hasEvent(name) {\n    return this.getEmitter(name).observers.length !== 0;\n  }\n\n  fireEvent(name, args) {\n    let emitter = this.getEmitter(name);\n\n    if (emitter.observers.length) {\n      const internalSubs = this.subscriptions[name] || [];\n\n      if (internalSubs.length === emitter.observers.length) {\n        emitter.next(args && args[0]);\n      } else {\n        this.zone.run(() => emitter.next(args && args[0]));\n      }\n    }\n  }\n\n  on(name, handler) {\n    if (typeof name === 'string') {\n      let eventSubscriptions = this.subscriptions[name] || [],\n          subcription = this.getEmitter(name).subscribe(handler.bind(this.instance)),\n          unsubscribe = subcription.unsubscribe.bind(subcription);\n      eventSubscriptions.push({\n        handler,\n        unsubscribe\n      });\n      this.subscriptions[name] = eventSubscriptions;\n    } else {\n      let handlersObj = name;\n      Object.keys(handlersObj).forEach(event => this.on(event, handlersObj[event]));\n    }\n  }\n\n  off(name, handler) {\n    let eventSubscriptions = this.subscriptions[name] || [];\n\n    if (handler) {\n      eventSubscriptions.some((subscription, i) => {\n        if (subscription.handler === handler) {\n          subscription.unsubscribe();\n          eventSubscriptions.splice(i, 1);\n          return true;\n        }\n      });\n    } else {\n      eventSubscriptions.forEach(subscription => {\n        subscription.unsubscribe();\n      });\n      eventSubscriptions.splice(0, eventSubscriptions.length);\n    }\n  }\n\n  dispose() {}\n\n  addEmitter(eventName, emitter) {\n    this.events[eventName] = emitter;\n  }\n\n  getEmitter(eventName) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new EventEmitter();\n    }\n\n    return this.events[eventName];\n  }\n\n}\n\nclass EmitterHelper {\n  constructor(zone, component) {\n    this.zone = zone;\n    this.component = component;\n    this.lockedValueChangeEvent = false;\n  }\n\n  fireNgEvent(eventName, eventArgs) {\n    if (this.lockedValueChangeEvent && eventName === 'valueChange') {\n      return;\n    }\n\n    let emitter = this.component[eventName];\n\n    if (emitter && emitter.observers.length) {\n      this.zone.run(() => {\n        emitter.next(eventArgs && eventArgs[0]);\n      });\n    }\n  }\n\n  createEmitters(events) {\n    events.forEach(event => {\n      this.component[event.emit] = new EventEmitter();\n    });\n  }\n\n}\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n\nfunction getElement(element) {\n  return element.get ? element.get(0) : element;\n}\n\n;\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n;\n\nclass DxTemplateHost {\n  setHost(host) {\n    this.host = host;\n  }\n\n  setTemplate(template) {\n    this.host.setTemplate(template);\n  }\n\n}\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n\nconst DX_TEMPLATE_WRAPPER_CLASS = 'dx-template-wrapper';\n\nclass RenderData {}\n\nlet DxTemplateDirective = /*#__PURE__*/(() => {\n  class DxTemplateDirective {\n    constructor(templateRef, viewContainerRef, templateHost, renderer, zone) {\n      this.templateRef = templateRef;\n      this.viewContainerRef = viewContainerRef;\n      this.renderer = renderer;\n      this.zone = zone;\n      templateHost.setTemplate(this);\n    }\n\n    set dxTemplateOf(value) {\n      this.name = value;\n    }\n\n    renderTemplate(renderData) {\n      const childView = this.viewContainerRef.createEmbeddedView(this.templateRef, {\n        '$implicit': renderData.model,\n        index: renderData.index\n      });\n      const container = getElement(renderData.container);\n\n      if (renderData.container) {\n        childView.rootNodes.forEach(element => {\n          this.renderer.appendChild(container, element);\n        });\n      }\n\n      return childView;\n    }\n\n    render(renderData) {\n      let childView;\n\n      if (this.zone.isStable) {\n        childView = this.zone.run(() => {\n          return this.renderTemplate(renderData);\n        });\n      } else {\n        childView = this.renderTemplate(renderData);\n      } // =========== WORKAROUND =============\n      // https://github.com/angular/angular/issues/12243\n\n\n      childView['detectChanges'](); // =========== /WORKAROUND =============\n\n      childView.rootNodes.forEach(element => {\n        if (element.nodeType === 1) {\n          domAdapter.setClass(element, DX_TEMPLATE_WRAPPER_CLASS, true);\n        }\n\n        one(element, 'dxremove', ({}, params) => {\n          if (!params || !params._angularIntegration) {\n            childView.destroy();\n          }\n        });\n      });\n      return childView.rootNodes;\n    }\n\n  }\n\n  /** @nocollapse */\n  DxTemplateDirective.ɵfac = function DxTemplateDirective_Factory(t) {\n    return new (t || DxTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(DxTemplateHost), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  DxTemplateDirective.ɵdir =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineDirective({\n    type: DxTemplateDirective,\n    selectors: [[\"\", \"dxTemplate\", \"\"]],\n    inputs: {\n      dxTemplateOf: \"dxTemplateOf\"\n    }\n  });\n  return DxTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DxTemplateModule = /*#__PURE__*/(() => {\n  class DxTemplateModule {}\n\n  /** @nocollapse */\n  DxTemplateModule.ɵfac = function DxTemplateModule_Factory(t) {\n    return new (t || DxTemplateModule)();\n  };\n  /** @nocollapse */\n\n\n  DxTemplateModule.ɵmod =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineNgModule({\n    type: DxTemplateModule\n  });\n  /** @nocollapse */\n\n  DxTemplateModule.ɵinj =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjector({});\n  return DxTemplateModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(DxTemplateModule, {\n    declarations: [DxTemplateDirective],\n    exports: [DxTemplateDirective]\n  });\n})();\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n\nconst VISIBILITY_CHANGE_SELECTOR = 'dx-visibility-change-handler';\nlet BaseNestedOption = /*#__PURE__*/(() => {\n  class BaseNestedOption {\n    constructor() {\n      this._initialOptions = {};\n      this._collectionContainerImpl = new CollectionNestedOptionContainerImpl(this._setOption.bind(this), this._filterItems.bind(this));\n    }\n\n    _optionChangedHandler(e) {\n      let fullOptionPath = this._fullOptionPath();\n\n      if (e.fullName.indexOf(fullOptionPath) === 0) {\n        let optionName = e.fullName.slice(fullOptionPath.length);\n        let emitter = this[optionName + 'Change'];\n\n        if (emitter) {\n          emitter.next(e.value);\n        }\n      }\n    }\n\n    _createEventEmitters(events) {\n      events.forEach(event => {\n        this[event.emit] = new EventEmitter();\n      });\n    }\n\n    _getOption(name) {\n      if (this.isLinked) {\n        return this.instance.option(this._fullOptionPath() + name);\n      } else {\n        return this._initialOptions[name];\n      }\n    }\n\n    _setOption(name, value) {\n      if (this.isLinked) {\n        const fullPath = this._fullOptionPath() + name;\n        this.instance.option(fullPath, value);\n      } else {\n        this._initialOptions[name] = value;\n      }\n    }\n\n    _addRemovedOption(name) {\n      if (this.instance && this.removedNestedComponents) {\n        this.removedNestedComponents.push(name);\n      }\n    }\n\n    _deleteRemovedOptions(name) {\n      if (this.instance && this.removedNestedComponents) {\n        this.removedNestedComponents = this.removedNestedComponents.filter(x => !x.startsWith(name));\n      }\n    }\n\n    _addRecreatedComponent() {\n      if (this.instance && this.recreatedNestedComponents) {\n        this.recreatedNestedComponents.push({\n          getOptionPath: () => this._getOptionPath()\n        });\n      }\n    }\n\n    _getOptionPath() {\n      return this._hostOptionPath() + this._optionPath;\n    }\n\n    setHost(host, optionPath) {\n      this._host = host;\n      this._hostOptionPath = optionPath;\n      this.optionChangedHandlers.subscribe(this._optionChangedHandler.bind(this));\n    }\n\n    setChildren(propertyName, items) {\n      this.resetOptions(propertyName);\n      return this._collectionContainerImpl.setChildren(propertyName, items);\n    }\n\n    _filterItems(items) {\n      return items.filter(item => {\n        return item !== this;\n      });\n    }\n\n    get instance() {\n      return this._host && this._host.instance;\n    }\n\n    get resetOptions() {\n      return this._host && this._host.resetOptions;\n    }\n\n    get isRecreated() {\n      return this._host && this._host.isRecreated;\n    }\n\n    get removedNestedComponents() {\n      return this._host && this._host.removedNestedComponents;\n    }\n\n    set removedNestedComponents(value) {\n      this._host.removedNestedComponents = value;\n    }\n\n    get recreatedNestedComponents() {\n      return this._host && this._host.recreatedNestedComponents;\n    }\n\n    set recreatedNestedComponents(value) {\n      this._host.recreatedNestedComponents = value;\n    }\n\n    get isLinked() {\n      return !!this.instance && this._host.isLinked;\n    }\n\n    get optionChangedHandlers() {\n      return this._host && this._host.optionChangedHandlers;\n    }\n\n  }\n\n  /** @nocollapse */\n  BaseNestedOption.ɵfac = function BaseNestedOption_Factory(t) {\n    return new (t || BaseNestedOption)();\n  };\n  /** @nocollapse */\n\n\n  BaseNestedOption.ɵcmp =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineComponent({\n    type: BaseNestedOption,\n    selectors: [[\"ng-component\"]],\n    decls: 0,\n    vars: 0,\n    template: function BaseNestedOption_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return BaseNestedOption;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass CollectionNestedOptionContainerImpl {\n  constructor(_setOption, _filterItems) {\n    this._setOption = _setOption;\n    this._filterItems = _filterItems;\n    this._activatedQueries = {};\n  }\n\n  setChildren(propertyName, items) {\n    if (this._filterItems) {\n      items = this._filterItems(items);\n    }\n\n    if (items.length) {\n      this._activatedQueries[propertyName] = true;\n    }\n\n    if (this._activatedQueries[propertyName]) {\n      let widgetItems = items.map((item, index) => {\n        item._index = index;\n        return item._value;\n      });\n\n      this._setOption(propertyName, widgetItems);\n    }\n  }\n\n}\n\nlet NestedOption = /*#__PURE__*/(() => {\n  class NestedOption extends BaseNestedOption {\n    setHost(host, optionPath) {\n      super.setHost(host, optionPath);\n      this._host[this._optionPath] = this._initialOptions;\n    }\n\n    _fullOptionPath() {\n      return this._getOptionPath() + '.';\n    }\n\n  }\n\n  /** @nocollapse */\n  NestedOption.ɵfac =\n  /** @pureOrBreakMyCode */\n  function () {\n    let ɵNestedOption_BaseFactory;\n    return function NestedOption_Factory(t) {\n      return (ɵNestedOption_BaseFactory || (ɵNestedOption_BaseFactory = i0.ɵɵgetInheritedFactory(NestedOption)))(t || NestedOption);\n    };\n  }();\n  /** @nocollapse */\n\n\n  NestedOption.ɵcmp =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineComponent({\n    type: NestedOption,\n    selectors: [[\"ng-component\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function NestedOption_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return NestedOption;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CollectionNestedOption = /*#__PURE__*/(() => {\n  class CollectionNestedOption extends BaseNestedOption {\n    _fullOptionPath() {\n      return `${this._getOptionPath()}[${this._index}].`;\n    }\n\n    get _value() {\n      return this._initialOptions;\n    }\n\n    get isLinked() {\n      return this._index !== undefined && !!this.instance && this._host.isLinked;\n    }\n\n  }\n\n  /** @nocollapse */\n  CollectionNestedOption.ɵfac =\n  /** @pureOrBreakMyCode */\n  function () {\n    let ɵCollectionNestedOption_BaseFactory;\n    return function CollectionNestedOption_Factory(t) {\n      return (ɵCollectionNestedOption_BaseFactory || (ɵCollectionNestedOption_BaseFactory = i0.ɵɵgetInheritedFactory(CollectionNestedOption)))(t || CollectionNestedOption);\n    };\n  }();\n  /** @nocollapse */\n\n\n  CollectionNestedOption.ɵcmp =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineComponent({\n    type: CollectionNestedOption,\n    selectors: [[\"ng-component\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function CollectionNestedOption_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return CollectionNestedOption;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet triggerShownEvent = function (element) {\n  let changeHandlers = [];\n\n  if (!render(element).hasClass(VISIBILITY_CHANGE_SELECTOR)) {\n    changeHandlers.push(element);\n  }\n\n  changeHandlers.push.apply(changeHandlers, element.querySelectorAll('.' + VISIBILITY_CHANGE_SELECTOR));\n\n  for (let i = 0; i < changeHandlers.length; i++) {\n    triggerHandler(changeHandlers[i], 'dxshown');\n  }\n};\n\nfunction extractTemplate(option, element, renderer, document) {\n  if (!option.template === undefined || !element.nativeElement.hasChildNodes()) {\n    return;\n  }\n\n  let childNodes = [].slice.call(element.nativeElement.childNodes);\n  let userContent = childNodes.filter(n => {\n    if (n.tagName) {\n      let tagNamePrefix = n.tagName.toLowerCase().substr(0, 3);\n      return !(tagNamePrefix === 'dxi' || tagNamePrefix === 'dxo');\n    } else {\n      return n.nodeName !== '#comment' && n.textContent.replace(/\\s/g, '').length;\n    }\n  });\n\n  if (!userContent.length) {\n    return;\n  }\n\n  option.template = {\n    render: renderData => {\n      let result = element.nativeElement;\n      domAdapter.setClass(result, DX_TEMPLATE_WRAPPER_CLASS, true);\n\n      if (renderData.container) {\n        let container = getElement(renderData.container);\n        let resultInContainer = container.contains(element.nativeElement);\n        renderer.appendChild(container, element.nativeElement);\n\n        if (!resultInContainer) {\n          let resultInBody = document.body.contains(container);\n\n          if (resultInBody) {\n            triggerShownEvent(result);\n          }\n        }\n      }\n\n      return result;\n    }\n  };\n}\n\nclass NestedOptionHost {\n  getHost() {\n    return this._host;\n  }\n\n  setHost(host, optionPath) {\n    this._host = host;\n\n    this._optionPath = optionPath || (() => '');\n  }\n\n  setNestedOption(nestedOption) {\n    nestedOption.setHost(this._host, this._optionPath);\n  }\n\n}\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n\nlet WatcherHelper = /*#__PURE__*/(() => {\n  class WatcherHelper {\n    constructor() {\n      this._watchers = [];\n    }\n\n    getWatchMethod() {\n      let watchMethod = (valueGetter, valueChangeCallback, options) => {\n        let oldValue = valueGetter();\n        options = options || {};\n\n        if (!options.skipImmediate) {\n          valueChangeCallback(oldValue);\n        }\n\n        let watcher = () => {\n          let newValue = valueGetter();\n\n          if (this._isDifferentValues(oldValue, newValue, options.deep)) {\n            valueChangeCallback(newValue);\n            oldValue = newValue;\n          }\n        };\n\n        this._watchers.push(watcher);\n\n        return () => {\n          let index = this._watchers.indexOf(watcher);\n\n          if (index !== -1) {\n            this._watchers.splice(index, 1);\n          }\n        };\n      };\n\n      return watchMethod;\n    }\n\n    _isDifferentValues(oldValue, newValue, deepCheck) {\n      let comparableNewValue = this._toComparable(newValue);\n\n      let comparableOldValue = this._toComparable(oldValue);\n\n      let isObjectValues = comparableNewValue instanceof Object && comparableOldValue instanceof Object;\n\n      if (deepCheck && isObjectValues) {\n        return this._checkObjectsFields(newValue, oldValue);\n      }\n\n      return comparableNewValue !== comparableOldValue;\n    }\n\n    _toComparable(value) {\n      if (value instanceof Date) {\n        return value.getTime();\n      }\n\n      return value;\n    }\n\n    _checkObjectsFields(checkingFromObject, checkingToObject) {\n      for (let field in checkingFromObject) {\n        let oldValue = this._toComparable(checkingFromObject[field]);\n\n        let newValue = this._toComparable(checkingToObject[field]);\n\n        let isEqualObjects = false;\n\n        if (typeof oldValue === 'object' && typeof newValue === 'object') {\n          isEqualObjects = equalByValue(oldValue, newValue);\n        }\n\n        if (oldValue !== newValue && !isEqualObjects) {\n          return true;\n        }\n      }\n    }\n\n    checkWatchers() {\n      for (let watcher of this._watchers) {\n        watcher();\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  WatcherHelper.ɵfac = function WatcherHelper_Factory(t) {\n    return new (t || WatcherHelper)();\n  };\n  /** @nocollapse */\n\n\n  WatcherHelper.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: WatcherHelper,\n    factory: WatcherHelper.ɵfac\n  });\n  return WatcherHelper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n\nlet serverStateKey;\n\nconst getServerStateKey = () => {\n  if (!serverStateKey) {\n    serverStateKey = makeStateKey('DX_isPlatformServer');\n  }\n\n  return serverStateKey;\n};\n\nlet DxComponent = /*#__PURE__*/(() => {\n  class DxComponent {\n    constructor(element, ngZone, templateHost, watcherHelper, transferState, platformId) {\n      this.element = element;\n      this.ngZone = ngZone;\n      this.watcherHelper = watcherHelper;\n      this.transferState = transferState;\n      this.platformId = platformId;\n      this._initialOptions = {};\n      this._optionsToUpdate = {};\n      this.optionChangedHandlers = new EventEmitter();\n      this.isLinked = true;\n      this.changedOptions = {};\n      this.removedNestedComponents = [];\n      this.widgetUpdateLocked = false;\n      this.templates = [];\n      templateHost.setHost(this);\n      this._collectionContainerImpl = new CollectionNestedOptionContainerImpl(this._setOption.bind(this));\n      this.eventHelper = new EmitterHelper(ngZone, this);\n    }\n\n    _initTemplates() {\n      if (this.templates.length) {\n        let initialTemplates = {};\n        this.templates.forEach(template => {\n          initialTemplates[template.name] = template;\n        });\n        this.instance.option('integrationOptions.templates', initialTemplates);\n      }\n    }\n\n    _initEvents() {\n      this.instance.on('optionChanged', e => {\n        this.changedOptions[e.name] = e.value;\n        const value = e.name === e.fullName ? e.value : e.component.option(e.name);\n        this.eventHelper.fireNgEvent(e.name + 'Change', [value]);\n        this.optionChangedHandlers.emit(e);\n      });\n    }\n\n    _initOptions() {\n      this._initialOptions.integrationOptions.watchMethod = this.watcherHelper.getWatchMethod();\n    }\n\n    _initPlatform() {\n      if (this.transferState.hasKey(getServerStateKey())) {\n        this._initialOptions.integrationOptions.renderedOnServer = this.transferState.get(getServerStateKey(), null);\n      } else if (isPlatformServer(this.platformId)) {\n        this.transferState.set(getServerStateKey(), true);\n      }\n    }\n\n    _createEventEmitters(events) {\n      const zone = this.ngZone;\n      this.eventHelper.createEmitters(events);\n\n      this._initialOptions.eventsStrategy = instance => {\n        let strategy = new NgEventsStrategy(instance, zone);\n        events.filter(event => event.subscribe).forEach(event => {\n          strategy.addEmitter(event.subscribe, this[event.emit]);\n        });\n        return strategy;\n      };\n\n      this._initialOptions.nestedComponentOptions = function (component) {\n        return {\n          eventsStrategy: instance => {\n            return new NgEventsStrategy(instance, zone);\n          },\n          nestedComponentOptions: component.option('nestedComponentOptions')\n        };\n      };\n    }\n\n    _shouldOptionChange(name, value) {\n      if (this.changedOptions.hasOwnProperty(name)) {\n        const prevValue = this.changedOptions[name];\n        delete this.changedOptions[name];\n        return value !== prevValue;\n      }\n\n      return true;\n    }\n\n    clearChangedOptions() {\n      this.changedOptions = {};\n    }\n\n    _getOption(name) {\n      return this.instance ? this.instance.option(name) : this._initialOptions[name];\n    }\n\n    lockWidgetUpdate() {\n      if (!this.widgetUpdateLocked && this.instance) {\n        this.instance.beginUpdate();\n        this.widgetUpdateLocked = true;\n      }\n    }\n\n    unlockWidgetUpdate() {\n      if (this.widgetUpdateLocked) {\n        this.widgetUpdateLocked = false;\n        this.instance.endUpdate();\n      }\n    }\n\n    _setOption(name, value) {\n      this.lockWidgetUpdate();\n\n      if (!this._shouldOptionChange(name, value)) {\n        return;\n      }\n\n      if (this.instance) {\n        this.instance.option(name, value);\n      } else {\n        this._initialOptions[name] = value;\n      }\n    }\n\n    _createWidget(element) {\n      this._initialOptions.integrationOptions = {};\n\n      this._initPlatform();\n\n      this._initOptions();\n\n      this._initialOptions.onInitializing = function () {\n        this.beginUpdate();\n      };\n\n      this.instance = this._createInstance(element, this._initialOptions);\n\n      this._initEvents();\n\n      this._initialOptions = {};\n    }\n\n    _destroyWidget() {\n      this.removedNestedComponents = [];\n\n      if (this.instance) {\n        let element = this.instance.element();\n        triggerHandler(element, 'dxremove', {\n          _angularIntegration: true\n        });\n        this.instance.dispose();\n        domAdapter.removeElement(element);\n      }\n    }\n\n    ngOnChanges(changes) {\n      for (let key in changes) {\n        let change = changes[key];\n\n        if (change.currentValue !== this[key]) {\n          this._optionsToUpdate[key] = changes[key].currentValue;\n        }\n      }\n    }\n\n    ngOnInit() {\n      this._createWidget(this.element.nativeElement);\n    }\n\n    ngDoCheck() {\n      this.applyOptions();\n    }\n\n    ngAfterContentChecked() {\n      this.applyOptions();\n      this.resetOptions();\n      this.unlockWidgetUpdate();\n    }\n\n    ngAfterViewInit() {\n      this._initTemplates();\n\n      this.instance.endUpdate();\n      this.recreatedNestedComponents = [];\n    }\n\n    applyOptions() {\n      if (Object.keys(this._optionsToUpdate).length) {\n        if (this.instance) {\n          this.instance.option(this._optionsToUpdate);\n        }\n\n        this._optionsToUpdate = {};\n      }\n    }\n\n    resetOptions(collectionName) {\n      if (this.instance) {\n        this.removedNestedComponents.filter(option => option && !this.isRecreated(option) && collectionName ? option.startsWith(collectionName) : true).forEach(option => {\n          this.instance.resetOption(option);\n        });\n        this.removedNestedComponents = [];\n        this.recreatedNestedComponents = [];\n      }\n    }\n\n    isRecreated(name) {\n      return this.recreatedNestedComponents && this.recreatedNestedComponents.some(nestedComponent => nestedComponent.getOptionPath() === name);\n    }\n\n    setTemplate(template) {\n      this.templates.push(template);\n    }\n\n    setChildren(propertyName, items) {\n      this.resetOptions(propertyName);\n      return this._collectionContainerImpl.setChildren(propertyName, items);\n    }\n\n  }\n\n  /** @nocollapse */\n  DxComponent.ɵfac = function DxComponent_Factory(t) {\n    return new (t || DxComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(DxTemplateHost), i0.ɵɵdirectiveInject(WatcherHelper), i0.ɵɵdirectiveInject(i3.TransferState), i0.ɵɵdirectiveInject(PLATFORM_ID));\n  };\n  /** @nocollapse */\n\n\n  DxComponent.ɵcmp =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineComponent({\n    type: DxComponent,\n    selectors: [[\"ng-component\"]],\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function DxComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return DxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DxComponentExtension = /*#__PURE__*/(() => {\n  class DxComponentExtension extends DxComponent {\n    createInstance(element) {\n      this._createWidget(element);\n    }\n\n    ngOnInit() {}\n\n    ngAfterViewInit() {\n      this._createWidget(this.element.nativeElement);\n\n      this.instance.endUpdate();\n    }\n\n  }\n\n  /** @nocollapse */\n  DxComponentExtension.ɵfac =\n  /** @pureOrBreakMyCode */\n  function () {\n    let ɵDxComponentExtension_BaseFactory;\n    return function DxComponentExtension_Factory(t) {\n      return (ɵDxComponentExtension_BaseFactory || (ɵDxComponentExtension_BaseFactory = i0.ɵɵgetInheritedFactory(DxComponentExtension)))(t || DxComponentExtension);\n    };\n  }();\n  /** @nocollapse */\n\n\n  DxComponentExtension.ɵcmp =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineComponent({\n    type: DxComponentExtension,\n    selectors: [[\"ng-component\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function DxComponentExtension_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return DxComponentExtension;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n\nconst outsideZoneEvents = ['mousemove', 'mouseover', 'mouseout'];\nconst insideZoneEvents = ['mouseup', 'click', 'mousedown', 'transitionend', 'wheel'];\nlet originalAdd;\nlet callbacks = [];\n\nlet readyCallbackAdd = function (callback) {\n  if (!originalAdd) {\n    originalAdd = this.callBase.bind(this);\n  }\n\n  callbacks.push(callback);\n};\n\nreadyCallbacks.inject({\n  add: function (callback) {\n    return readyCallbackAdd.call(this, callback);\n  }\n});\n\nlet doInjections = (document, ngZone, xhrFactory) => {\n  if (Number(VERSION.major) < 12) {\n    console.warn(`Your version of Angular is not supported. Please update your project to version 12 or later. Please refer to the Angular Update Guide for more information: https://update.angular.io`);\n  }\n\n  domAdapter.inject({\n    _document: document,\n    listen: function (...args) {\n      const eventName = args[1];\n\n      if (outsideZoneEvents.indexOf(eventName) !== -1) {\n        return ngZone.runOutsideAngular(() => {\n          return this.callBase.apply(this, args);\n        });\n      }\n\n      if (ngZone.isStable && insideZoneEvents.indexOf(eventName) !== -1) {\n        return ngZone.run(() => {\n          return this.callBase.apply(this, args);\n        });\n      }\n\n      return this.callBase.apply(this, args);\n    },\n    isElementNode: function (element) {\n      return element && element.nodeType === 1;\n    },\n    isTextNode: function (element) {\n      return element && element.nodeType === 3;\n    },\n    isDocument: function (element) {\n      return element && element.nodeType === 9;\n    }\n  });\n  httpRequest.inject({\n    getXhr: function () {\n      if (!xhrFactory) {\n        return this.callBase.apply(this);\n      }\n\n      let _xhr = xhrFactory.build();\n\n      if (!('withCredentials' in _xhr)) {\n        _xhr['withCredentials'] = false;\n      }\n\n      return _xhr;\n    }\n  });\n\n  const runReadyCallbacksInZone = () => {\n    ngZone.run(() => {\n      eventsEngine.set({});\n      callbacks.forEach(callback => originalAdd.call(null, callback));\n      callbacks = [];\n      readyCallbacks.fire();\n    });\n  };\n\n  runReadyCallbacksInZone();\n\n  readyCallbackAdd = callback => ngZone.run(() => callback());\n\n  doInjections = runReadyCallbacksInZone;\n};\n\nlet DxIntegrationModule = /*#__PURE__*/(() => {\n  class DxIntegrationModule {\n    constructor(document, ngZone, xhrFactory) {\n      doInjections(document, ngZone, xhrFactory);\n    }\n\n  }\n\n  /** @nocollapse */\n  DxIntegrationModule.ɵfac = function DxIntegrationModule_Factory(t) {\n    return new (t || DxIntegrationModule)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.XhrFactory, 8));\n  };\n  /** @nocollapse */\n\n\n  DxIntegrationModule.ɵmod =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineNgModule({\n    type: DxIntegrationModule\n  });\n  /** @nocollapse */\n\n  DxIntegrationModule.ɵinj =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjector({});\n  return DxIntegrationModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n\nlet IterableDifferHelper = /*#__PURE__*/(() => {\n  class IterableDifferHelper {\n    constructor(_differs) {\n      this._differs = _differs;\n      this._propertyDiffers = {};\n    }\n\n    setHost(host) {\n      this._host = host;\n    }\n\n    setup(prop, changes) {\n      if (prop in changes) {\n        const value = changes[prop].currentValue;\n        this.setupSingle(prop, value);\n      }\n    }\n\n    setupSingle(prop, value) {\n      if (value && Array.isArray(value)) {\n        if (!this._propertyDiffers[prop]) {\n          try {\n            this._propertyDiffers[prop] = this._differs.find(value).create(null);\n            return true;\n          } catch (e) {}\n        }\n      } else {\n        delete this._propertyDiffers[prop];\n      }\n\n      return false;\n    }\n\n    getChanges(prop, value) {\n      if (this._propertyDiffers[prop]) {\n        return this._propertyDiffers[prop].diff(value);\n      }\n    }\n\n    checkChangedOptions(propName, hostValue) {\n      return this._host.changedOptions[propName] === hostValue;\n    }\n\n    doCheck(prop) {\n      if (this._propertyDiffers[prop]) {\n        let hostValue = this._host[prop],\n            isChangedOption = this.checkChangedOptions(prop, hostValue);\n        const changes = this.getChanges(prop, hostValue);\n\n        if (changes && this._host.instance && !isChangedOption) {\n          this._host.lockWidgetUpdate();\n\n          this._host.instance.option(prop, hostValue);\n        }\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  IterableDifferHelper.ɵfac = function IterableDifferHelper_Factory(t) {\n    return new (t || IterableDifferHelper)(i0.ɵɵinject(i0.IterableDiffers));\n  };\n  /** @nocollapse */\n\n\n  IterableDifferHelper.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: IterableDifferHelper,\n    factory: IterableDifferHelper.ɵfac\n  });\n  return IterableDifferHelper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n\nlet DxServerTransferStateModule = /*#__PURE__*/(() => {\n  class DxServerTransferStateModule {\n    constructor(state, platformId) {\n      this.state = state;\n      this.platformId = platformId;\n      let that = this;\n      ajax.inject({\n        sendRequest: function (...args) {\n          let key = makeStateKey(that.generateKey(args)),\n              cachedData = that.state.get(key, null);\n\n          if (isPlatformServer(that.platformId)) {\n            let result = this.callBase.apply(this, args);\n            result.always((data, status) => {\n              let dataForCache = {\n                data: data,\n                status: status\n              };\n              that.state.set(key, dataForCache);\n            });\n            return result;\n          } else {\n            if (cachedData) {\n              let d = Deferred();\n              d.resolve(cachedData.data, cachedData.status);\n              that.state.set(key, null);\n              return d.promise();\n            }\n\n            return this.callBase.apply(this, args);\n          }\n        }\n      });\n    }\n\n    generateKey(args) {\n      let keyValue = '';\n\n      for (let key in args) {\n        if (typeof args[key] === 'object') {\n          let objKey = this.generateKey(args[key]);\n          keyValue += key + objKey;\n        } else {\n          keyValue += key + args[key];\n        }\n      }\n\n      return keyValue;\n    }\n\n  }\n\n  /** @nocollapse */\n  DxServerTransferStateModule.ɵfac = function DxServerTransferStateModule_Factory(t) {\n    return new (t || DxServerTransferStateModule)(i0.ɵɵinject(i3.TransferState), i0.ɵɵinject(PLATFORM_ID));\n  };\n  /** @nocollapse */\n\n\n  DxServerTransferStateModule.ɵmod =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineNgModule({\n    type: DxServerTransferStateModule\n  });\n  /** @nocollapse */\n\n  DxServerTransferStateModule.ɵinj =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjector({\n    imports: [[BrowserTransferStateModule]]\n  });\n  return DxServerTransferStateModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(DxServerTransferStateModule, {\n    imports: [BrowserTransferStateModule]\n  });\n})();\n/*!\r\n * devextreme-angular\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n *\r\n * This software may be modified and distributed under the terms\r\n * of the MIT license. See the LICENSE file in the root of the project for details.\r\n *\r\n * https://github.com/DevExpress/devextreme-angular\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { BaseNestedOption, CollectionNestedOption, CollectionNestedOptionContainerImpl, DX_TEMPLATE_WRAPPER_CLASS, DxComponent, DxComponentExtension, DxIntegrationModule, DxServerTransferStateModule, DxTemplateDirective, DxTemplateHost, DxTemplateModule, EmitterHelper, IterableDifferHelper, NestedOption, NestedOptionHost, NgEventsStrategy, RenderData, WatcherHelper, extractTemplate, getElement, getServerStateKey }; //# sourceMappingURL=devextreme-angular-core.js.map","map":null,"metadata":{},"sourceType":"module"}