{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.timeline.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getOuterWidth, setHeight, getOuterHeight } from \"../../../core/utils/size\";\nimport $ from \"../../../core/renderer\";\nimport { noop } from \"../../../core/utils/common\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport registerComponent from \"../../../core/component_registrator\";\nimport SchedulerWorkSpace from \"./ui.scheduler.work_space.indicator\";\nimport dateUtils from \"../../../core/utils/date\";\nimport tableCreatorModule from \"../table_creator\";\nvar {\n  tableCreator: tableCreator\n} = tableCreatorModule;\nimport HorizontalShader from \"../shaders/ui.scheduler.current_time_shader.horizontal\";\nimport { HEADER_CURRENT_TIME_CELL_CLASS, GROUP_ROW_CLASS, GROUP_HEADER_CONTENT_CLASS } from \"../classes\";\nimport { getDateForHeaderText } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/timeline_week\";\nimport timezoneUtils from \"../utils.timeZone\";\nimport dxrTimelineDateHeader from \"../../../renovation/ui/scheduler/workspaces/timeline/header_panel/layout.j\";\nimport { formatWeekdayAndDay } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { hasWindow } from \"../../../core/utils/window\";\nvar TIMELINE_CLASS = \"dx-scheduler-timeline\";\nvar GROUP_TABLE_CLASS = \"dx-scheduler-group-table\";\nvar HORIZONTAL_GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-horizontal-grouped\";\nvar HEADER_PANEL_CELL_CLASS = \"dx-scheduler-header-panel-cell\";\nvar HEADER_PANEL_WEEK_CELL_CLASS = \"dx-scheduler-header-panel-week-cell\";\nvar HEADER_ROW_CLASS = \"dx-scheduler-header-row\";\nvar HORIZONTAL = \"horizontal\";\nvar DATE_TABLE_CELL_BORDER = 1;\nvar DATE_TABLE_HEADER_MARGIN = 10;\nvar toMs = dateUtils.dateToMilliseconds;\n\nclass SchedulerTimeline extends SchedulerWorkSpace {\n  get verticalGroupTableClass() {\n    return GROUP_TABLE_CLASS;\n  }\n\n  get viewDirection() {\n    return \"horizontal\";\n  }\n\n  get renovatedHeaderPanelComponent() {\n    return dxrTimelineDateHeader;\n  }\n\n  getGroupTableWidth() {\n    return this._$sidebarTable ? getOuterWidth(this._$sidebarTable) : 0;\n  }\n\n  _getTotalRowCount(groupCount) {\n    if (this._isHorizontalGroupedWorkSpace()) {\n      return this._getRowCount();\n    } else {\n      groupCount = groupCount || 1;\n      return this._getRowCount() * groupCount;\n    }\n  }\n\n  _getFormat() {\n    return \"shorttime\";\n  }\n\n  _getWorkSpaceHeight() {\n    if (this.option(\"crossScrollingEnabled\") && hasWindow()) {\n      return getBoundingRect(this._$dateTable.get(0)).height;\n    }\n\n    return getBoundingRect(this.$element().get(0)).height;\n  }\n\n  _dateTableScrollableConfig() {\n    var config = super._dateTableScrollableConfig();\n\n    var timelineConfig = {\n      direction: HORIZONTAL\n    };\n    return this.option(\"crossScrollingEnabled\") ? config : extend(config, timelineConfig);\n  }\n\n  _needCreateCrossScrolling() {\n    return true;\n  }\n\n  _headerScrollableConfig() {\n    var config = super._headerScrollableConfig();\n\n    return extend(config, {\n      scrollByContent: true\n    });\n  }\n\n  supportAllDayRow() {\n    return false;\n  }\n\n  _getGroupHeaderContainer() {\n    if (this._isHorizontalGroupedWorkSpace()) {\n      return this._$thead;\n    }\n\n    return this._$sidebarTable;\n  }\n\n  _insertAllDayRowsIntoDateTable() {\n    return false;\n  }\n\n  _needRenderWeekHeader() {\n    return false;\n  }\n\n  _incrementDate(date) {\n    date.setDate(date.getDate() + 1);\n  }\n\n  getIndicationCellCount() {\n    var timeDiff = this._getTimeDiff();\n\n    return this._calculateDurationInCells(timeDiff);\n  }\n\n  _getTimeDiff() {\n    var today = this._getToday();\n\n    var date = this._getIndicationFirstViewDate();\n\n    var startViewDate = this.getStartViewDate();\n    var dayLightOffset = timezoneUtils.getDaylightOffsetInMs(startViewDate, today);\n\n    if (dayLightOffset) {\n      today = new Date(today.getTime() + dayLightOffset);\n    }\n\n    return today.getTime() - date.getTime();\n  }\n\n  _calculateDurationInCells(timeDiff) {\n    var today = this._getToday();\n\n    var differenceInDays = Math.floor(timeDiff / toMs(\"day\"));\n    var duration = (timeDiff - differenceInDays * toMs(\"day\") - this.option(\"startDayHour\") * toMs(\"hour\")) / this.getCellDuration();\n\n    if (today.getHours() > this.option(\"endDayHour\")) {\n      duration = this._getCellCountInDay();\n    }\n\n    if (duration < 0) {\n      duration = 0;\n    }\n\n    return differenceInDays * this._getCellCountInDay() + duration;\n  }\n\n  getIndicationWidth() {\n    if (this.isGroupedByDate()) {\n      var cellCount = this.getIndicationCellCount();\n      var integerPart = Math.floor(cellCount);\n      var fractionPart = cellCount - integerPart;\n      return this.getCellWidth() * (integerPart * this._getGroupCount() + fractionPart);\n    } else {\n      return this.getIndicationCellCount() * this.getCellWidth();\n    }\n  }\n\n  _isVerticalShader() {\n    return false;\n  }\n\n  _isCurrentTimeHeaderCell() {\n    return false;\n  }\n\n  _setTableSizes() {\n    var minHeight = this._getWorkSpaceMinHeight();\n\n    setHeight(this._$sidebarTable, minHeight);\n    setHeight(this._$dateTable, minHeight);\n\n    super._setTableSizes();\n\n    this.virtualScrollingDispatcher.updateDimensions();\n  }\n\n  _getWorkSpaceMinHeight() {\n    var minHeight = this._getWorkSpaceHeight();\n\n    var workspaceContainerHeight = getOuterHeight(this.$element(), true) - this.getHeaderPanelHeight() - 2 * DATE_TABLE_CELL_BORDER - DATE_TABLE_HEADER_MARGIN;\n\n    if (minHeight < workspaceContainerHeight) {\n      minHeight = workspaceContainerHeight;\n    }\n\n    return minHeight;\n  }\n\n  _getCellCoordinatesByIndex(index) {\n    return {\n      columnIndex: index % this._getCellCount(),\n      rowIndex: 0\n    };\n  }\n\n  _getCellByCoordinates(cellCoordinates, groupIndex) {\n    var indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex);\n\n    return this._$dateTable.find(\"tr\").eq(indexes.rowIndex).find(\"td\").eq(indexes.columnIndex);\n  }\n\n  _getWorkSpaceWidth() {\n    return getOuterWidth(this._$dateTable, true);\n  }\n\n  _getIndicationFirstViewDate() {\n    return dateUtils.trimTime(new Date(this.getStartViewDate()));\n  }\n\n  _getIntervalBetween(currentDate, allDay) {\n    var startDayHour = this.option(\"startDayHour\");\n    var endDayHour = this.option(\"endDayHour\");\n    var firstViewDate = this.getStartViewDate();\n    var firstViewDateTime = firstViewDate.getTime();\n    var hiddenInterval = (24 - endDayHour + startDayHour) * toMs(\"hour\");\n    var timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate);\n    var apptStart = currentDate.getTime();\n    var fullInterval = apptStart - firstViewDateTime - timeZoneOffset;\n    var fullDays = Math.floor(fullInterval / toMs(\"day\"));\n    var tailDuration = fullInterval - fullDays * toMs(\"day\");\n    var tailDelta = 0;\n\n    var cellCount = this._getCellCountInDay() * (fullDays - this._getWeekendsCount(fullDays));\n\n    var gapBeforeAppt = apptStart - dateUtils.trimTime(new Date(currentDate)).getTime();\n    var result = cellCount * this.option(\"hoursInterval\") * toMs(\"hour\");\n\n    if (!allDay) {\n      if (currentDate.getHours() < startDayHour) {\n        tailDelta = tailDuration - hiddenInterval + gapBeforeAppt;\n      } else if (currentDate.getHours() >= startDayHour && currentDate.getHours() < endDayHour) {\n        tailDelta = tailDuration;\n      } else if (currentDate.getHours() >= startDayHour && currentDate.getHours() >= endDayHour) {\n        tailDelta = tailDuration - (gapBeforeAppt - endDayHour * toMs(\"hour\"));\n      } else if (!fullDays) {\n        result = fullInterval;\n      }\n\n      result += tailDelta;\n    }\n\n    return result;\n  }\n\n  _getWeekendsCount() {\n    return 0;\n  }\n\n  getAllDayContainer() {\n    return null;\n  }\n\n  getTimePanelWidth() {\n    return 0;\n  }\n\n  getIntervalDuration(allDay) {\n    return this.getCellDuration();\n  }\n\n  getCellMinWidth() {\n    return 0;\n  }\n\n  getWorkSpaceLeftOffset() {\n    return 0;\n  }\n\n  scrollToTime(hours, minutes, date) {\n    var coordinates = this._getScrollCoordinates(hours, minutes, date);\n\n    var scrollable = this.getScrollable();\n    var offset = this.option(\"rtlEnabled\") ? getBoundingRect(this.getScrollableContainer().get(0)).width : 0;\n\n    if (this.option(\"templatesRenderAsynchronously\")) {\n      setTimeout(function () {\n        scrollable.scrollBy({\n          left: coordinates.left - scrollable.scrollLeft() - offset,\n          top: 0\n        });\n      });\n    } else {\n      scrollable.scrollBy({\n        left: coordinates.left - scrollable.scrollLeft() - offset,\n        top: 0\n      });\n    }\n  }\n\n  renderRAllDayPanel() {}\n\n  renderRTimeTable() {}\n\n  _renderGroupAllDayPanel() {}\n\n  generateRenderOptions() {\n    var options = super.generateRenderOptions(true);\n    return _extends({}, options, {\n      isGenerateWeekDaysHeaderData: this._needRenderWeekHeader(),\n      getDateForHeaderText: getDateForHeaderText\n    });\n  }\n\n  _init() {\n    super._init();\n\n    this.$element().addClass(TIMELINE_CLASS);\n    this._$sidebarTable = $(\"<div>\").addClass(GROUP_TABLE_CLASS);\n  }\n\n  _getDefaultGroupStrategy() {\n    return \"vertical\";\n  }\n\n  _toggleGroupingDirectionClass() {\n    this.$element().toggleClass(HORIZONTAL_GROUPED_WORKSPACE_CLASS, this._isHorizontalGroupedWorkSpace());\n  }\n\n  _getDefaultOptions() {\n    return extend(super._getDefaultOptions(), {\n      groupOrientation: \"vertical\"\n    });\n  }\n\n  _createWorkSpaceElements() {\n    this._createWorkSpaceScrollableElements();\n  }\n\n  _toggleAllDayVisibility() {\n    return noop();\n  }\n\n  _changeAllDayVisibility() {\n    return noop();\n  }\n\n  _getDateHeaderTemplate() {\n    return this.option(\"timeCellTemplate\");\n  }\n\n  _renderView() {\n    var groupCellTemplates;\n\n    if (!this.isRenovatedRender()) {\n      groupCellTemplates = this._renderGroupHeader();\n    }\n\n    this.renderWorkSpace();\n    this._shader = new HorizontalShader(this);\n\n    this._$sidebarTable.appendTo(this._sidebarScrollable.$content());\n\n    if (this.isRenovatedRender() && this._isVerticalGroupedWorkSpace()) {\n      this.renderRGroupPanel();\n    }\n\n    this.updateHeaderEmptyCellWidth();\n\n    this._applyCellTemplates(groupCellTemplates);\n  }\n\n  _setHorizontalGroupHeaderCellsHeight() {\n    return noop();\n  }\n\n  _setCurrentTimeCells() {\n    var timePanelCells = this._getTimePanelCells();\n\n    var currentTimeCellIndices = this._getCurrentTimePanelCellIndices();\n\n    currentTimeCellIndices.forEach(timePanelCellIndex => {\n      timePanelCells.eq(timePanelCellIndex).addClass(HEADER_CURRENT_TIME_CELL_CLASS);\n    });\n  }\n\n  _cleanCurrentTimeCells() {\n    this.$element().find(\".\".concat(HEADER_CURRENT_TIME_CELL_CLASS)).removeClass(HEADER_CURRENT_TIME_CELL_CLASS);\n  }\n\n  _getTimePanelCells() {\n    return this.$element().find(\".\".concat(HEADER_PANEL_CELL_CLASS, \":not(.\").concat(HEADER_PANEL_WEEK_CELL_CLASS, \")\"));\n  }\n\n  _getCurrentTimePanelCellIndices() {\n    var columnCountPerGroup = this._getCellCount();\n\n    var today = this._getToday();\n\n    var index = this.getCellIndexByDate(today);\n\n    var {\n      columnIndex: currentTimeColumnIndex\n    } = this._getCellCoordinatesByIndex(index);\n\n    if (void 0 === currentTimeColumnIndex) {\n      return [];\n    }\n\n    var horizontalGroupCount = this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate() ? this._getGroupCount() : 1;\n    return [...new Array(horizontalGroupCount)].map((_, groupIndex) => columnCountPerGroup * groupIndex + currentTimeColumnIndex);\n  }\n\n  _renderTimePanel() {\n    return noop();\n  }\n\n  _renderAllDayPanel() {\n    return noop();\n  }\n\n  _createAllDayPanelElements() {\n    return noop();\n  }\n\n  _renderDateHeader() {\n    var $headerRow = super._renderDateHeader();\n\n    if (this._needRenderWeekHeader()) {\n      var firstViewDate = new Date(this.getStartViewDate());\n      var currentDate = new Date(firstViewDate);\n      var $cells = [];\n\n      var groupCount = this._getGroupCount();\n\n      var cellCountInDay = this._getCellCountInDay();\n\n      var colSpan = this.isGroupedByDate() ? cellCountInDay * groupCount : cellCountInDay;\n      var cellTemplate = this.option(\"dateCellTemplate\");\n      var horizontalGroupCount = this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate() ? groupCount : 1;\n      var cellsInGroup = this.viewDataProvider.viewDataGenerator.daysInInterval * this.option(\"intervalCount\");\n      var cellsCount = cellsInGroup * horizontalGroupCount;\n\n      for (var templateIndex = 0; templateIndex < cellsCount; templateIndex++) {\n        var $th = $(\"<th>\");\n        var text = formatWeekdayAndDay(currentDate);\n\n        if (cellTemplate) {\n          var templateOptions = {\n            model: _extends({\n              text: text,\n              date: new Date(currentDate)\n            }, this._getGroupsForDateHeaderTemplate(templateIndex, colSpan)),\n            container: $th,\n            index: templateIndex\n          };\n          cellTemplate.render(templateOptions);\n        } else {\n          $th.text(text);\n        }\n\n        $th.addClass(HEADER_PANEL_CELL_CLASS).addClass(HEADER_PANEL_WEEK_CELL_CLASS).attr(\"colSpan\", colSpan);\n        $cells.push($th);\n\n        if (templateIndex % cellsInGroup === cellsInGroup - 1) {\n          currentDate = new Date(firstViewDate);\n        } else {\n          this._incrementDate(currentDate);\n        }\n      }\n\n      var $row = $(\"<tr>\").addClass(HEADER_ROW_CLASS).append($cells);\n      $headerRow.before($row);\n    }\n  }\n\n  _renderIndicator(height, rtlOffset, $container, groupCount) {\n    var $indicator;\n    var width = this.getIndicationWidth();\n\n    if (\"vertical\" === this.option(\"groupOrientation\")) {\n      $indicator = this._createIndicator($container);\n      setHeight($indicator, getBoundingRect($container.get(0)).height);\n      $indicator.css(\"left\", rtlOffset ? rtlOffset - width : width);\n    } else {\n      for (var i = 0; i < groupCount; i++) {\n        var offset = this.isGroupedByDate() ? i * this.getCellWidth() : this._getCellCount() * this.getCellWidth() * i;\n        $indicator = this._createIndicator($container);\n        setHeight($indicator, getBoundingRect($container.get(0)).height);\n        $indicator.css(\"left\", rtlOffset ? rtlOffset - width - offset : width + offset);\n      }\n    }\n  }\n\n  _makeGroupRows(groups, groupByDate) {\n    var tableCreatorStrategy = \"vertical\" === this.option(\"groupOrientation\") ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;\n    return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {\n      groupRowClass: GROUP_ROW_CLASS,\n      groupHeaderRowClass: GROUP_ROW_CLASS,\n      groupHeaderClass: this._getGroupHeaderClass.bind(this),\n      groupHeaderContentClass: GROUP_HEADER_CONTENT_CLASS\n    }, this._getCellCount() || 1, this.option(\"resourceCellTemplate\"), this._getTotalRowCount(this._getGroupCount()), groupByDate);\n  }\n\n}\n\nregisterComponent(\"dxSchedulerTimeline\", SchedulerTimeline);\nexport default SchedulerTimeline;","map":null,"metadata":{},"sourceType":"module"}