{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/grid_core/ui.grid_core.row_dragging.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { setWidth, getWidth } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport { extend } from \"../../core/utils/extend\";\nimport Sortable from \"../sortable\";\nimport gridCoreUtils from \"./ui.grid_core.utils\";\nimport { deferUpdate } from \"../../core/utils/common\";\nvar COMMAND_HANDLE_CLASS = \"dx-command-drag\";\nvar CELL_FOCUS_DISABLED_CLASS = \"dx-cell-focus-disabled\";\nvar HANDLE_ICON_CLASS = \"drag-icon\";\nvar ROWS_VIEW = \"rowsview\";\nvar SORTABLE_WITHOUT_HANDLE_CLASS = \"dx-sortable-without-handle\";\nvar RowDraggingExtender = {\n  init: function () {\n    this.callBase.apply(this, arguments);\n\n    this._updateHandleColumn();\n  },\n  _allowReordering: function () {\n    var rowDragging = this.option(\"rowDragging\");\n    return !!(rowDragging && (rowDragging.allowReordering || rowDragging.allowDropInsideItem || rowDragging.group));\n  },\n  _updateHandleColumn: function () {\n    var rowDragging = this.option(\"rowDragging\");\n\n    var allowReordering = this._allowReordering();\n\n    var columnsController = this._columnsController;\n    var isHandleColumnVisible = allowReordering && rowDragging.showDragIcons;\n    columnsController && columnsController.addCommandColumn({\n      type: \"drag\",\n      command: \"drag\",\n      visibleIndex: -2,\n      alignment: \"center\",\n      cssClass: COMMAND_HANDLE_CLASS,\n      width: \"auto\",\n      cellTemplate: this._getHandleTemplate(),\n      visible: isHandleColumnVisible\n    });\n    columnsController.columnOption(\"type:drag\", \"visible\", isHandleColumnVisible);\n  },\n  _renderContent: function () {\n    var rowDragging = this.option(\"rowDragging\");\n\n    var allowReordering = this._allowReordering();\n\n    var $content = this.callBase.apply(this, arguments);\n    var isFixedTableRendering = this._isFixedTableRendering;\n    var sortableName = \"_sortable\";\n    var sortableFixedName = \"_sortableFixed\";\n    var currentSortableName = isFixedTableRendering ? sortableFixedName : sortableName;\n    var anotherSortableName = isFixedTableRendering ? sortableName : sortableFixedName;\n\n    var togglePointerEventsStyle = toggle => {\n      var _this$sortableFixedNa;\n\n      null === (_this$sortableFixedNa = this[sortableFixedName]) || void 0 === _this$sortableFixedNa ? void 0 : _this$sortableFixedNa.$element().css(\"pointerEvents\", toggle ? \"auto\" : \"\");\n    };\n\n    var rowSelector = \".dx-row:not(.dx-freespace-row):not(.dx-virtual-row):not(.dx-header-row):not(.dx-footer-row)\";\n    var filter = this.option(\"dataRowTemplate\") ? \"> table > tbody\".concat(rowSelector) : \"> table > tbody > \".concat(rowSelector);\n\n    if ((allowReordering || this[currentSortableName]) && $content.length) {\n      this[currentSortableName] = this._createComponent($content, Sortable, extend({\n        component: this.component,\n        contentTemplate: null,\n        filter: filter,\n        cursorOffset: options => {\n          var event = options.event;\n          var rowsViewOffset = $(this.element()).offset();\n          return {\n            x: event.pageX - rowsViewOffset.left\n          };\n        },\n        onDraggableElementShown: e => {\n          if (rowDragging.dragTemplate) {\n            return;\n          }\n\n          var $dragElement = $(e.dragElement);\n          var gridInstance = $dragElement.children(\".dx-widget\").data(this.component.NAME);\n\n          this._synchronizeScrollLeftPosition(gridInstance);\n        },\n        dragTemplate: this._getDraggableRowTemplate(),\n        handle: rowDragging.showDragIcons && \".\".concat(COMMAND_HANDLE_CLASS),\n        dropFeedbackMode: \"indicate\"\n      }, rowDragging, {\n        onDragStart: e => {\n          var _this$getController, _rowDragging$onDragSt;\n\n          null === (_this$getController = this.getController(\"keyboardNavigation\")) || void 0 === _this$getController ? void 0 : _this$getController._resetFocusedCell();\n          var row = e.component.getVisibleRows()[e.fromIndex];\n          e.itemData = row && row.data;\n          var isDataRow = row && \"data\" === row.rowType;\n          e.cancel = !allowReordering || !isDataRow;\n          null === (_rowDragging$onDragSt = rowDragging.onDragStart) || void 0 === _rowDragging$onDragSt ? void 0 : _rowDragging$onDragSt.call(rowDragging, e);\n        },\n        onDragEnter: () => {\n          togglePointerEventsStyle(true);\n        },\n        onDragLeave: () => {\n          togglePointerEventsStyle(false);\n        },\n        onDragEnd: e => {\n          var _rowDragging$onDragEn;\n\n          togglePointerEventsStyle(false);\n          null === (_rowDragging$onDragEn = rowDragging.onDragEnd) || void 0 === _rowDragging$onDragEn ? void 0 : _rowDragging$onDragEn.call(rowDragging, e);\n        },\n        onAdd: e => {\n          var _rowDragging$onAdd;\n\n          togglePointerEventsStyle(false);\n          null === (_rowDragging$onAdd = rowDragging.onAdd) || void 0 === _rowDragging$onAdd ? void 0 : _rowDragging$onAdd.call(rowDragging, e);\n        },\n        dropFeedbackMode: rowDragging.dropFeedbackMode,\n        onOptionChanged: e => {\n          var hasFixedSortable = this[sortableFixedName];\n\n          if (hasFixedSortable) {\n            if (\"fromIndex\" === e.name || \"toIndex\" === e.name) {\n              this[anotherSortableName].option(e.name, e.value);\n            }\n          }\n        }\n      }));\n      $content.toggleClass(\"dx-scrollable-container\", isFixedTableRendering);\n      $content.toggleClass(SORTABLE_WITHOUT_HANDLE_CLASS, allowReordering && !rowDragging.showDragIcons);\n    }\n\n    return $content;\n  },\n\n  _renderCore(e) {\n    this.callBase.apply(this, arguments);\n\n    if (e && \"update\" === e.changeType && e.repaintChangesOnly && gridCoreUtils.isVirtualRowRendering(this)) {\n      deferUpdate(() => {\n        this._updateSortable();\n      });\n    }\n  },\n\n  _updateSortable() {\n    var offset = this._dataController.getRowIndexOffset();\n\n    [this._sortable, this._sortableFixed].forEach(sortable => {\n      null === sortable || void 0 === sortable ? void 0 : sortable.option(\"offset\", offset);\n      null === sortable || void 0 === sortable ? void 0 : sortable.update();\n    });\n  },\n\n  _resizeCore: function () {\n    this.callBase.apply(this, arguments);\n\n    this._updateSortable();\n  },\n  _getDraggableGridOptions: function (options) {\n    var gridOptions = this.option();\n    var columns = this.getColumns();\n    var $rowElement = $(this.getRowElement(options.rowIndex));\n    return {\n      dataSource: [{\n        id: 1,\n        parentId: 0\n      }],\n      showBorders: true,\n      showColumnHeaders: false,\n      scrolling: {\n        useNative: false,\n        showScrollbar: \"never\"\n      },\n      pager: {\n        visible: false\n      },\n      loadingTimeout: null,\n      columnFixing: gridOptions.columnFixing,\n      columnAutoWidth: gridOptions.columnAutoWidth,\n      showColumnLines: gridOptions.showColumnLines,\n      columns: columns.map(column => ({\n        width: column.width || column.visibleWidth,\n        fixed: column.fixed,\n        fixedPosition: column.fixedPosition\n      })),\n      onRowPrepared: e => {\n        var rowsView = e.component.getView(\"rowsView\");\n        $(e.rowElement).replaceWith($rowElement.eq(rowsView._isFixedTableRendering ? 1 : 0).clone());\n      }\n    };\n  },\n  _synchronizeScrollLeftPosition: function (gridInstance) {\n    var scrollable = null === gridInstance || void 0 === gridInstance ? void 0 : gridInstance.getScrollable();\n    null === scrollable || void 0 === scrollable ? void 0 : scrollable.scrollTo({\n      x: this._scrollLeft\n    });\n  },\n  _getDraggableRowTemplate: function () {\n    return options => {\n      var $rootElement = this.component.$element();\n      var $dataGridContainer = $(\"<div>\");\n      setWidth($dataGridContainer, getWidth($rootElement));\n\n      var items = this._dataController.items();\n\n      var row = items && items[options.fromIndex];\n\n      var gridOptions = this._getDraggableGridOptions(row);\n\n      this._createComponent($dataGridContainer, this.component.NAME, gridOptions);\n\n      $dataGridContainer.find(\".dx-gridbase-container\").children(\":not(.\".concat(this.addWidgetPrefix(ROWS_VIEW), \")\")).hide();\n      return $dataGridContainer;\n    };\n  },\n  _getHandleTemplate: function () {\n    return (container, options) => {\n      if (\"data\" === options.rowType) {\n        $(container).addClass(CELL_FOCUS_DISABLED_CLASS);\n        return $(\"<span>\").addClass(this.addWidgetPrefix(HANDLE_ICON_CLASS));\n      } else {\n        gridCoreUtils.setEmptyText($(container));\n      }\n    };\n  },\n  optionChanged: function (args) {\n    if (\"rowDragging\" === args.name) {\n      this._updateHandleColumn();\n\n      this._invalidate(true, true);\n\n      args.handled = true;\n    }\n\n    this.callBase.apply(this, arguments);\n  }\n};\nexport var rowDraggingModule = {\n  defaultOptions: function () {\n    return {\n      rowDragging: {\n        showDragIcons: true,\n        dropFeedbackMode: \"indicate\",\n        allowReordering: false,\n        allowDropInsideItem: false\n      }\n    };\n  },\n  extenders: {\n    views: {\n      rowsView: RowDraggingExtender\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}