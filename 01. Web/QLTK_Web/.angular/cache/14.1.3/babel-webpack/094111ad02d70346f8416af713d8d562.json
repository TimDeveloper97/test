{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/popover/ui.popover.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getWidth, setWidth, getHeight, setHeight } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport { hasWindow } from \"../../core/utils/window\";\nimport { getPublicElement } from \"../../core/element\";\nimport domAdapter from \"../../core/dom_adapter\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport registerComponent from \"../../core/component_registrator\";\nimport { extend } from \"../../core/utils/extend\";\nimport { move } from \"../../animation/translator\";\nimport positionUtils from \"../../animation/position\";\nimport { isObject, isString } from \"../../core/utils/type\";\nimport { fitIntoRange } from \"../../core/utils/math\";\nimport { addNamespace } from \"../../events/utils/index\";\nimport errors from \"../widget/ui.errors\";\nimport Popup from \"../popup\";\nimport { getBoundingRect } from \"../../core/utils/position\";\nimport { PopoverPositionController, POPOVER_POSITION_ALIASES } from \"./popover_position_controller\";\nvar POPOVER_CLASS = \"dx-popover\";\nvar POPOVER_WRAPPER_CLASS = \"dx-popover-wrapper\";\nvar POPOVER_ARROW_CLASS = \"dx-popover-arrow\";\nvar POPOVER_WITHOUT_TITLE_CLASS = \"dx-popover-without-title\";\nvar POSITION_FLIP_MAP = {\n  left: \"right\",\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  center: \"center\"\n};\n\nvar getEventNameByOption = function (optionValue) {\n  return isObject(optionValue) ? optionValue.name : optionValue;\n};\n\nvar getEventName = function (that, optionName) {\n  var optionValue = that.option(optionName);\n  return getEventNameByOption(optionValue);\n};\n\nvar getEventDelay = function (that, optionName) {\n  var optionValue = that.option(optionName);\n  return isObject(optionValue) && optionValue.delay;\n};\n\nvar attachEvent = function (that, name) {\n  var {\n    target: target,\n    shading: shading,\n    disabled: disabled,\n    hideEvent: hideEvent\n  } = that.option();\n  var isSelector = isString(target);\n  var shouldIgnoreHideEvent = shading && \"hide\" === name;\n  var event = shouldIgnoreHideEvent ? null : getEventName(that, \"\".concat(name, \"Event\"));\n\n  if (shouldIgnoreHideEvent && hideEvent) {\n    errors.log(\"W1020\");\n  }\n\n  if (!event || disabled) {\n    return;\n  }\n\n  var eventName = addNamespace(event, that.NAME);\n\n  var action = that._createAction(function () {\n    var delay = getEventDelay(that, name + \"Event\");\n\n    this._clearEventsTimeouts();\n\n    if (delay) {\n      this._timeouts[name] = setTimeout(function () {\n        that[name]();\n      }, delay);\n    } else {\n      that[name]();\n    }\n  }.bind(that), {\n    validatingTargetName: \"target\"\n  });\n\n  var handler = function (e) {\n    action({\n      event: e,\n      target: $(e.currentTarget)\n    });\n  };\n\n  var EVENT_HANDLER_NAME = \"_\" + name + \"EventHandler\";\n\n  if (isSelector) {\n    that[EVENT_HANDLER_NAME] = handler;\n    eventsEngine.on(domAdapter.getDocument(), eventName, target, handler);\n  } else {\n    var targetElement = getPublicElement($(target));\n    that[EVENT_HANDLER_NAME] = void 0;\n    eventsEngine.on(targetElement, eventName, handler);\n  }\n};\n\nvar detachEvent = function (that, target, name, event) {\n  var eventName = event || getEventName(that, name + \"Event\");\n\n  if (!eventName) {\n    return;\n  }\n\n  eventName = addNamespace(eventName, that.NAME);\n  var EVENT_HANDLER_NAME = \"_\" + name + \"EventHandler\";\n\n  if (that[EVENT_HANDLER_NAME]) {\n    eventsEngine.off(domAdapter.getDocument(), eventName, target, that[EVENT_HANDLER_NAME]);\n  } else {\n    eventsEngine.off(getPublicElement($(target)), eventName);\n  }\n};\n\nvar Popover = Popup.inherit({\n  _getDefaultOptions: function () {\n    return extend(this.callBase(), {\n      target: void 0,\n      shading: false,\n      position: extend({}, POPOVER_POSITION_ALIASES.bottom),\n      hideOnOutsideClick: true,\n      animation: {\n        show: {\n          type: \"fade\",\n          from: 0,\n          to: 1\n        },\n        hide: {\n          type: \"fade\",\n          to: 0\n        }\n      },\n      showTitle: false,\n      width: \"auto\",\n      height: \"auto\",\n      dragEnabled: false,\n      resizeEnabled: false,\n      fullScreen: false,\n      hideOnParentScroll: true,\n      arrowPosition: \"\",\n      arrowOffset: 0,\n      _fixWrapperPosition: true\n    });\n  },\n  _defaultOptionsRules: function () {\n    return [{\n      device: {\n        platform: \"ios\"\n      },\n      options: {\n        arrowPosition: {\n          boundaryOffset: {\n            h: 20,\n            v: -10\n          },\n          collision: \"fit\"\n        }\n      }\n    }, {\n      device: function () {\n        return !hasWindow();\n      },\n      options: {\n        animation: null\n      }\n    }];\n  },\n  _init: function () {\n    this.callBase();\n\n    this._renderArrow();\n\n    this._timeouts = {};\n    this.$element().addClass(POPOVER_CLASS);\n    this.$wrapper().addClass(POPOVER_WRAPPER_CLASS);\n  },\n  _render: function () {\n    this.callBase.apply(this, arguments);\n\n    this._detachEvents(this.option(\"target\"));\n\n    this._attachEvents();\n  },\n  _detachEvents: function (target) {\n    detachEvent(this, target, \"show\");\n    detachEvent(this, target, \"hide\");\n  },\n  _attachEvents: function () {\n    attachEvent(this, \"show\");\n    attachEvent(this, \"hide\");\n  },\n  _renderArrow: function () {\n    this._$arrow = $(\"<div>\").addClass(POPOVER_ARROW_CLASS).prependTo(this.$overlayContent());\n  },\n  _documentDownHandler: function (e) {\n    if (this._isOutsideClick(e)) {\n      return this.callBase(e);\n    }\n\n    return true;\n  },\n  _isOutsideClick: function (e) {\n    return !$(e.target).closest(this.option(\"target\")).length;\n  },\n  _animate: function (animation) {\n    if (animation && animation.to && \"object\" === typeof animation.to) {\n      extend(animation.to, {\n        position: this._getContainerPosition()\n      });\n    }\n\n    this.callBase.apply(this, arguments);\n  },\n  _stopAnimation: function () {\n    this.callBase.apply(this, arguments);\n  },\n  _renderTitle: function () {\n    this.$wrapper().toggleClass(POPOVER_WITHOUT_TITLE_CLASS, !this.option(\"showTitle\"));\n    this.callBase();\n  },\n  _renderPosition: function () {\n    this.callBase();\n\n    this._renderOverlayPosition();\n\n    this._actions.onPositioned();\n  },\n  _renderOverlayPosition: function () {\n    this._resetOverlayPosition();\n\n    this._updateContentSize();\n\n    var contentPosition = this._getContainerPosition();\n\n    var resultLocation = positionUtils.setup(this.$overlayContent(), contentPosition);\n\n    var positionSide = this._getSideByLocation(resultLocation);\n\n    this._togglePositionClass(\"dx-position-\" + positionSide);\n\n    this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);\n\n    var isArrowVisible = this._isHorizontalSide() || this._isVerticalSide();\n\n    if (isArrowVisible) {\n      this._renderArrowPosition(positionSide);\n    }\n  },\n  _resetOverlayPosition: function () {\n    this._setContentHeight(true);\n\n    this._togglePositionClass(\"dx-position-\" + this._positionController._positionSide);\n\n    move(this.$overlayContent(), {\n      left: 0,\n      top: 0\n    });\n\n    this._$arrow.css({\n      top: \"auto\",\n      right: \"auto\",\n      bottom: \"auto\",\n      left: \"auto\"\n    });\n  },\n  _updateContentSize: function () {\n    if (!this.$content()) {\n      return;\n    }\n\n    var containerLocation = positionUtils.calculate(this.$overlayContent(), this._getContainerPosition());\n\n    if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {\n      var newContainerWidth = getWidth(this.$overlayContent()) - containerLocation.h.oversize;\n      setWidth(this.$overlayContent(), newContainerWidth);\n    }\n\n    if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {\n      var newOverlayContentHeight = getHeight(this.$overlayContent()) - containerLocation.v.oversize;\n      var newPopupContentHeight = getHeight(this.$content()) - containerLocation.v.oversize;\n      setHeight(this.$overlayContent(), newOverlayContentHeight);\n      setHeight(this.$content(), newPopupContentHeight);\n    }\n  },\n  _getContainerPosition: function () {\n    return this._positionController._getContainerPosition();\n  },\n  _hideOnParentScrollTarget: function () {\n    return $(this._positionController._position.of || this.callBase());\n  },\n  _getSideByLocation: function (location) {\n    var isFlippedByVertical = location.v.flip;\n    var isFlippedByHorizontal = location.h.flip;\n    return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionController._positionSide] : this._positionController._positionSide;\n  },\n  _togglePositionClass: function (positionClass) {\n    this.$wrapper().removeClass(\"dx-position-left dx-position-right dx-position-top dx-position-bottom\").addClass(positionClass);\n  },\n  _toggleFlippedClass: function (isFlippedHorizontal, isFlippedVertical) {\n    this.$wrapper().toggleClass(\"dx-popover-flipped-horizontal\", isFlippedHorizontal).toggleClass(\"dx-popover-flipped-vertical\", isFlippedVertical);\n  },\n  _renderArrowPosition: function (side) {\n    var arrowRect = getBoundingRect(this._$arrow.get(0));\n    var arrowFlip = -(this._isVerticalSide(side) ? arrowRect.height : arrowRect.width);\n\n    this._$arrow.css(POSITION_FLIP_MAP[side], arrowFlip);\n\n    var axis = this._isVerticalSide(side) ? \"left\" : \"top\";\n    var sizeProperty = this._isVerticalSide(side) ? \"width\" : \"height\";\n    var $target = $(this._positionController._position.of);\n    var targetOffset = positionUtils.offset($target) || {\n      top: 0,\n      left: 0\n    };\n    var contentOffset = positionUtils.offset(this.$overlayContent());\n    var arrowSize = arrowRect[sizeProperty];\n    var contentLocation = contentOffset[axis];\n    var contentSize = getBoundingRect(this.$overlayContent().get(0))[sizeProperty];\n    var targetLocation = targetOffset[axis];\n    var targetElement = $target.get(0);\n    var targetSize = targetElement && !targetElement.preventDefault ? getBoundingRect(targetElement)[sizeProperty] : 0;\n    var min = Math.max(contentLocation, targetLocation);\n    var max = Math.min(contentLocation + contentSize, targetLocation + targetSize);\n    var arrowLocation;\n\n    if (\"start\" === this.option(\"arrowPosition\")) {\n      arrowLocation = min - contentLocation;\n    } else if (\"end\" === this.option(\"arrowPosition\")) {\n      arrowLocation = max - contentLocation - arrowSize;\n    } else {\n      arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2;\n    }\n\n    var borderWidth = this._positionController._getContentBorderWidth(side);\n\n    var finalArrowLocation = fitIntoRange(arrowLocation - borderWidth + this.option(\"arrowOffset\"), borderWidth, contentSize - arrowSize - 2 * borderWidth);\n\n    this._$arrow.css(axis, finalArrowLocation);\n  },\n  _isPopoverInside: function () {\n    return this._positionController._isPopoverInside();\n  },\n  _setContentHeight: function (fullUpdate) {\n    if (fullUpdate) {\n      this.callBase();\n    }\n  },\n\n  _getPositionControllerConfig() {\n    var {\n      shading: shading,\n      target: target\n    } = this.option();\n    return extend({}, this.callBase(), {\n      target: target,\n      shading: shading,\n      $arrow: this._$arrow\n    });\n  },\n\n  _initPositionController() {\n    this._positionController = new PopoverPositionController(this._getPositionControllerConfig());\n  },\n\n  _renderWrapperDimensions: function () {\n    if (this.option(\"shading\")) {\n      this.$wrapper().css({\n        width: \"100%\",\n        height: \"100%\"\n      });\n    }\n  },\n  _isVerticalSide: function (side) {\n    return this._positionController._isVerticalSide(side);\n  },\n  _isHorizontalSide: function (side) {\n    return this._positionController._isHorizontalSide(side);\n  },\n  _clearEventTimeout: function (name) {\n    clearTimeout(this._timeouts[name]);\n  },\n  _clearEventsTimeouts: function () {\n    this._clearEventTimeout(\"show\");\n\n    this._clearEventTimeout(\"hide\");\n  },\n  _clean: function () {\n    this._detachEvents(this.option(\"target\"));\n\n    this.callBase.apply(this, arguments);\n  },\n  _optionChanged: function (args) {\n    switch (args.name) {\n      case \"arrowPosition\":\n      case \"arrowOffset\":\n        this._renderGeometry();\n\n        break;\n\n      case \"fullScreen\":\n        if (args.value) {\n          this.option(\"fullScreen\", false);\n        }\n\n        break;\n\n      case \"target\":\n        args.previousValue && this._detachEvents(args.previousValue);\n\n        this._positionController.updateTarget(args.value);\n\n        this._invalidate();\n\n        break;\n\n      case \"showEvent\":\n      case \"hideEvent\":\n        var name = args.name.substring(0, 4);\n        var event = getEventNameByOption(args.previousValue);\n        this.hide();\n        detachEvent(this, this.option(\"target\"), name, event);\n        attachEvent(this, name);\n        break;\n\n      case \"visible\":\n        this._clearEventTimeout(args.value ? \"show\" : \"hide\");\n\n        this.callBase(args);\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  show: function (target) {\n    if (target) {\n      this.option(\"target\", target);\n    }\n\n    return this.callBase();\n  }\n});\nregisterComponent(\"dxPopover\", Popover);\nexport default Popover;","map":null,"metadata":{},"sourceType":"module"}