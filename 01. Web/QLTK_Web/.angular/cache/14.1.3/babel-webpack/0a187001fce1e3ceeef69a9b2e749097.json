{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/collection/ui.collection_widget.live_update.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport CollectionWidget from \"./ui.collection_widget.edit\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { update, insert, indexByKey } from \"../../data/array_utils\";\nimport { keysEqual } from \"../../data/utils\";\nimport { when } from \"../../core/utils/deferred\";\nimport { findChanges } from \"../../core/utils/array_compare\";\nimport domAdapter from \"../../core/dom_adapter\";\nimport { noop } from \"../../core/utils/common\";\nvar PRIVATE_KEY_FIELD = \"__dx_key__\";\nexport default CollectionWidget.inherit({\n  _getDefaultOptions: function () {\n    return extend(this.callBase(), {\n      repaintChangesOnly: false\n    });\n  },\n  ctor: function () {\n    this.callBase.apply(this, arguments);\n    this._customizeStoreLoadOptions = e => {\n      var dataSource = this._dataSource;\n\n      if (dataSource && !dataSource.isLoaded()) {\n        this._correctionIndex = 0;\n      }\n\n      if (this._correctionIndex && e.storeLoadOptions) {\n        e.storeLoadOptions.skip += this._correctionIndex;\n      }\n    }, this._dataSource && this._dataSource.on(\"customizeStoreLoadOptions\", this._customizeStoreLoadOptions);\n  },\n  reload: function () {\n    this._correctionIndex = 0;\n  },\n  _init: function () {\n    this.callBase();\n\n    this._refreshItemsCache();\n\n    this._correctionIndex = 0;\n  },\n  _findItemElementByKey: function (key) {\n    var result = $();\n    var keyExpr = this.key();\n    this.itemElements().each((_, item) => {\n      var $item = $(item);\n\n      var itemData = this._getItemData($item);\n\n      if (keyExpr ? keysEqual(keyExpr, this.keyOf(itemData), key) : this._isItemEquals(itemData, key)) {\n        result = $item;\n        return false;\n      }\n    });\n    return result;\n  },\n  _dataSourceChangedHandler: function (newItems, e) {\n    if (null !== e && void 0 !== e && e.changes) {\n      this._modifyByChanges(e.changes);\n    } else {\n      this.callBase(newItems, e);\n\n      this._refreshItemsCache();\n    }\n  },\n  _isItemEquals: function (item1, item2) {\n    if (item1 && item1[PRIVATE_KEY_FIELD]) {\n      item1 = item1.data;\n    }\n\n    try {\n      return JSON.stringify(item1) === JSON.stringify(item2);\n    } catch (e) {\n      return item1 === item2;\n    }\n  },\n  _isItemStrictEquals: function (item1, item2) {\n    return this._isItemEquals(item1, item2);\n  },\n  _shouldAddNewGroup: function (changes, items) {\n    var result = false;\n\n    if (this.option(\"grouped\")) {\n      if (!changes.length) {\n        result = true;\n      }\n\n      each(changes, (i, change) => {\n        if (\"insert\" === change.type) {\n          result = true;\n          each(items, (_, item) => {\n            if (void 0 !== change.data.key && change.data.key === item.key) {\n              result = false;\n              return false;\n            }\n          });\n        }\n      });\n    }\n\n    return result;\n  },\n  _partialRefresh: function () {\n    if (this.option(\"repaintChangesOnly\")) {\n      var result = findChanges(this._itemsCache, this._editStrategy.itemsGetter(), data => {\n        if (data && void 0 !== data[PRIVATE_KEY_FIELD]) {\n          return data[PRIVATE_KEY_FIELD];\n        }\n\n        return this.keyOf(data);\n      }, this._isItemStrictEquals.bind(this));\n\n      if (result && this._itemsCache.length && !this._shouldAddNewGroup(result, this._itemsCache)) {\n        this._modifyByChanges(result, true);\n\n        this._renderEmptyMessage();\n\n        return true;\n      } else {\n        this._refreshItemsCache();\n      }\n    }\n\n    return false;\n  },\n  _refreshItemsCache: function () {\n    if (this.option(\"repaintChangesOnly\")) {\n      var items = this._editStrategy.itemsGetter();\n\n      try {\n        this._itemsCache = extend(true, [], items);\n\n        if (!this.key()) {\n          this._itemsCache = this._itemsCache.map((itemCache, index) => ({\n            [PRIVATE_KEY_FIELD]: items[index],\n            data: itemCache\n          }));\n        }\n      } catch (e) {\n        this._itemsCache = extend([], items);\n      }\n    }\n  },\n  _dispose: function () {\n    this._dataSource && this._dataSource.off(\"customizeStoreLoadOptions\", this._customizeStoreLoadOptions);\n    this.callBase();\n  },\n  _updateByChange: function (keyInfo, items, change, isPartialRefresh) {\n    if (isPartialRefresh) {\n      this._renderItem(change.index, change.data, null, this._findItemElementByKey(change.key));\n    } else {\n      var changedItem = items[indexByKey(keyInfo, items, change.key)];\n\n      if (changedItem) {\n        update(keyInfo, items, change.key, change.data).done(() => {\n          this._renderItem(items.indexOf(changedItem), changedItem, null, this._findItemElementByKey(change.key));\n        });\n      }\n    }\n  },\n  _insertByChange: function (keyInfo, items, change, isPartialRefresh) {\n    when(isPartialRefresh || insert(keyInfo, items, change.data, change.index)).done(() => {\n      var _change$index;\n\n      this._beforeItemElementInserted(change);\n\n      var $itemContainer = this._getItemContainer(change.data);\n\n      this._renderItem(null !== (_change$index = change.index) && void 0 !== _change$index ? _change$index : items.length, change.data, $itemContainer);\n\n      this._afterItemElementInserted();\n\n      this._correctionIndex++;\n    });\n  },\n  _getItemContainer: function (changeData) {\n    return this._itemContainer();\n  },\n  _updateSelectionAfterRemoveByChange: function (removeIndex) {\n    var selectedIndex = this.option(\"selectedIndex\");\n\n    if (selectedIndex > removeIndex) {\n      this.option(\"selectedIndex\", selectedIndex - 1);\n    } else if (selectedIndex === removeIndex && 1 === this.option(\"selectedItems\").length) {\n      this.option(\"selectedItems\", []);\n    } else {\n      this._normalizeSelectedItems();\n    }\n  },\n  _beforeItemElementInserted: function (change) {\n    var selectedIndex = this.option(\"selectedIndex\");\n\n    if (change.index <= selectedIndex) {\n      this.option(\"selectedIndex\", selectedIndex + 1);\n    }\n  },\n  _afterItemElementInserted: noop,\n  _removeByChange: function (keyInfo, items, change, isPartialRefresh) {\n    var index = isPartialRefresh ? change.index : indexByKey(keyInfo, items, change.key);\n    var removedItem = isPartialRefresh ? change.oldItem : items[index];\n\n    if (removedItem) {\n      var $removedItemElement = this._findItemElementByKey(change.key);\n\n      var deletedActionArgs = this._extendActionArgs($removedItemElement);\n\n      this._waitDeletingPrepare($removedItemElement).done(() => {\n        if (isPartialRefresh) {\n          this._updateIndicesAfterIndex(index - 1);\n\n          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);\n\n          this._updateSelectionAfterRemoveByChange(index);\n        } else {\n          this._deleteItemElementByIndex(index);\n\n          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);\n        }\n      });\n\n      this._correctionIndex--;\n    }\n  },\n  _modifyByChanges: function (changes, isPartialRefresh) {\n    var items = this._editStrategy.itemsGetter();\n\n    var keyInfo = {\n      key: this.key.bind(this),\n      keyOf: this.keyOf.bind(this)\n    };\n    var dataSource = this._dataSource;\n    var paginate = dataSource && dataSource.paginate();\n    var group = dataSource && dataSource.group();\n\n    if (paginate || group) {\n      changes = changes.filter(item => \"insert\" !== item.type || void 0 !== item.index);\n    }\n\n    changes.forEach(change => this[\"_\".concat(change.type, \"ByChange\")](keyInfo, items, change, isPartialRefresh));\n    this._renderedItemsCount = items.length;\n\n    this._refreshItemsCache();\n\n    this._fireContentReadyAction();\n  },\n  _appendItemToContainer: function ($container, $itemFrame, index) {\n    var nextSiblingElement = $container.children(this._itemSelector()).get(index);\n    domAdapter.insertElement($container.get(0), $itemFrame.get(0), nextSiblingElement);\n  },\n  _optionChanged: function (args) {\n    switch (args.name) {\n      case \"items\":\n        var isItemsUpdated = this._partialRefresh(args.value);\n\n        if (!isItemsUpdated) {\n          this.callBase(args);\n        }\n\n        break;\n\n      case \"dataSource\":\n        if (!this.option(\"repaintChangesOnly\") || !args.value) {\n          this.option(\"items\", []);\n        }\n\n        this.callBase(args);\n        break;\n\n      case \"repaintChangesOnly\":\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"module"}