{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/diagram/diagram.items_option.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend } from \"../../core/utils/extend\";\nimport { Component } from \"../../core/component\";\nimport DataHelperMixin from \"../../data_helper\";\nvar ItemsOptionBase = Component.inherit({}).include(DataHelperMixin);\n\nclass ItemsOption extends ItemsOptionBase {\n  constructor(diagramWidget) {\n    super();\n    this._diagramWidget = diagramWidget;\n\n    this._resetCache();\n  }\n\n  _dataSourceChangedHandler(newItems, e) {\n    this._resetCache();\n\n    this._items = newItems.map(item => extend(true, {}, item));\n    this._dataSourceItems = newItems.slice();\n\n    if (e && e.changes) {\n      var internalChanges = e.changes.filter(change => change.internalChange);\n      var externalChanges = e.changes.filter(change => !change.internalChange);\n\n      if (internalChanges.length) {\n        this._reloadContentByChanges(internalChanges, false);\n      }\n\n      if (externalChanges.length) {\n        this._reloadContentByChanges(externalChanges, true);\n      }\n    } else {\n      this._diagramWidget._onDataSourceChanged();\n    }\n  }\n\n  _dataSourceLoadingChangedHandler(isLoading) {\n    if (isLoading && !this._dataSource.isLoaded()) {\n      this._diagramWidget._showLoadingIndicator();\n    } else {\n      this._diagramWidget._hideLoadingIndicator();\n    }\n  }\n\n  _prepareData(dataObj) {\n    for (var key in dataObj) {\n      if (!Object.prototype.hasOwnProperty.call(dataObj, key)) {\n        continue;\n      }\n\n      if (void 0 === dataObj[key]) {\n        dataObj[key] = null;\n      }\n    }\n\n    return dataObj;\n  }\n\n  insert(data, callback, errorCallback) {\n    this._resetCache();\n\n    var store = this._getStore();\n\n    store.insert(this._prepareData(data)).done((data, key) => {\n      store.push([{\n        type: \"insert\",\n        key: key,\n        data: data,\n        internalChange: true\n      }]);\n\n      if (callback) {\n        callback(data);\n      }\n\n      this._resetCache();\n    }).fail(error => {\n      if (errorCallback) {\n        errorCallback(error);\n      }\n\n      this._resetCache();\n    });\n  }\n\n  update(key, data, callback, errorCallback) {\n    var store = this._getStore();\n\n    var storeKey = this._getStoreKey(store, key, data);\n\n    store.update(storeKey, this._prepareData(data)).done((data, key) => {\n      store.push([{\n        type: \"update\",\n        key: key,\n        data: data,\n        internalChange: true\n      }]);\n\n      if (callback) {\n        callback(key, data);\n      }\n    }).fail(error => {\n      if (errorCallback) {\n        errorCallback(error);\n      }\n    });\n  }\n\n  remove(key, data, callback, errorCallback) {\n    this._resetCache();\n\n    var store = this._getStore();\n\n    var storeKey = this._getStoreKey(store, key, data);\n\n    store.remove(storeKey).done(key => {\n      store.push([{\n        type: \"remove\",\n        key: key,\n        internalChange: true\n      }]);\n\n      if (callback) {\n        callback(key);\n      }\n\n      this._resetCache();\n    }).fail(error => {\n      if (errorCallback) {\n        errorCallback(error);\n      }\n\n      this._resetCache();\n    });\n  }\n\n  findItem(itemKey) {\n    if (!this._items) {\n      return null;\n    }\n\n    return this._getItemByKey(itemKey);\n  }\n\n  getItems() {\n    return this._items;\n  }\n\n  hasItems() {\n    return !!this._items;\n  }\n\n  _reloadContentByChanges(changes, isExternalChanges) {\n    changes = changes.map(change => extend(change, {\n      internalKey: this._getInternalKey(change.key)\n    }));\n\n    this._diagramWidget._reloadContentByChanges(changes, isExternalChanges);\n  }\n\n  _getItemByKey(key) {\n    this._ensureCache();\n\n    var cache = this._cache;\n\n    var index = this._getIndexByKey(key);\n\n    return cache.items[index];\n  }\n\n  _getIndexByKey(key) {\n    this._ensureCache();\n\n    var cache = this._cache;\n\n    if (\"object\" === typeof key) {\n      for (var i = 0, length = cache.keys.length; i < length; i++) {\n        if (cache.keys[i] === key) {\n          return i;\n        }\n      }\n    } else {\n      var keySet = cache.keySet || cache.keys.reduce((accumulator, key, index) => {\n        accumulator[key] = index;\n        return accumulator;\n      }, {});\n\n      if (!cache.keySet) {\n        cache.keySet = keySet;\n      }\n\n      return keySet[key];\n    }\n\n    return -1;\n  }\n\n  _ensureCache() {\n    var cache = this._cache;\n\n    if (!cache.keys) {\n      cache.keys = [];\n      cache.items = [];\n\n      this._fillCache(cache, this._items);\n    }\n  }\n\n  _fillCache(cache, items) {\n    if (!items || !items.length) {\n      return;\n    }\n\n    var keyExpr = this._getKeyExpr();\n\n    if (keyExpr) {\n      items.forEach(item => {\n        cache.keys.push(keyExpr(item));\n        cache.items.push(item);\n      });\n    }\n\n    var itemsExpr = this._getItemsExpr();\n\n    if (itemsExpr) {\n      items.forEach(item => this._fillCache(cache, itemsExpr(item)));\n    }\n\n    var containerChildrenExpr = this._getContainerChildrenExpr();\n\n    if (containerChildrenExpr) {\n      items.forEach(item => this._fillCache(cache, containerChildrenExpr(item)));\n    }\n  }\n\n  _getKeyExpr() {\n    throw \"Not Implemented\";\n  }\n\n  _getItemsExpr() {}\n\n  _getContainerChildrenExpr() {}\n\n  _initDataSource() {\n    super._initDataSource();\n\n    this._dataSource && this._dataSource.paginate(false);\n  }\n\n  _dataSourceOptions() {\n    return {\n      paginate: false\n    };\n  }\n\n  _getStore() {\n    return this._dataSource && this._dataSource.store();\n  }\n\n  _getStoreKey(store, internalKey, data) {\n    var storeKey = store.keyOf(data);\n\n    if (storeKey === data) {\n      var keyExpr = this._getKeyExpr();\n\n      this._dataSourceItems.forEach(item => {\n        if (keyExpr(item) === internalKey) {\n          storeKey = item;\n        }\n      });\n    }\n\n    return storeKey;\n  }\n\n  _getInternalKey(storeKey) {\n    if (\"object\" === typeof storeKey) {\n      var keyExpr = this._getKeyExpr();\n\n      return keyExpr(storeKey);\n    }\n\n    return storeKey;\n  }\n\n  _resetCache() {\n    this._cache = {};\n  }\n\n}\n\nexport default ItemsOption;","map":null,"metadata":{},"sourceType":"module"}