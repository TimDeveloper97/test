{"ast":null,"code":"/**\r\n * DevExtreme (esm/renovation/ui/common/utils/get_updated_options.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { isPlainObject, type } from \"../../../../core/utils/type\";\nvar defaultNotDeepCopyArrays = [\"dataSource\", \"selectedRowKeys\"];\nvar propsToIgnore = {\n  integrationOptions: true\n};\n\nfunction getDiffItem(key, value, previousValue) {\n  return {\n    path: key,\n    value: value,\n    previousValue: previousValue\n  };\n}\n\nfunction compare(resultPaths, item1, item2, key, fullPropName, notDeepCopyArrays) {\n  if (propsToIgnore[key]) {\n    return;\n  }\n\n  var type1 = type(item1);\n  var type2 = type(item2);\n\n  if (item1 === item2) {\n    return;\n  }\n\n  if (type1 !== type2) {\n    resultPaths.push(getDiffItem(key, item2, item1));\n  } else if (\"object\" === type1) {\n    if (!isPlainObject(item2)) {\n      resultPaths.push(getDiffItem(key, item2, item1));\n    } else {\n      var diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);\n      resultPaths.push(...diffPaths.map(item => _extends({}, item, {\n        path: \"\".concat(key, \".\").concat(item.path)\n      })));\n    }\n  } else if (\"array\" === type1) {\n    var notDeepCopy = notDeepCopyArrays.some(prop => fullPropName.includes(prop));\n\n    if (notDeepCopy && item1 !== item2) {\n      resultPaths.push(getDiffItem(key, item2, item1));\n    } else if (item1.length !== item2.length) {\n      resultPaths.push(getDiffItem(key, item2, item1));\n    } else {\n      var _diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);\n\n      [].push.apply(resultPaths, _diffPaths.map(item => _extends({}, item, {\n        path: \"\".concat(key).concat(item.path)\n      })));\n    }\n  } else {\n    resultPaths.push(getDiffItem(key, item2, item1));\n  }\n}\n\nvar objectDiffsFiltered = propsEnumerator => (oldProps, props, fullPropName, notDeepCopyArrays) => {\n  var resultPaths = [];\n  var processItem = !Array.isArray(oldProps) ? propName => {\n    compare(resultPaths, oldProps[propName], props[propName], propName, \"\".concat(fullPropName, \".\").concat(propName), notDeepCopyArrays);\n  } : propName => {\n    compare(resultPaths, oldProps[propName], props[propName], \"[\".concat(propName, \"]\"), \"\".concat(fullPropName, \".\").concat(propName), notDeepCopyArrays);\n  };\n  propsEnumerator(oldProps).forEach(processItem);\n  Object.keys(props).filter(propName => !Object.prototype.hasOwnProperty.call(oldProps, propName) && oldProps[propName] !== props[propName]).forEach(propName => {\n    resultPaths.push({\n      path: propName,\n      value: props[propName],\n      previousValue: oldProps[propName]\n    });\n  });\n  return resultPaths;\n};\n\nvar objectDiffs = objectDiffsFiltered(oldProps => Object.keys(oldProps));\nvar reactProps = {\n  key: true,\n  ref: true,\n  children: true,\n  style: true\n};\nvar objectDiffsWithoutReactProps = objectDiffsFiltered(prop => Object.keys(prop).filter(p => !reactProps[p]));\nexport function getUpdatedOptions(oldProps, props) {\n  var notDeepCopyArrays = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : defaultNotDeepCopyArrays;\n  return objectDiffsWithoutReactProps(oldProps, props, \"\", notDeepCopyArrays);\n}","map":null,"metadata":{},"sourceType":"module"}