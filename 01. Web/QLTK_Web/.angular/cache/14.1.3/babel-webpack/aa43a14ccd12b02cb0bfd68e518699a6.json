{"ast":null,"code":"/**\r\n * DevExtreme (esm/events/transform.js)\r\n * Version: 22.1.4\r\n * Build date: Fri Jul 22 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { sign as mathSign, fitIntoRange } from \"../core/utils/math\";\nimport * as iteratorUtils from \"../core/utils/iterator\";\nimport { hasTouches } from \"./utils/index\";\nimport Emitter from \"./core/emitter\";\nimport registerEmitter from \"./core/emitter_registrator\";\nvar DX_PREFIX = \"dx\";\nvar TRANSFORM = \"transform\";\nvar TRANSLATE = \"translate\";\nvar PINCH = \"pinch\";\nvar ROTATE = \"rotate\";\nvar START_POSTFIX = \"start\";\nvar UPDATE_POSTFIX = \"\";\nvar END_POSTFIX = \"end\";\nvar eventAliases = [];\n\nvar addAlias = function (eventName, eventArgs) {\n  eventAliases.push({\n    name: eventName,\n    args: eventArgs\n  });\n};\n\naddAlias(TRANSFORM, {\n  scale: true,\n  deltaScale: true,\n  rotation: true,\n  deltaRotation: true,\n  translation: true,\n  deltaTranslation: true\n});\naddAlias(TRANSLATE, {\n  translation: true,\n  deltaTranslation: true\n});\naddAlias(PINCH, {\n  scale: true,\n  deltaScale: true\n});\naddAlias(ROTATE, {\n  rotation: true,\n  deltaRotation: true\n});\n\nvar getVector = function (first, second) {\n  return {\n    x: second.pageX - first.pageX,\n    y: -second.pageY + first.pageY,\n    centerX: .5 * (second.pageX + first.pageX),\n    centerY: .5 * (second.pageY + first.pageY)\n  };\n};\n\nvar getEventVector = function (e) {\n  var pointers = e.pointers;\n  return getVector(pointers[0], pointers[1]);\n};\n\nvar getDistance = function (vector) {\n  return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n};\n\nvar getScale = function (firstVector, secondVector) {\n  return getDistance(firstVector) / getDistance(secondVector);\n};\n\nvar getRotation = function (firstVector, secondVector) {\n  var scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;\n  var distanceProduct = getDistance(firstVector) * getDistance(secondVector);\n\n  if (0 === distanceProduct) {\n    return 0;\n  }\n\n  var sign = mathSign(firstVector.x * secondVector.y - secondVector.x * firstVector.y);\n  var angle = Math.acos(fitIntoRange(scalarProduct / distanceProduct, -1, 1));\n  return sign * angle;\n};\n\nvar getTranslation = function (firstVector, secondVector) {\n  return {\n    x: firstVector.centerX - secondVector.centerX,\n    y: firstVector.centerY - secondVector.centerY\n  };\n};\n\nvar TransformEmitter = Emitter.inherit({\n  validatePointers: function (e) {\n    return hasTouches(e) > 1;\n  },\n  start: function (e) {\n    this._accept(e);\n\n    var startVector = getEventVector(e);\n    this._startVector = startVector;\n    this._prevVector = startVector;\n\n    this._fireEventAliases(START_POSTFIX, e);\n  },\n  move: function (e) {\n    var currentVector = getEventVector(e);\n\n    var eventArgs = this._getEventArgs(currentVector);\n\n    this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);\n\n    this._prevVector = currentVector;\n  },\n  end: function (e) {\n    var eventArgs = this._getEventArgs(this._prevVector);\n\n    this._fireEventAliases(END_POSTFIX, e, eventArgs);\n  },\n  _getEventArgs: function (vector) {\n    return {\n      scale: getScale(vector, this._startVector),\n      deltaScale: getScale(vector, this._prevVector),\n      rotation: getRotation(vector, this._startVector),\n      deltaRotation: getRotation(vector, this._prevVector),\n      translation: getTranslation(vector, this._startVector),\n      deltaTranslation: getTranslation(vector, this._prevVector)\n    };\n  },\n  _fireEventAliases: function (eventPostfix, originalEvent, eventArgs) {\n    eventArgs = eventArgs || {};\n    iteratorUtils.each(eventAliases, function (_, eventAlias) {\n      var args = {};\n      iteratorUtils.each(eventAlias.args, function (name) {\n        if (name in eventArgs) {\n          args[name] = eventArgs[name];\n        }\n      });\n\n      this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args);\n    }.bind(this));\n  }\n});\nvar eventNames = eventAliases.reduce((result, eventAlias) => {\n  [START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX].forEach(eventPostfix => {\n    result.push(DX_PREFIX + eventAlias.name + eventPostfix);\n  });\n  return result;\n}, []);\nregisterEmitter({\n  emitter: TransformEmitter,\n  events: eventNames\n});\nvar exportNames = {};\niteratorUtils.each(eventNames, function (_, eventName) {\n  exportNames[eventName.substring(DX_PREFIX.length)] = eventName;\n});\nexport var {\n  transformstart: transformstart,\n  transform: transform,\n  transformend: transformend,\n  translatestart: translatestart,\n  translate: translate,\n  translateend: translateend,\n  zoomstart: zoomstart,\n  zoom: zoom,\n  zoomend: zoomend,\n  pinchstart: pinchstart,\n  pinch: pinch,\n  pinchend: pinchend,\n  rotatestart: rotatestart,\n  rotate: rotate,\n  rotateend: rotateend\n} = exportNames;","map":null,"metadata":{},"sourceType":"module"}